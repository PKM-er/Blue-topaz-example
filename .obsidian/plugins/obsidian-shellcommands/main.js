/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var child_process = require('child_process');
var os = require('os');
var path = require('path');
var electron = require('electron');
var fs = require('fs');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

/**
 * If true, logging stuff to console.log() will be enabled.
 * Might also enable some testing {{variables}} in the future, perhaps.
 */
let DEBUG_ON = false;
function setDEBUG_ON(value) {
    DEBUG_ON = value;
}
/**
 * Calls console.log(), but only if debugging is enabled.
 * @param message
 */
function debugLog(message) {
    if (DEBUG_ON) {
        console.log(message);
    }
}

function getVaultAbsolutePath(app) {
    // Original code was copied 2021-08-22 from https://github.com/phibr0/obsidian-open-with/blob/84f0e25ba8e8355ff83b22f4050adde4cc6763ea/main.ts#L66-L67
    // But the code has been rewritten 2021-08-27 as per https://github.com/obsidianmd/obsidian-releases/pull/433#issuecomment-906087095
    const adapter = app.vault.adapter;
    if (adapter instanceof obsidian.FileSystemAdapter) {
        return adapter.getBasePath();
    }
    return null;
}
function getPluginAbsolutePath(plugin) {
    return normalizePath2(path__namespace.join(getVaultAbsolutePath(plugin.app), plugin.app.vault.configDir, "plugins", plugin.getPluginId()));
}
/**
 * For some reason there is no Platform.isWindows .
 */
function isWindows() {
    return process.platform === "win32";
}
/**
 * This is just a wrapper around platform() in order to cast the type to PlatformId.
 * TODO: Consider renaming this to getPlatformId().
 */
function getOperatingSystem() {
    // @ts-ignore In theory, platform() can return an OS name not included in OperatingSystemName. But as Obsidian
    // currently does not support anything else than Windows, Mac and Linux (except mobile platforms, but they are
    // ruled out by the manifest of this plugin), it should be safe to assume that the current OS is one of those
    // three.
    return os.platform();
}
function getView(app) {
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!view) {
        debugLog("getView(): Could not get a view. Will return null.");
        return null;
    }
    return view;
}
function getEditor(app) {
    const view = getView(app);
    if (null === view) {
        // Could not get a view.
        return null;
    }
    // Ensure that view.editor exists! It exists at least if this is a MarkDownView.
    if ("editor" in view) {
        // Good, it exists.
        // @ts-ignore We already know that view.editor exists.
        return view.editor;
    }
    // Did not find an editor.
    debugLog("getEditor(): 'view' does not have a property named 'editor'. Will return null.");
    return null;
}
function cloneObject(object) {
    return Object.assign({}, object);
}
/**
 * Merges two or more objects together. If they have same property names, former objects' properties get overwritten by later objects' properties.
 *
 * @param objects
 */
function combineObjects(...objects) {
    return Object.assign({}, ...objects);
}
/**
 * Same as normalizePath(), but fixes these glitches:
 * - Leading forward slashes / backward slashes should not be removed.
 * - \ should not be converted to / if platform is Windows. In other words, / should be converted to \ if platform is Windows.
 *
 * TODO: I've opened a discussion about this on Obsidian's forums. If anything new comes up in the discussion, make changes accordingly. https://forum.obsidian.md/t/normalizepath-removes-a-leading/24713
 */
function normalizePath2(path) {
    // 1. Preparations
    path = path.trim();
    const leading_slashes_regexp = /^[/\\]*/g; // Get as many / or \ slashes as there are in the very beginning of path. Can also be "" (an empty string).
    let leading_slashes = leading_slashes_regexp.exec(path)[0];
    // 2. Run the original normalizePath()
    path = obsidian.normalizePath(path);
    // 3. Fixes
    // Check that correct slashes are used.
    if (isWindows()) {
        // The platform is Windows.
        // Convert / to \
        path = path.replace(/\//g, "\\"); // Need to use a regexp instead of a normal "/" -> "\\" replace because the normal replace would only replace first occurrence of /.
        leading_slashes = leading_slashes.replace(/\//g, "\\"); // Same here.
    }
    // Now ensure that path still contains leading slashes (if there were any before calling normalizePath()).
    // Check that the path should have a similar set of leading slashes at the beginning. It can be at least "/" (on linux/Mac), or "\\" (on Windows when it's a network path), in theory even "///" or "\\\\\" whatever.
    // normalizePath() seems to remove leading slashes (and they are needed to be re-added), but it's needed to check first, otherwise the path would have double leading slashes if normalizePath() gets fixed in the future.
    if (leading_slashes.length && path.slice(0, leading_slashes.length) !== leading_slashes) {
        // The path does not contain the required set of leading slashes, so add them.
        path = leading_slashes + path;
    }
    // 4. Done
    return path;
}
function extractFileName(file_path) {
    return path__namespace.parse(file_path).base;
}
function joinObjectProperties(object, glue) {
    let result = "";
    for (const property_name in object) {
        if (result.length) {
            result += glue;
        }
        // @ts-ignore
        result += object[property_name];
    }
    return result;
}
/**
 * Removes all duplicates from an array.
 *
 * Idea is copied 2021-10-06 from https://stackoverflow.com/a/33121880/2754026
 */
function uniqueArray(array) {
    return [...new Set(array)];
}
/**
 * Opens a web browser in the specified URL.
 * @param url
 */
function gotoURL(url) {
    electron.shell.openExternal(url); // This returns a promise, but it can be ignored as there's nothing to do after opening the browser.
}
function generateObsidianCommandName(plugin, shell_command, alias) {
    const prefix = plugin.settings.obsidian_command_palette_prefix;
    if (alias) {
        // If an alias is set for the command, Obsidian's command palette should display the alias text instead of the actual command.
        return prefix + alias;
    }
    return prefix + shell_command;
}
function isInteger(value, allow_minus) {
    if (allow_minus) {
        return !!value.match(/^-?\d+$/);
    }
    else {
        return !!value.match(/^\d+$/);
    }
}
/**
 * Translates 1-indexed caret line and column to a 0-indexed EditorPosition object. Also translates a possibly negative line
 * to a positive line from the end of the file, and a possibly negative column to a positive column from the end of the line.
 * @param editor
 * @param caret_line
 * @param caret_column
 */
function prepareEditorPosition(editor, caret_line, caret_column) {
    // Determine line
    if (caret_line < 0) {
        // Negative line means to calculate it from the end of the file.
        caret_line = Math.max(0, editor.lastLine() + caret_line + 1);
    }
    else {
        // Positive line needs just a small adjustment.
        // Editor line is zero-indexed, line numbers are 1-indexed.
        caret_line -= 1;
    }
    // Determine column
    if (caret_column < 0) {
        // Negative column means to calculate it from the end of the line.
        caret_column = Math.max(0, editor.getLine(caret_line).length + caret_column + 1);
    }
    else {
        // Positive column needs just a small adjustment.
        // Editor column is zero-indexed, column numbers are 1-indexed.
        caret_column -= 1;
    }
    return {
        line: caret_line,
        ch: caret_column,
    };
}
function getSelectionFromTextarea(textarea_element, return_null_if_empty) {
    const selected_text = textarea_element.value.substring(textarea_element.selectionStart, textarea_element.selectionEnd);
    return "" === selected_text && return_null_if_empty ? null : selected_text;
}

function newShellCommandConfiguration(shell_command = "") {
    return {
        platform_specific_commands: {
            default: shell_command,
        },
        shells: {},
        alias: "",
        confirm_execution: false,
        ignore_error_codes: [],
        output_channels: {
            stdout: "ignore",
            stderr: "notification",
        },
        output_channel_order: "stdout-first",
        events: {},
        command_palette_availability: "enabled",
    };
}

function getDefaultSettings(is_new_installation) {
    return {
        // Common:
        settings_version: is_new_installation
            ? SC_Plugin.SettingsVersion // For new installations, a specific settings version number can be used, as migrations do not need to be taken into account.
            : "prior-to-0.7.0" // This will be substituted by ShellCommandsPlugin.saveSettings() when the settings are saved.
        ,
        // Hidden settings (no UI controls in the settings panel)
        debug: false,
        obsidian_command_palette_prefix: "Execute: ",
        // Variables:
        preview_variables_in_command_palette: true,
        show_autocomplete_menu: true,
        // Operating systems and shells:
        working_directory: "",
        default_shells: {},
        // Output:
        error_message_duration: 20,
        notification_message_duration: 10,
        output_channel_clipboard_also_outputs_to_notification: true,
        // Events:
        enable_events: true,
        // Shell commands:
        shell_commands: {},
    };
}
const PlatformNames = {
    darwin: "Macintosh",
    linux: "Linux",
    win32: "Windows",
};
const CommandPaletteOptions = {
    enabled: "Command palette & hotkeys",
    unlisted: "Hotkeys only",
    disabled: "Excluded",
};

async function RunMigrations(plugin) {
    const should_save = [
        EnsureMainFieldsExist(plugin),
        MigrateCommandsToShellCommands(plugin),
        MigrateShellCommandToPlatforms(plugin),
        EnsureShellCommandsHaveAllFields(plugin),
        DeleteEmptyCommandsField(plugin),
    ];
    if (should_save.includes(true)) {
        // Only save if there were changes to configuration.
        debugLog("Saving migrations...");
        backupSettingsFile(plugin); // Make a backup copy of the old file BEFORE writing the new, migrated settings file.
        await plugin.saveSettings();
        debugLog("Migrations saved...");
    }
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function MigrateCommandsToShellCommands(plugin) {
    if (undefined === plugin.settings.commands) {
        return false;
    }
    const count_shell_commands = plugin.settings.commands.length;
    let save = false;
    if (0 < count_shell_commands) {
        let count_empty_commands = 0; // A counter for empty or null commands
        debugLog("settings.commands is not empty, will migrate " + count_shell_commands + " commands to settings.shell_commands.");
        for (const shell_command_id in plugin.settings.commands) {
            const shell_command = plugin.settings.commands[shell_command_id];
            // Ensure that the command is not empty. Just in case.
            if (null === shell_command || 0 === shell_command.length) {
                // The command is empty
                debugLog("Migration failure for shell command #" + shell_command_id + ": The original shell command string is empty, so it cannot be migrated.");
                count_empty_commands++;
            }
            else if (undefined !== plugin.settings.shell_commands[shell_command_id]) {
                // A command with the same id already exists
                debugLog("Migration failure for shell command #" + shell_command_id + ": A shell command with same ID already exists in settings.shell_commands.");
            }
            else {
                // All OK, migrate.
                plugin.settings.shell_commands[shell_command_id] = newShellCommandConfiguration(shell_command); // Creates a shell command with default values and defines the command for it.
                delete plugin.settings.commands[shell_command_id]; // Leaves a null in place, but we can deal with it by deleting the whole array if it gets empty.
                count_empty_commands++; // Account the null generated on the previous line.
                save = true;
                debugLog("Migrated shell command #" + shell_command_id + ": " + shell_command);
            }
        }
        if (count_empty_commands === count_shell_commands) {
            // The whole commands array now contains only empty/null commands.
            // Delete it.
            delete plugin.settings.commands;
        }
    }
    else {
        debugLog("settings.commands is empty, so no need to migrate commands. Good thing! :)");
    }
    return save;
}
/**
 * This is a general migrator that adds new, missing properties to ShellCommandConfiguration objects. This is not tied to any specific version update, unlike MigrateCommandsToShellCommands().
 *
 * @param plugin
 * @constructor
 */
function EnsureShellCommandsHaveAllFields(plugin) {
    let save = false;
    const shell_command_default_configuration = newShellCommandConfiguration();
    let shell_command_id;
    const shell_command_configurations = plugin.settings.shell_commands;
    for (shell_command_id in shell_command_configurations) {
        const shell_command_configuration = shell_command_configurations[shell_command_id];
        for (const property_name in shell_command_default_configuration) {
            // @ts-ignore property_default_value can have (almost) whatever datatype
            const property_default_value = shell_command_default_configuration[property_name];
            // @ts-ignore
            if (undefined === shell_command_configuration[property_name]) {
                // This shell command does not have this property.
                // Add the property to the shell command and use a default value.
                debugLog("EnsureShellCommandsHaveAllFields(): Shell command #" + shell_command_id + " does not have property '" + property_name + "'. Will create the property and assign a default value '" + property_default_value + "'.");
                // @ts-ignore
                shell_command_configuration[property_name] = property_default_value;
                save = true;
            }
        }
    }
    return save;
}
/**
 * This is a general migrator that adds new, missing properties to the main settings object. This is not tied to any specific version update, unlike MigrateCommandsToShellCommands().
 *
 * @param plugin
 * @constructor
 */
function EnsureMainFieldsExist(plugin) {
    let has_missing_fields = false;
    const settings = plugin.settings;
    const default_settings = getDefaultSettings(false);
    for (const property_name in default_settings) {
        // @ts-ignore
        if (undefined === settings[property_name]) {
            // The settings object does not have this property.
            // @ts-ignore property_default_value can have (almost) whatever datatype
            const property_default_value = default_settings[property_name];
            debugLog("EnsureMainFieldsExist(): Main settings does not have property '" + property_name + "'. Will later create the property and assign a default value '" + property_default_value + "'.");
            has_missing_fields = true;
        }
    }
    if (has_missing_fields) {
        debugLog("EnsureMainFieldsExist(): Doing the above-mentioned new field creations...");
        plugin.settings = combineObjects(default_settings, plugin.settings);
        debugLog("EnsureMainFieldsExist(): Done.");
        return true; // Save the changes
    }
    debugLog("EnsureMainFieldsExist(): No new fields to create, all ok.");
    return false; // Nothing to save.
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function MigrateShellCommandToPlatforms(plugin) {
    let save = false;
    for (const shell_command_id in plugin.settings.shell_commands) {
        const shell_command_configuration = plugin.settings.shell_commands[shell_command_id];
        if (undefined !== shell_command_configuration.shell_command) {
            // The shell command should be migrated.
            if (undefined === shell_command_configuration.platform_specific_commands || shell_command_configuration.platform_specific_commands.default === "") {
                debugLog("Migrating shell command #" + shell_command_id + ": shell_command string will be moved to platforms.default: " + shell_command_configuration.shell_command);
                shell_command_configuration.platform_specific_commands = {
                    default: shell_command_configuration.shell_command,
                };
                delete shell_command_configuration.shell_command;
                save = true;
            }
            else {
                debugLog("Migration failure for shell command #" + shell_command_id + ": platforms exists already.");
            }
        }
    }
    return save;
}
/**
 * Can be removed in 1.0.0.
 *
 * @param plugin
 * @constructor
 */
function DeleteEmptyCommandsField(plugin) {
    let save = false;
    if (undefined !== plugin.settings.commands) {
        if (plugin.settings.commands.length === 0) {
            delete plugin.settings.commands;
            save = true;
        }
    }
    return save;
}
/**
 * Permanent, do not remove.
 *
 * @param plugin
 */
function backupSettingsFile(plugin) {
    // plugin.app.fileManager.
    // @ts-ignore
    const current_settings_version = (plugin.settings.settings_version === "prior-to-0.7.0") ? "0.x" : plugin.settings.settings_version;
    const plugin_path = getPluginAbsolutePath(plugin);
    const settings_file_path = path__namespace.join(plugin_path, "data.json");
    const backup_file_path_without_extension = path__namespace.join(plugin_path, "data-backup-version-" + current_settings_version + "-before-upgrading-to-" + SC_Plugin.SettingsVersion);
    // Check that the current settings file can be found.
    if (!fs__namespace.existsSync(settings_file_path)) {
        // Not found. Probably the vault uses a different config folder than .obsidian.
        debugLog("backupSettingsFile(): Cannot find data.json");
        plugin.newError("Shell commands: Cannot create a backup of current settings file, because data.json is not found.");
        return;
    }
    let backup_file_path = backup_file_path_without_extension + ".json";
    let running_number = 1;
    while (fs__namespace.existsSync(backup_file_path)) {
        running_number++; // The first number will be 2.
        backup_file_path = backup_file_path_without_extension + "-" + running_number + ".json";
        if (running_number >= 1000) {
            // There is some problem with detecting existing/inexisting files.
            // Prevent hanging the program in an eternal loop.
            throw new Error("backupSettingsFile(): Eternal loop detected.");
        }
    }
    fs__namespace.copyFileSync(settings_file_path, backup_file_path);
}

const PlatformShells = {
    darwin: {
        "/bin/bash": "Bash",
        "/bin/dash": "Dash",
        "/bin/zsh": "Zsh (Z shell)",
    },
    linux: {
        "/bin/bash": "Bash",
        "/bin/dash": "Dash",
        "/bin/zsh": "Zsh (Z shell)",
    },
    win32: {
        "pwsh.exe": "PowerShell Core",
        "PowerShell.exe": "PowerShell 5",
        "CMD.EXE": "cmd.exe",
    },
};
function getUsersDefaultShell() {
    if (isWindows()) {
        return process.env.ComSpec;
    }
    else {
        return process.env.SHELL;
    }
}
function isShellSupported(shell) {
    const shell_file_name = extractFileName(shell);
    const supported_shells = PlatformShells[getOperatingSystem()];
    for (const supported_shell_path in supported_shells) {
        if (supported_shell_path.substr(-shell_file_name.length, shell_file_name.length).toLowerCase() === shell_file_name.toLowerCase()) {
            // If supported_shell_path (e.g. /bin/bash or CMD.EXE) ends with shell_file_name (e.g. bash, derived from /bin/bash or CMD.EXE, derived from C:\System32\CMD.EXE), then the shell can be considered to be supported.
            return true;
        }
    }
    return false;
}

function createShellSelectionField(plugin, container_element, shells, is_global_settings) {
    let platform_id;
    for (platform_id in PlatformNames) {
        const platform_name = PlatformNames[platform_id];
        let options;
        if (is_global_settings) {
            const current_system_default = (getOperatingSystem() === platform_id) ? " (" + extractFileName(getUsersDefaultShell()) + ")" : "";
            options = { "default": "Use system default" + current_system_default };
        }
        else {
            options = { "default": "Use default" };
        }
        for (const shell_path in PlatformShells[platform_id]) {
            // @ts-ignore // TODO: Get rid of these two ts-ignores.
            const shell_name = PlatformShells[platform_id][shell_path];
            // @ts-ignore
            options[shell_path] = shell_name;
        }
        new obsidian.Setting(container_element)
            .setName(platform_name + (is_global_settings ? " default shell" : " shell"))
            .setDesc((is_global_settings ? "Can be overridden by each shell command. " : "") + ("win32" === platform_id ? "Powershell is recommended over cmd.exe, because this plugin does not support escaping variables in CMD." : ""))
            .addDropdown(dropdown => dropdown
            .addOptions(options)
            .setValue(shells[platform_id] ?? "default")
            .onChange(((_platform_id) => {
            return async (value) => {
                if ("default" === value) {
                    // When using default shell, the value should be unset.
                    delete shells[_platform_id];
                }
                else {
                    // Normal case: assign the shell value.
                    shells[_platform_id] = value;
                }
                await plugin.saveSettings();
            };
        })(platform_id)));
    }
}

class OutputChannelDriver {
    constructor() {
        this.accepted_output_streams = ["stdout", "stderr"];
        this.accepts_empty_output = false;
    }
    /**
     * Can be overridden in child classes in order to vary the title depending on output_stream.
     * @param output_stream
     */
    getTitle(output_stream) {
        return this.title;
    }
    initialize(plugin, t_shell_command, shell_command_parsing_result) {
        this.plugin = plugin;
        this.app = plugin.app;
        this.t_shell_command = t_shell_command;
        this.shell_command_parsing_result = shell_command_parsing_result;
    }
    handle(output, error_code) {
        // Qualify output
        if (OutputChannelDriver.isOutputEmpty(output)) {
            // The output is empty
            if (!this.accepts_empty_output) {
                // This OutputChannelDriver does not accept empty output, i.e. empty output should be just ignored.
                debugLog(this.constructor.name + ": Ignoring empty output.");
                return;
            }
        }
        debugLog(this.constructor.name + ": Handling output...");
        // Output is ok.
        // Handle it.
        this._handle(output, error_code);
        debugLog("Output handling is done.");
    }
    acceptsOutputStream(output_stream) {
        return this.accepted_output_streams.contains(output_stream);
    }
    /**
     * Can be moved to a global function isOutputStreamEmpty() if needed.
     * @param output
     * @private
     */
    static isOutputEmpty(output) {
        if (undefined !== output.stderr) {
            return false;
        }
        return undefined === output.stdout || "" === output.stdout;
    }
}

class OutputChannelDriver_Notification extends OutputChannelDriver {
    getTitle(output_stream) {
        switch (output_stream) {
            case "stdout":
                return "Notification balloon";
            case "stderr":
                return "Error balloon";
        }
    }
    _handle(output, error_code) {
        // Iterate output streams.
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, two
        // notifications will be created.
        let output_stream_name;
        for (output_stream_name in output) {
            const output_message = output[output_stream_name];
            switch (output_stream_name) {
                case "stdout":
                    // Normal output
                    this.plugin.newNotification(output_message);
                    break;
                case "stderr":
                    // Error output
                    this.plugin.newError("[" + error_code + "]: " + output_message);
                    break;
            }
        }
    }
}

class OutputChannelDriver_CurrentFile extends OutputChannelDriver {
    _handle(output) {
        const editor = getEditor(this.app);
        const view = getView(this.app);
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
        // will be joined together with " " as a separator.
        const output_message = joinObjectProperties(output, " ");
        if (null === editor) {
            // For some reason it's not possible to get an editor.
            this.plugin.newError("Could not get an editor instance! Please raise an issue in GitHub. The command output is in the next error box:");
            this.plugin.newError(output_message); // Good to output it at least some way.
            debugLog("OutputChannelDriver_CurrentFile: Could not get an editor instance.");
            return;
        }
        // Check if the view is in source mode
        if (null === view) {
            // For some reason it's not possible to get an editor, but it's not a big problem.
            debugLog("OutputChannelDriver_CurrentFile: Could not get a view instance.");
        }
        else {
            // We do have a view
            if ("source" !== view.getMode()) {
                // Warn that the output might go to an unexpected place in the note file.
                this.plugin.newNotification("Note that your active note is not in 'Edit' mode! The output comes visible when you switch to 'Edit' mode again!");
            }
        }
        // Insert into the current file
        this.insertIntoEditor(editor, output_message);
    }
}

class OutputChannelDriver_CurrentFileCaret extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: caret position";
    }
    /**
     * Inserts text into the given editor, at caret position.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        editor.replaceSelection(output_message);
    }
}

class OutputChannelDriver_CurrentFileTop extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: top";
    }
    /**
     * Inserts text into the given editor, at top.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const top_position = editor.offsetToPos(0);
        editor.replaceRange(output_message, top_position);
    }
}

class OutputChannelDriver_StatusBar extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Status bar";
        this.accepts_empty_output = true;
    }
    _handle(output) {
        const status_bar_element = this.getStatusBarElement();
        // Combine stdout and stderr (in case both of them happen to be present).
        const stdout_and_stderr = joinObjectProperties(output, os.EOL + os.EOL).trim(); // Will be an empty string if 'output' is an empty object (i.e. no 'stdout' nor 'stderr').
        // Full output (shown when hovering with mouse)
        status_bar_element.setAttr("aria-label", stdout_and_stderr);
        // Show last line permanently.
        const output_message_lines = stdout_and_stderr.split(/(\r\n|\r|\n)/);
        const last_output_line = output_message_lines[output_message_lines.length - 1];
        status_bar_element.setText(last_output_line);
    }
    getStatusBarElement() {
        if (!this.status_bar_element) {
            this.status_bar_element = this.plugin.addStatusBarItem();
        }
        return this.status_bar_element;
    }
}

class OutputChannelDriver_CurrentFileBottom extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: bottom";
    }
    /**
     * Inserts text into the given editor, at bottom.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const bottom_position = {
            ch: editor.getLine(editor.lastLine()).length,
            line: editor.lastLine(), // ... the last line.
        }; // *) But do not subtract 1, because ch is zero-based, so when .length is used without -1, we are pointing AFTER the last character.
        editor.replaceRange(output_message, bottom_position);
    }
}

class OutputChannelDriver_Clipboard extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Clipboard";
    }
    _handle(output) {
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
        // will be joined together with " " as a separator.
        const output_message = joinObjectProperties(output, " ");
        electron.clipboard.writeText(output_message);
        if (this.plugin.settings.output_channel_clipboard_also_outputs_to_notification) {
            // Notify the user so they know a) what was copied to clipboard, and b) that their command has finished execution.
            this.plugin.newNotification("Copied to clipboard: " + os.EOL + output_message + os.EOL + os.EOL + "(Notification can be turned off in settings.)");
        }
    }
}

class OutputChannelDriver_Modal extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Ask after execution";
    }
    _handle(outputs, error_code) {
        // Initialize a modal and pass outputs
        const modal = new OutputModal(this.plugin, outputs, this.t_shell_command, this.shell_command_parsing_result);
        // Define a possible error code to be shown on the modal.
        if (error_code !== null) {
            modal.setExitCode(error_code);
        }
        // Done
        modal.open();
    }
}
class OutputModal extends obsidian.Modal {
    constructor(plugin, outputs, t_shell_command, shell_command_parsing_result) {
        super(plugin.app);
        this.exit_code = null;
        this.plugin = plugin;
        this.outputs = outputs;
        this.t_shell_command = t_shell_command;
        this.shell_command_parsing_result = shell_command_parsing_result;
    }
    onOpen() {
        // Make the modal scrollable if it has more content than what fits in the screen.
        this.modalEl.addClass("SC-scrollable"); // TODO: Maybe make a common parent class for all SC's modals and do this there?
        // Heading
        const heading = this.shell_command_parsing_result.alias;
        this.titleEl.innerText = heading ? heading : "Shell command output";
        // Shell command preview
        this.modalEl.createEl("pre", { text: this.shell_command_parsing_result.shell_command, attr: { class: "SC-no-margin" } }); // no margin so that exit code will be close.
        // Exit code
        if (this.exit_code !== null) {
            this.modalEl.createEl("small", { text: "Exit code: " + this.exit_code });
        }
        // Outputs
        let is_first = true;
        Object.getOwnPropertyNames(this.outputs).forEach((output_stream) => {
            const output_setting = this.createOutputField(output_stream, this.outputs[output_stream]);
            // Focus on the first output field
            if (is_first) {
                output_setting.controlEl.find("textarea").focus();
                is_first = false;
            }
        });
        // A tip about selecting text.
        this.modalEl.createDiv({
            text: "Tip! If you select something, only the selected text will be used.",
            attr: { class: "setting-item-description" /* A CSS class defined by Obsidian. */ },
        });
    }
    createOutputField(output_stream, output) {
        let output_textarea;
        this.modalEl.createEl("hr", { attr: { class: "SC-no-margin" } });
        // Output stream name
        new obsidian.Setting(this.modalEl)
            .setName(output_stream)
            .setHeading()
            .setClass("SC-no-bottom-border");
        // Textarea
        const textarea_setting = new obsidian.Setting(this.modalEl)
            .addTextArea(textarea => output_textarea = textarea
            .setValue(output));
        textarea_setting.infoEl.addClass("SC-hide"); // Make room for the textarea by hiding the left column.
        textarea_setting.settingEl.addClass("SC-output-channel-modal-textarea-container", "SC-no-top-border");
        // Add controls for redirecting the output to another channel.
        const redirect_setting = new obsidian.Setting(this.modalEl)
            .setDesc("Redirect:")
            .setClass("SC-no-top-border");
        const excluded_output_channels = [
            "notification",
            "modal", // Would not make sense to open a new modal for the same thing.
        ];
        const output_channel_drivers = getOutputChannelDrivers();
        Object.getOwnPropertyNames(output_channel_drivers).forEach((output_channel_name) => {
            // Ensure this channel is not excluded
            if (!excluded_output_channels.contains(output_channel_name)) {
                const output_channel_driver = output_channel_drivers[output_channel_name];
                // Ensure the output channel accepts this output stream. E.g. OutputChannelDriver_OpenFiles does not accept "stderr".
                if (output_channel_driver.acceptsOutputStream(output_stream)) {
                    redirect_setting.addButton(button => button
                        .setButtonText(output_channel_driver.getTitle(output_stream))
                        .onClick(() => {
                        // Redirect output to the selected driver
                        const output_streams = {};
                        const textarea_element = textarea_setting.settingEl.find("textarea");
                        output_streams[output_stream] =
                            getSelectionFromTextarea(textarea_element, true) // Use the selection, or...
                                ?? output_textarea.getValue() // ...use the whole text, if nothing is selected.
                        ;
                        output_channel_driver.initialize(this.plugin, this.t_shell_command, this.shell_command_parsing_result);
                        output_channel_driver.handle(output_streams, this.exit_code);
                        textarea_element.focus(); // Bring the focus back to the textarea in order to show a possible highlight (=selection) again.
                    }));
                }
            }
        });
        return textarea_setting;
    }
    /**
     * Should be called only if an exit code was received.
     *
     * @param exit_code
     */
    setExitCode(exit_code) {
        this.exit_code = exit_code;
    }
}

class OutputChannelDriver_OpenFiles extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Open a file";
        /**
         * This output channel is not suitable for stderr, as stderr can contain unexpected messages.
         * @protected
         */
        this.accepted_output_streams = ["stdout"];
    }
    _handle(output, error_code) {
        let output_stream_name;
        for (output_stream_name in output) {
            // Get parts that define different details about how the file should be opened
            const file_definition = output[output_stream_name].trim(); // Contains at least a file name, and MAYBE: a caret position, new pane option, and view state
            const file_definition_parts = file_definition.split(":");
            // Future compatibility: Ensure there is no newline characters in-between the output.
            // This is to reserve newline usage to future when this output channel will support opening multiple files at once.
            // TODO: Remove this check when multi-file support is implemented.
            if (file_definition.match(/[\r\n]/)) {
                // Bad, the output contains a newline.
                this.plugin.newErrors([
                    "Cannot open file: The output contains linebreaks: " + file_definition,
                    "Linebreaks will be supported in a future version of SC that allows defining multiple files to open at once.",
                ]);
                return;
            }
            // The first part is always the file path
            let open_file_path = file_definition_parts.shift();
            // On Windows: Check if an absolute path was split incorrectly. (E.g. a path starting with "C:\...").
            if (isWindows() && file_definition_parts.length > 0) {
                const combined_path = open_file_path + ":" + file_definition_parts[0];
                if (path__namespace.isAbsolute(combined_path)) {
                    // Yes, the first two parts do form an absolute path together, so they should not be split.
                    open_file_path = combined_path;
                    file_definition_parts.shift(); // Remove the second part so that it won't be accidentally processed in the 'Special features' part.
                }
            }
            // Trim the file path, for being able to use cleaner separation between file name and other parts, e.g: MyFile.md : new-pane
            open_file_path = open_file_path.trim();
            // Special features
            const caret_parts = []; // If caret position is present in file_definition_parts, the first item in this array will be the caret line, the second will be the column. If more parts are present, they will be used for making selections.
            let new_pane = false;
            let can_create_file = false;
            let file_definition_interpreting_failed = false;
            file_definition_parts.forEach((file_definition_part) => {
                file_definition_part = file_definition_part.toLocaleLowerCase().trim(); // .trim() is for being able to use cleaner separation between e.g. different selections: MyFile.md:1:1:1:-1 : 5:1:5:-1
                // Determine the part type
                if (isInteger(file_definition_part, true)) {
                    // This is a number, so consider it as a caret position part.
                    caret_parts.push(parseInt(file_definition_part));
                }
                else {
                    switch (file_definition_part) {
                        case "new-pane":
                            new_pane = true;
                            break;
                        case "can-create-file":
                            can_create_file = true;
                            break;
                        default:
                            this.plugin.newError("Cannot open file: Unrecognised definition part: " + file_definition_part + " in " + file_definition);
                            file_definition_interpreting_failed = true;
                    }
                }
            });
            if (file_definition_interpreting_failed) {
                return;
            }
            // Ensure the path is relative
            if (path__namespace.isAbsolute(open_file_path)) {
                // The path is absolute.
                // Check if it can be converted to relative.
                let vault_absolute_path = getVaultAbsolutePath(this.app);
                if (open_file_path.toLocaleLowerCase().startsWith(vault_absolute_path.toLocaleLowerCase())) {
                    // Converting to relative is possible
                    open_file_path = open_file_path.substr(vault_absolute_path.length); // Get everything after the point where the vault path ends.
                }
                else {
                    // Cannot convert to relative, because the file does not reside in the vault
                    this.plugin.newError("Cannot open file '" + open_file_path + "' as the path is outside this vault.");
                    return;
                }
            }
            // Clean up the file path
            open_file_path = obsidian.normalizePath(open_file_path); // normalizePath() is used on purpose, instead of normalizePath2(), because backslashes \ should be converted to forward slashes /
            this.openFileInTab(open_file_path, new_pane, can_create_file).then(() => {
                // The file is now open
                // Check, did we have a caret position available. If not, do nothing.
                let count_caret_parts = caret_parts.length;
                if (count_caret_parts > 0) {
                    // Yes, a caret position was defined in the output.
                    // Ensure the correct amount of caret position parts.
                    // 0 parts: no caret positioning needs to be done (but in this part of code the amount of parts is always greater than 0).
                    // 1 part: caret line is defined, no column.
                    // 2 parts: caret line and column are defined.
                    // 3 parts: NOT ALLOWED.
                    // 4 parts: selection starting position (line, column) and selection end position (line, column) are defined.
                    // 5 parts or more: NOT ALLOWED. Exception: any number of sets of four parts is allowed, i.e. 8 parts, 12 parts, 16 parts etc. are allowed as they can define multiple selections.
                    const error_message_base = "File opened, but caret cannot be positioned due to an incorrect amount (" + count_caret_parts + ") of numeric values in the output: " + file_definition + os.EOL + os.EOL;
                    if (count_caret_parts == 3) {
                        // Incorrect amount of caret parts
                        this.plugin.newError(error_message_base + "Three numeric parts is an incorrect amount, correct would be 1,2 or 4 parts.");
                        return;
                    }
                    else if (count_caret_parts > 4 && count_caret_parts % 4 !== 0) {
                        // Incorrect amount of caret parts
                        this.plugin.newError(error_message_base + "Perhaps too many numeric parts are defined? If more than four parts are defined, make sure to define complete sets of four parts. The amount of numeric parts needs to be dividable by 4.");
                        return;
                    }
                    // Even though the file is already loaded, rendering it may take some time, thus the height of the content may increase.
                    // For this reason, there needs to be a tiny delay before setting the caret position. If the caret position is set immediately,
                    // the caret will be placed in a correct position, but it might be that the editor does not scroll into correct position, so the
                    // caret might be out of the view, even when it's in a correct place. (Obsidian version 0.13.23).
                    window.setTimeout(() => {
                        const editor = getEditor(this.app);
                        if (editor) {
                            if (count_caret_parts >= 4) {
                                // Selection mode
                                // There can be multiple selections defined
                                const selections = [];
                                while (caret_parts.length) {
                                    const from_line = caret_parts.shift();
                                    const from_column = caret_parts.shift();
                                    const to_line = caret_parts.shift();
                                    const to_column = caret_parts.shift();
                                    selections.push({
                                        anchor: prepareEditorPosition(editor, from_line, from_column),
                                        head: prepareEditorPosition(editor, to_line, to_column),
                                    });
                                }
                                editor.setSelections(selections);
                            }
                            else {
                                // Simple caret mode
                                const caret_line = caret_parts[0];
                                const caret_column = caret_parts[1] ?? 1;
                                editor.setCursor(prepareEditorPosition(editor, caret_line, caret_column));
                            }
                        }
                    }, 500); // 500ms is probably long enough even if a new tab is opened (takes more time than opening a file into an existing tab). This can be made into a setting sometime. If you change this, remember to change it in the documentation, too.
                }
            });
        }
    }
    openFileInTab(file_path, new_pane, can_create_file) {
        // Ensure that the file exists (or can be created)
        const source_path = ""; // TODO: When adding an option for creating new files, read this documentation from Obsidian API's getNewFileParent(): "sourcePath – The path to the current open/focused file, used when the user wants new files to be created “in the same folder”. Use an empty string if there is no active file."
        const file_exists_or_can_be_created = can_create_file || null !== this.app.metadataCache.getFirstLinkpathDest(file_path, source_path);
        if (file_exists_or_can_be_created) {
            // Yes, the file exists (or can be created)
            return this.app.workspace.openLinkText(file_path, source_path, new_pane);
        }
        else {
            // No, the file does not exist, and it may not be created.
            this.plugin.newError("Cannot open file '" + file_path + "', as it does not exist. (If you want to allow file creation, add :can-create-file to the shell command output.)");
        }
    }
}

const output_channel_drivers = {};
// Register output channel drivers
registerOutputChannelDriver("status-bar", new OutputChannelDriver_StatusBar());
registerOutputChannelDriver("notification", new OutputChannelDriver_Notification());
registerOutputChannelDriver("current-file-caret", new OutputChannelDriver_CurrentFileCaret());
registerOutputChannelDriver("current-file-top", new OutputChannelDriver_CurrentFileTop());
registerOutputChannelDriver("current-file-bottom", new OutputChannelDriver_CurrentFileBottom());
registerOutputChannelDriver("open-files", new OutputChannelDriver_OpenFiles());
registerOutputChannelDriver("clipboard", new OutputChannelDriver_Clipboard());
registerOutputChannelDriver("modal", new OutputChannelDriver_Modal());
function handleShellCommandOutput(plugin, t_shell_command, shell_command_parsing_result, stdout, stderr, error_code) {
    // Terminology: Stream = outputs stream from a command, can be "stdout" or "stderr". Channel = a method for this application to present the output ot user, e.g. "notification".
    const shell_command_configuration = t_shell_command.getConfiguration(); // TODO: Refactor OutputChannelDrivers to use TShellCommand instead of the configuration objects directly.
    // Insert stdout and stderr to an object in a correct order
    let output = {};
    if (stdout.length && stderr.length) {
        // Both stdout and stderr have content
        // Decide the output order == Find out which data stream should be processed first, stdout or stderr.
        switch (shell_command_configuration.output_channel_order) {
            case "stdout-first":
                output = {
                    stdout: stdout,
                    stderr: stderr,
                };
                break;
            case "stderr-first":
                output = {
                    stderr: stderr,
                    stdout: stdout,
                };
                break;
        }
    }
    else if (stdout.length) {
        // Only stdout has content
        output = {
            stdout: stdout,
        };
    }
    else if (stderr.length) {
        // Only stderr has content
        output = {
            stderr: stderr,
        };
    }
    else {
        // Neither stdout nor stderr have content
        // Provide empty output, some output channels will process it, while other will just ignore it.
        output = {
            "stdout": "",
        };
    }
    // Should stderr be processed same time with stdout?
    if (shell_command_configuration.output_channels.stdout === shell_command_configuration.output_channels.stderr) {
        // Stdout and stderr use the same channel.
        // Make one handling call.
        handle_stream(plugin, t_shell_command, shell_command_parsing_result, shell_command_configuration.output_channels.stdout, output, error_code);
    }
    else {
        // Stdout and stderr use different channels.
        // Make two handling calls.
        let output_stream_name;
        for (output_stream_name in output) {
            const output_channel_name = shell_command_configuration.output_channels[output_stream_name];
            const output_message = output[output_stream_name];
            const separated_output = {};
            separated_output[output_stream_name] = output_message;
            handle_stream(plugin, t_shell_command, shell_command_parsing_result, output_channel_name, separated_output, error_code);
        }
    }
}
function handle_stream(plugin, t_shell_command, shell_command_parsing_result, output_channel_name, output, error_code) {
    // Check if the output should be ignored
    if ("ignore" !== output_channel_name) {
        // The output should not be ignored.
        // Check that an output driver exists
        if (undefined === output_channel_drivers[output_channel_name]) {
            throw new Error("No output driver found for channel '" + output_channel_name + "'.");
        }
        const driver = output_channel_drivers[output_channel_name];
        // Perform handling the output
        driver.initialize(plugin, t_shell_command, shell_command_parsing_result);
        driver.handle(output, error_code);
    }
}
function getOutputChannelDriversOptionList(output_stream) {
    const list = { ignore: "Ignore" };
    for (const name in output_channel_drivers) {
        const output_channel_driver = output_channel_drivers[name];
        // Check that the stream is suitable for the channel
        if (output_channel_driver.acceptsOutputStream(output_stream)) {
            list[name] = output_channel_driver.getTitle(output_stream);
        }
    }
    return list;
}
function getOutputChannelDrivers() {
    return output_channel_drivers;
}
function registerOutputChannelDriver(name, driver) {
    if (undefined !== output_channel_drivers[name]) {
        throw new Error("OutputChannelDriver named '" + name + "' is already registered!");
    }
    output_channel_drivers[name] = driver;
}

class Escaper {
    constructor(raw_value) {
        this.raw_value = raw_value;
    }
}

/**
 * Prefixes all characters that are not letters, numbers or underscores with a prefix character that can be defined by child classes.
 */
class AllSpecialCharactersEscaper extends Escaper {
    escape() {
        return this.raw_value.replace(/[^\w\d]/g, (special_character) => {
            // Do the replacing in a function in order to avoid a possible $ character to be interpreted by JavaScript to interact with the regex.
            // More information: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter (referenced 2021-11-02.
            return this.prefix + special_character;
        });
    }
}

class ShEscaper extends AllSpecialCharactersEscaper {
    constructor() {
        super(...arguments);
        this.prefix = "\\"; // In *sh, escaping should use a backslash, e.g. "Hello, world!" becomes \"Hello\,\ world\!\"
    }
    escape() {
        return this.replace_newlines(super.escape());
    }
    /**
     * Converts escaped newline characters to a form that the Bourne family shells will interpret as literal newlines,
     * not as ignorable characters.
     *
     * @param escaped_value
     * @private
     */
    replace_newlines(escaped_value) {
        return escaped_value
            .replaceAll(this.prefix + "\r", this.prefix + this.prefix + "r") // Replace a real linefeed with a literal "\\r".
            .replaceAll(this.prefix + "\n", this.prefix + this.prefix + "n") // Replace a real newline with a literal "\\n".
        ;
    }
}

class PowerShellEscaper extends AllSpecialCharactersEscaper {
    constructor() {
        super(...arguments);
        this.prefix = "`"; // In PowerShell, escaping should use a ` character, e.g. "Hello, world!" becomes `"Hello`,` world`!`"
    }
}

function escapeValue(shell, raw_value) {
    shell = extractFileName(shell.toLowerCase());
    let escaper;
    switch (shell) {
        case "bash":
        case "dash":
        case "zsh":
            escaper = new ShEscaper(raw_value);
            break;
        case "powershell.exe": // PowerShell 5 is only available for Windows.
        case "pwsh.exe": // In Windows.
        case "pwsh": // In Linux and Mac. (SC does not actually support using PowerShell on Linux/Mac just yet, but support can be added).
            escaper = new PowerShellEscaper(raw_value);
            break;
        case "cmd.exe":
            // Exception: There is no escaping support for CMD, so all values will be left unescaped when CMD is used. :(
            return raw_value;
        default:
            // Shell was not recognised.
            new obsidian.Notice("EscapeValue(): Unrecognised shell: " + shell);
            throw new Error("EscapeValue(): Unrecognised shell: " + shell);
    }
    return escaper.escape();
}

/**
 * Variables that can be used to inject values to shell commands using {{variable:argument}} syntax.
 */
class Variable {
    /**
     *
     * @param plugin
     * @param shell Used to determine what kind of escaping should be used.
     */
    constructor(plugin, shell) {
        this.error_messages = [];
        /**
         * This contains actual values for parameters.
         * @protected
         */
        this.arguments = {};
        this.plugin = plugin;
        this.app = plugin.app;
        this.shell = shell;
    }
    getValue(escape) {
        const raw_value = this.generateValue();
        if (null === raw_value) {
            // Some error(s) has occurred when generating the variable's value.
            // Prevent passing null to escapeValue().
            return null;
        }
        if (escape) {
            // Value should be escaped.
            return escapeValue(this.shell, raw_value);
        }
        else {
            // A raw, unescaped value is expected.
            return raw_value;
        }
    }
    getVariableName() {
        const child_class = this.constructor;
        return child_class.variable_name;
    }
    getParameters() {
        const child_class = this.constructor;
        return child_class.parameters;
    }
    getParameterSeparator() {
        const child_class = this.constructor;
        return child_class.parameter_separator;
    }
    getPattern() {
        const error_prefix = this.getVariableName() + ".getPattern(): ";
        let pattern = '\{\{\!?' + this.getVariableName();
        for (const parameter_name in this.getParameters()) {
            const parameter = this.getParameters()[parameter_name];
            let parameter_type_pattern = this.getParameterSeparator(); // Here this.parameter_separator (= : ) is included in the parameter value just so that it's not needed to do nested parenthesis to accomplish possible optionality: (:())?. parseShellCommandVariables() will remove the leading : .
            // Check should we use parameter.options or parameter.type.
            if (undefined === parameter.options &&
                undefined === parameter.type) {
                // Neither is defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', neither is defined!");
            }
            else if (undefined !== parameter.options &&
                undefined !== parameter.type) {
                // Both are defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', not both!");
            }
            else if (undefined !== parameter.options) {
                // Use parameter.options
                parameter_type_pattern += parameter.options.join("|" + this.getParameterSeparator()); // E.g. "absolute|:relative" for {{file_path:mode}} variable's 'mode' parameter.
            }
            else {
                // Use parameter.type
                switch (parameter.type) {
                    case "string":
                        parameter_type_pattern += ".*?";
                        break;
                    case "integer":
                        parameter_type_pattern += "\\d+";
                        break;
                    default:
                        throw Error(error_prefix + "Parameter '" + parameter_name + "' has an unrecognised type: " + parameter.type);
                }
            }
            // Add the subpattern to 'pattern'.
            pattern += "(" + parameter_type_pattern + ")";
            if (!parameter.required) {
                // Make the parameter optional.
                pattern += "?";
            }
        }
        pattern += '\}\}';
        return pattern;
    }
    getParameterNames() {
        return Object.getOwnPropertyNames(this.getParameters());
    }
    /**
     * @param parameter_name
     * @param argument At this point 'argument' is always a string, but this method may convert it to another data type, depending on the parameter's data type.
     */
    setArgument(parameter_name, argument) {
        const parameter_type = this.getParameters()[parameter_name].type ?? "string"; // If the variable uses "options" instead of "type", then the type is always "string".
        switch (parameter_type) {
            case "string":
                this.arguments[parameter_name] = argument;
                break;
            case "integer":
                this.arguments[parameter_name] = parseInt(argument);
                break;
        }
    }
    /**
     * Note that error messages can only exist after getValue() is called!
     */
    getErrorMessages() {
        return this.error_messages;
    }
    newErrorMessage(message) {
        const prefix = "{{" + this.getVariableName() + "}}: ";
        this.error_messages.push(prefix + message);
    }
    newErrorMessages(messages) {
        messages.forEach((message) => {
            this.newErrorMessage(message);
        });
    }
    static getAutocompleteItems() {
        let parameter_indicator = "";
        const parameter_names = Object.getOwnPropertyNames(this.parameters)
            .filter(parameter_name => this.parameters[parameter_name].required === true) // Only include mandatory parameters
        ;
        if (parameter_names.length > 0) {
            this.parameter_separator + parameter_names.join(this.parameter_separator);
            parameter_indicator = this.parameter_separator; // When the variable name ends with a parameter separator character, it indicates to a user that an argument should be supplied.
        }
        return [
            // Normal variable
            {
                value: "{{" + this.variable_name + parameter_indicator + "}}",
                help_text: this.help_text + " " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped version of the variable
            {
                value: "{{!" + this.variable_name + parameter_indicator + "}}",
                help_text: this.help_text + " " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{" + this.getVariableName() + "}}</strong>";
    }
    getHelpText() {
        const child_class = this.constructor;
        return child_class.help_text;
    }
    /**
     * For variables that are always available, returns an empty string.
     */
    static getAvailabilityText() {
        return "";
    }
    /**
     * Return type needs to be 'any' so that child classes can return a child type.
     */
    static() {
        return this.constructor;
    }
}
Variable.parameter_separator = ":";
/**
 * A definition for what parameters this variables takes.
 * @protected
 */
Variable.parameters = {};

class Variable_Clipboard extends Variable {
    generateValue() {
        return electron.clipboard.readText();
    }
}
Variable_Clipboard.variable_name = "clipboard";
Variable_Clipboard.help_text = "Gives the content you last copied to your clipboard.";

class Variable_CaretPosition extends Variable {
    generateValue() {
        // Check that we are able to get an editor
        const editor = getEditor(this.app);
        if (null === editor) {
            // Nope.
            this.newErrorMessage("Could not get an editor instance! Please raise an issue in GitHub.");
            return null;
        }
        const position = editor.getCursor('to');
        const line = position.line + 1; // editor position is zero-indexed, line numbers are 1-indexed
        const column = position.ch + 1; // editor position is zero-indexed, column positions are 1-indexed
        if (Object.keys(this.arguments).length > 0) {
            switch (this.arguments.mode.toLowerCase()) {
                case "line":
                    return `${line}`;
                case "column":
                    return `${column}`;
                default:
                    this.newErrorMessage("Unrecognised argument: " + this.arguments.mode);
                    return null;
            }
        }
        else {
            // default case when no args provided
            return `${line}:${column}`;
        }
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + "}}",
                help_text: "Gives the line number and column position of the current caret position as 'line:column'. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            {
                value: "{{" + this.variable_name + ":line}}",
                help_text: "Gives the line number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            {
                value: "{{" + this.variable_name + ":column}}",
                help_text: "Gives the column number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable"
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + "}}",
                help_text: "Gives the line number and column position of the current caret position as 'line:column'. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":line}}",
                help_text: "Gives the line number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":column}}",
                help_text: "Gives the column number of the current caret position. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{caret_position}}</strong>, <strong>{{caret_position:line}}</strong> or <strong>{{caret_position:column}}</strong>";
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> when a note pane is open, not in graph view, nor when viewing non-text files.";
    }
}
Variable_CaretPosition.variable_name = "caret_position";
Variable_CaretPosition.help_text = "Gives the line number and column position of the current caret position as 'line:column'. Get only the line number using {{caret_position:line}}, and only the column with {{caret_position:column}}. Line and column numbers are 1-indexed.";
Variable_CaretPosition.parameters = {
    mode: {
        options: ["line", "column"],
        required: false,
    },
};

class Variable_Date extends Variable {
    generateValue() {
        return obsidian.moment().format(this.arguments.format);
    }
}
Variable_Date.variable_name = "date";
Variable_Date.help_text = "Gives a date/time stamp as per your liking. The \"format\" part can be customized and is mandatory. Formatting options: https://momentjs.com/docs/#/displaying/format/";
Variable_Date.parameters = {
    format: {
        type: "string",
        required: true,
    },
};

/**
 * TODO: Consider creating a decorator class for TFolder and moving this function to be a method in it.
 *
 * @param app
 * @param folder
 * @param mode
 */
function getFolderPath(app, folder, mode) {
    switch (mode.toLowerCase()) {
        case "absolute":
            return normalizePath2(getVaultAbsolutePath(app) + "/" + folder.path);
        case "relative":
            if (folder.isRoot()) {
                // Obsidian API does not give a correct folder.path value for the vault's root folder.
                // TODO: See this discussion and apply possible changes if something will come up: https://forum.obsidian.md/t/vault-root-folders-relative-path-gives/24857
                return ".";
            }
            else {
                // This is a normal subfolder
                return normalizePath2(folder.path); // Normalize to get a correct slash between directories depending on platform. On Windows it should be \ .
            }
    }
}
/**
 * TODO: Consider creating a decorator class for TFile and moving this function to be a method in it.
 *
 * @param app
 * @param file
 * @param mode
 */
function getFilePath(app, file, mode) {
    switch (mode.toLowerCase()) {
        case "absolute":
            return normalizePath2(getVaultAbsolutePath(app) + "/" + file.path);
        case "relative":
            return normalizePath2(file.path); // Normalize to get a correct slash depending on platform. On Windows it should be \ .
    }
}
/**
 * TODO: Consider creating a decorator class for TFile and moving this function to be a method in it.
 * @param file
 * @param with_dot
 */
function getFileExtension(file, with_dot) {
    const file_extension = file.extension;
    // Should the extension be given with or without a dot?
    if (with_dot) {
        // A preceding dot must be included.
        if (file_extension.length > 0) {
            // But only if the extension is not empty.
            return "." + file_extension;
        }
    }
    // No dot should be included, or the extension is empty
    return file_extension;
}
function getFileTags(app, file) {
    const cache = app.metadataCache.getFileCache(file);
    const tags = uniqueArray(obsidian.getAllTags(cache)); // If a tag is defined multiple times in the same file, getTags() returns it multiple times, so use uniqueArray() to iron out duplicates.
    // Remove preceding hash characters. E.g. #tag becomes tag
    tags.forEach((tag, index) => {
        tags[index] = tag.replace("#", "");
    });
    return tags;
}
/**
 * @param app
 * @param file
 * @param property_path
 * @return string|string[] Either a result string, or an array of error messages.
 */
function getFileYAMLValue(app, file, property_path) {
    const error_messages = [];
    const property_parts = property_path.split(".");
    // Validate all property names along the path
    property_parts.forEach((property_name) => {
        if (0 === property_name.length) {
            error_messages.push("YAML property '" + this.arguments.property_name + "' has an empty property name. Remove possible double dots or a preceding/trailing dot.");
        }
    });
    if (error_messages.length > 0) {
        // Failure in property name(s).
        return error_messages;
    }
    const frontmatter = app.metadataCache.getFileCache(file)?.frontmatter;
    // Check that a YAML section is available in the file
    if (undefined === frontmatter) {
        // No it ain't.
        error_messages.push("No YAML frontmatter section is defined for the current file.");
        return error_messages;
    }
    else {
        // A YAML section is available.
        // Read the property's value.
        return nested_read(property_parts, property_path, frontmatter);
    }
    /**
     * @param property_parts Property path split into parts (= property names). The deeper the nesting goes, the fewer values will be left in this array.
     * @param property_path The original, whole property path string.
     * @param yaml_object
     * @return string|string[] Either a result string, or an array of error messages.
     */
    function nested_read(property_parts, property_path, yaml_object) {
        let property_name = property_parts.shift();
        // Check if the property name is a negative numeric index.
        if (property_name.match(/^-\d+$/)) {
            // The property name is a negative number.
            // Check that yaml_object contains at least one element.
            const yaml_object_keys = Object.getOwnPropertyNames(yaml_object).filter(key => key !== "length"); // All _really custom_ yaml keys, not .length
            if (yaml_object_keys.length > 0) {
                // Check if yaml_object happens to be an indexed list.
                let is_indexed_list = true;
                yaml_object_keys.forEach((key) => {
                    if (!key.match(/^\d+$/)) {
                        // At least one non-numeric key was found, so consider the object not to be an indexed list.
                        is_indexed_list = false;
                    }
                });
                if (is_indexed_list) {
                    // The object is an indexed list and property_name is a negative index number.
                    // Translate property_name to a positive index from the end of the list.
                    property_name = Math.max(0, // If a greatly negative index is used (e.g. -999), don't allow the new index to be negative again.
                    yaml_object_keys.length
                        + parseInt(property_name) // Although + is used, this will be a subtraction, because property_name is prefixed with a minus.
                    ).toString();
                }
            }
        }
        // Get a value
        const property_value = yaml_object[property_name];
        // Check if the value is either: not found, object, or literal.
        if (undefined === property_value) {
            // Property was not found.
            error_messages.push("YAML property '" + property_name + "' is not found.");
            return error_messages;
        }
        else if ("object" === typeof property_value) {
            // The value is an object.
            // Check if we have still dot notation parts left in the property path.
            if (0 === property_parts.length) {
                // No dot notation parts are left.
                // Freak out.
                const nested_elements_keys = Object.getOwnPropertyNames(property_value);
                if (nested_elements_keys.length > 0) {
                    error_messages.push("YAML property '" + property_name + "' contains a nested element with keys: " + nested_elements_keys.join(", ") + ". Use e.g. '" + property_path + "." + nested_elements_keys[0] + "' to get its value.");
                }
                else {
                    error_messages.push("YAML property '" + property_name + "' contains a nested element. Use a property name that points to a literal value instead.");
                }
                return error_messages;
            }
            else {
                // Dot notation path still has another property name left, so continue the hunt.
                return nested_read(property_parts, property_path, property_value);
            }
        }
        else {
            // The value is literal, i.e. a string or number.
            if (property_parts.length > 0) {
                error_messages.push("YAML property '" + property_name + "' gives already a literal value '" + property_value.toString() + "', but the argument '" + property_path + "' assumes the property would contain a nested element with the key '" + property_parts[0] + "'.");
                return error_messages;
            }
            else {
                return property_value.toString();
            }
        }
    }
}

class FileVariable extends Variable {
    getFile() {
        const current_file = this.app.workspace.getActiveFile();
        if (!current_file) {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null;
        }
        return current_file;
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> when the active pane contains a file, not in graph view or other non-file view.";
    }
}

class Variable_FileExtension extends FileVariable {
    generateValue() {
        const file = this.getFile();
        if (!file) {
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return getFileExtension(file, this.arguments.dot === "with-dot");
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":no-dot}}",
                help_text: "Gives the current file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":with-dot}}",
                help_text: "Gives the current file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":no-dot}}",
                help_text: "Gives the current file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":with-dot}}",
                help_text: "Gives the current file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{file_extension:with-dot}}</strong> or <strong>{{file_extension:no-dot}}</strong>";
    }
}
Variable_FileExtension.variable_name = "file_extension";
Variable_FileExtension.help_text = "Gives the current file name's ending. Use {{file_extension:with-dot}} to include a preceding dot. If the extension is empty, no dot is added. {{file_extension:no-dot}} never includes a dot.";
Variable_FileExtension.parameters = {
    "dot": {
        options: ["with-dot", "no-dot"],
        required: true,
    },
};

class Variable_FileName extends FileVariable {
    generateValue() {
        const file = this.getFile();
        if (!file) {
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return file.name;
    }
}
Variable_FileName.variable_name = "file_name";
Variable_FileName.help_text = "Gives the current file name with a file extension. If you need it without the extension, use {{title}} instead.";

class Variable_FilePath extends FileVariable {
    generateValue() {
        const active_file = this.getFile();
        if (active_file) {
            return getFilePath(this.app, active_file, this.arguments.mode);
        }
        else {
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{file_path:relative}}</strong> or <strong>{{file_path:absolute}}</strong>";
    }
}
Variable_FilePath.variable_name = "file_path";
Variable_FilePath.help_text = "Gives path to the current file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
Variable_FilePath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};

class FolderVariable extends FileVariable {
    getFolder() {
        // Get current file's parent folder.
        const file = this.getFile();
        if (!file) {
            return null;
        }
        const current_folder = file.parent;
        if (!current_folder) {
            // No parent folder.
            this.newErrorMessage("The current file does not have a parent for some strange reason.");
            return null;
        }
        return current_folder;
    }
}

class Variable_FolderName extends FolderVariable {
    generateValue() {
        const folder = this.getFolder();
        if (!folder) {
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return folder.name;
    }
}
Variable_FolderName.variable_name = "folder_name";
Variable_FolderName.help_text = "Gives the current file's parent folder name. No ancestor folders are included.";

class Variable_FolderPath extends FolderVariable {
    generateValue() {
        const folder = this.getFolder();
        if (folder) {
            return getFolderPath(this.app, folder, this.arguments.mode);
        }
        else {
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file's parent folder, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file's parent folder, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the current file's parent folder, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the current file's parent folder, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{folder_path:relative}}</strong> or <strong>{{folder_path:absolute}}</strong>";
    }
}
Variable_FolderPath.variable_name = "folder_path";
Variable_FolderPath.help_text = "Gives path to the current file's parent folder, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
Variable_FolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    }
};

class Variable_Selection extends Variable {
    generateValue() {
        // Check that we are able to get a view
        const view = getView(this.app);
        if (null === view) {
            // Nope.
            this.newErrorMessage("Could not get a view instance! Please raise an issue in GitHub.");
            return null;
        }
        // Check that we are able to get an editor
        const editor = getEditor(this.app);
        if (null === editor) {
            // Nope.
            this.newErrorMessage("Could not get an editor instance! Please raise an issue in GitHub.");
            return null;
        }
        // Check the view mode
        const view_mode = view.getMode(); // "preview" or "source" (can also be "live" but I don't know when that happens)
        switch (view_mode) {
            case "preview":
                // The leaf is in preview mode, which makes things difficult.
                // We could still return view.editor, but it does not work at least for getting selected text, maybe for other things, but currently this function is only used for getting selected text.
                // At this moment, just return null to indicate that we were not able to offer an editor instance which could work reliably on text selections.
                // FIXME: Make it possible to use this feature also in preview mode.
                debugLog("ShellCommandVariable_Selection: 'view' is in preview mode, and the poor guy who wrote this code, does not know how to return an editor instance that could be used for getting text selection.");
                this.newErrorMessage("You need to turn editing mode on, as I'm not able to get selected text when in preview mode. Blame the one who developed this plugin! This should be fixed in the future.");
                return null;
            case "source":
                // Good, the editor is in "source" mode, so it's possible to get a selection.
                if (editor.somethingSelected()) {
                    return editor.getSelection();
                }
                return "";
        }
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> in <em>Editing</em>/<em>Live preview</em> mode, <strong>not</strong> in <em>Reading</em> mode.";
    }
}
Variable_Selection.variable_name = "selection";
Variable_Selection.help_text = "Gives the currently selected text.";

class Variable_Tags extends FileVariable {
    generateValue() {
        const active_file = this.getFile();
        if (active_file) {
            // We do have an active file
            return getFileTags(this.app, active_file).join(this.arguments.separator);
        }
        else {
            // No file is active at the moment
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
Variable_Tags.variable_name = "tags";
Variable_Tags.help_text = "Gives all tags defined in the current note. Replace the \"separator\" part with a comma, space or whatever characters you want to use as a separator between tags. A separator is always needed to be defined.";
Variable_Tags.parameters = {
    separator: {
        type: "string",
        required: true,
    }
};

class Variable_Title extends FileVariable {
    generateValue() {
        const active_file = this.getFile();
        if (active_file) {
            return active_file.basename;
        }
        return null;
    }
}
Variable_Title.variable_name = "title";
Variable_Title.help_text = "Gives the current file name without a file extension. If you need it with the extension, use {{file_name}} instead.";

class Variable_VaultPath extends Variable {
    generateValue() {
        return getVaultAbsolutePath(this.app);
    }
}
Variable_VaultPath.variable_name = "vault_path";
Variable_VaultPath.help_text = "Gives the Obsidian vault's absolute path from the root of the filesystem. This is the same that is used as a default working directory if you do not define one manually. If you define a working directory manually, this variable won't give you your manually defined directory, it always gives the vault's root directory.";

class Variable_Workspace extends Variable {
    generateValue() {
        // Idea how to access the workspaces plugin is copied 2021-09-15 from https://github.com/Vinzent03/obsidian-advanced-uri/blob/f7ef80d5252481242e69496208e925874209f4aa/main.ts#L168-L179
        // @ts-ignore internalPlugins exists although it's not in obsidian.d.ts.
        const workspaces_plugin = this.app.internalPlugins?.plugins?.workspaces;
        if (!workspaces_plugin) {
            this.newErrorMessage("Workspaces core plugin is not found for some reason. Please raise an issue in GitHub.");
            return null;
        }
        else if (!workspaces_plugin.enabled) {
            this.newErrorMessage("Workspaces core plugin is not enabled.");
            return null;
        }
        const workspace_name = workspaces_plugin.instance?.activeWorkspace;
        if (!workspace_name) {
            this.newErrorMessage("Could not figure out the current workspace's name. Probably you have not loaded a workspace. You can do it e.g. via \"Manage workspaces\" from the left side panel.");
            return null;
        }
        // All ok
        return workspace_name;
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> when the Workspaces core plugin is enabled.";
    }
}
Variable_Workspace.variable_name = "workspace";
Variable_Workspace.help_text = "Gives the current workspace's name.";

class Variable_Passthrough extends Variable {
    generateValue() {
        // Simply return the argument that was received.
        return this.arguments.value;
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> in debug mode.";
    }
}
Variable_Passthrough.variable_name = "passthrough";
Variable_Passthrough.help_text = "Gives the same value that is passed as an argument. Used for testing special characters' escaping.";
Variable_Passthrough.parameters = {
    value: {
        type: "string",
        required: true,
    }
};

class Variable_YAMLValue extends FileVariable {
    generateValue() {
        const active_file = this.getFile();
        if (active_file) {
            // We do have an active file
            const result = getFileYAMLValue(this.app, active_file, this.arguments.property_name);
            if (Array.isArray(result)) {
                // The result contains error message(s).
                this.newErrorMessages(result);
                return null;
            }
            else {
                // The result is ok, it's a string.
                return result;
            }
        }
        else {
            // No file is active at the moment
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
Variable_YAMLValue.variable_name = "yaml_value";
Variable_YAMLValue.help_text = "Reads a single value from the current file's frontmatter. Takes a property name as an argument. You can access nested properties with dot notation: property1.property2";
Variable_YAMLValue.parameters = {
    property_name: {
        type: "string",
        required: true,
    },
};

class EventVariable extends Variable {
    constructor(plugin, shell, sc_event) {
        super(plugin, shell);
        this.sc_event = sc_event;
    }
    /**
     * Every subclass should call this method in their generateValue() before returning a value. If this method returns false,
     * then a variable should not generate a value, as the dependent SC_Event is unavailable.
     *
     * TODO: Change the error system to throw exceptions instead of relying on return values.
     *
     * @protected
     */
    checkSC_EventSupport() {
        // 1. Check generally that an event is happening.
        if (!this.sc_event) {
            this.newErrorMessage("This variable can only be used during events: " + this.static().getSummaryOfSupportedEvents());
            return false;
        }
        // 2. Check particularly which event it is.
        if (!this.static().supportsSC_Event(this.sc_event.getClass())) {
            this.newErrorMessage("This variable does not support event '" + this.sc_event.static().getTitle() + "'. Supported events: " + this.static().getSummaryOfSupportedEvents());
            return false;
        }
        return true;
    }
    static supportsSC_Event(sc_event_class) {
        return this.supported_sc_events.contains(sc_event_class);
    }
    static getSummaryOfSupportedEvents() {
        const sc_event_titles = [];
        this.supported_sc_events.forEach((sc_event_class) => {
            sc_event_titles.push(sc_event_class.getTitle());
        });
        return sc_event_titles.join(", ");
    }
    static getAvailabilityText() {
        return "<strong>Only available</strong> in events: " + this.getSummaryOfSupportedEvents() + ".";
    }
    static() {
        return this.constructor;
    }
}

const DocumentationMainLink = "https://publish.obsidian.md/shellcommands";
const DocumentationVariablesLink = "https://publish.obsidian.md/shellcommands/Variables/Variables+-+general+principles#All+variables";
const DocumentationAutocompleteLink = "https://publish.obsidian.md/shellcommands/Variables/Autocomplete/Autocomplete";
const DocumentationEventsFolderLink = "https://publish.obsidian.md/shellcommands/Events/";
const GitHubLink = "https://github.com/Taitava/obsidian-shellcommands";
const ChangelogLink = "https://github.com/Taitava/obsidian-shellcommands/blob/main/CHANGELOG.md";

/**
 * Named SC_Event instead of just Event, because Event is a class in JavaScript.
 */
class SC_Event {
    constructor(plugin) {
        /**
         * If true, changing the enabled/disabled status of the event permits registering the event immediately, so it can activate
         * anytime. Usually true, but can be set to false if immediate registering tends to trigger the event unnecessarily.
         *
         * Events are always registered when loading the plugin, regardless of this property.
         * @protected
         */
        this.register_after_changing_settings = true;
        this.event_registrations = {};
        this.default_configuration = {
            enabled: false,
        };
        this.plugin = plugin;
        this.app = plugin.app;
        this.subclass_instance = this; // Stores a subclass reference, not a base class reference.
    }
    getClass() {
        return this.subclass_instance.constructor;
    }
    canRegisterAfterChangingSettings() {
        return this.register_after_changing_settings;
    }
    register(t_shell_command) {
        const event_reference = this._register(t_shell_command);
        if (event_reference) {
            this.plugin.registerEvent(event_reference);
            this.event_registrations[t_shell_command.getId()] = event_reference;
        }
    }
    unregister(t_shell_command) {
        // Check if an EventRef is available.
        if (undefined === this.event_registrations[t_shell_command.getId()]) {
            // The event was registered without an EventRef object.
            // Provide a TShellCommand to _unregister() so it can do a custom unregistering.
            this._unregister(t_shell_command);
        }
        else {
            // The event registration had created an EventRef object.
            // Provide the EventRef to _unregister() and forget it afterwards.
            this._unregister(this.event_registrations[t_shell_command.getId()]);
            delete this.event_registrations[t_shell_command.getId()];
        }
    }
    /**
     * Executes a shell command.
     */
    trigger(t_shell_command, parsing_result = undefined) {
        // Check if variables are not yet parsed. (They might be parsed already by SC_MenuEvent).
        if (undefined === parsing_result) {
            // No preparsed shell command exists, so parse now.
            parsing_result = t_shell_command.parseVariables(this);
            // Check the parsing result.
            if (!parsing_result.succeeded) {
                // Errors occurred when parsing variables.
                this.plugin.newErrors(parsing_result.error_messages);
                return;
            }
        }
        // Execute the shell command.
        this.plugin.confirmAndExecuteShellCommand(t_shell_command, parsing_result);
    }
    static getCode() {
        return this.event_code;
    }
    static getTitle() {
        return this.event_title;
    }
    /**
     * @param shell Needed just for being able to instantiate variables.
     */
    getSummaryOfEventVariables(shell) {
        const variable_names = [];
        this.getEventVariables(shell).forEach((variable) => {
            variable_names.push("{{" + variable.getVariableName() + "}}");
        });
        return variable_names.join(", ");
    }
    getEventVariables(shell) {
        const event_variables = [];
        getVariables(this.plugin, shell).forEach((variable) => {
            // Check if the variable is an EventVariable
            if (variable instanceof EventVariable) {
                // Yes it is.
                // Check if the variable supports this particular event.
                if (variable.static().supportsSC_Event(this.getClass())) {
                    // Yes it supports.
                    event_variables.push(variable);
                }
            }
        });
        return event_variables;
    }
    /**
     * Can be overridden in child classes that need custom settings fields.
     *
     * @param enabled
     */
    getDefaultConfiguration(enabled) {
        const configuration = cloneObject(this.default_configuration);
        configuration.enabled = enabled;
        return configuration;
    }
    getConfiguration(t_shell_command) {
        return t_shell_command.getEventConfiguration(this);
    }
    /**
     * Can be overridden in child classes to provide custom configuration fields for ShellCommandsExtraOptionsModal.
     *
     * @param extra_settings_container
     */
    createExtraSettingsFields(extra_settings_container, t_shell_command) {
        // Most classes do not define custom settings, so for those classes this method does not need to do anything.
    }
    /**
     * Returns all the TShellCommand instances that have enabled this event.
     */
    getTShellCommands() {
        const enabled_t_shell_commands = [];
        Object.values(this.plugin.getTShellCommands()).forEach((t_shell_command) => {
            // Check if this event has been enabled for the shell command.
            if (t_shell_command.isSC_EventEnabled(this.static().event_code)) {
                // Yes, it's enabled.
                enabled_t_shell_commands.push(t_shell_command);
            }
        });
        return enabled_t_shell_commands;
    }
    static() {
        return this.constructor;
    }
    /**
     * Child classes can override this to hook into a situation where a user has enabled an event in settings.
     *
     * @param t_shell_command The TShellCommand instance for which this SC_Event was enabled for.
     */
    onAfterEnabling(t_shell_command) {
        // If an SC_Event does not override this hook method, do nothing.
    }
    static getDocumentationLink() {
        return DocumentationEventsFolderLink + encodeURIComponent(this.event_title);
    }
}

class SC_WorkspaceEvent extends SC_Event {
    _register(t_shell_command) {
        // @ts-ignore TODO: Find a way to get a dynamic type for this.workspace_event .
        return this.app.workspace.on(this.workspace_event, this.getTrigger(t_shell_command));
    }
    _unregister(event_reference) {
        this.app.workspace.offref(event_reference);
    }
    getTrigger(t_shell_command) {
        return (...parameters /* Need to have this ugly parameter thing so that subclasses can define their own parameters. */) => this.trigger(t_shell_command);
    }
}

class SC_MenuEvent extends SC_WorkspaceEvent {
    addTShellCommandToMenu(t_shell_command, menu) {
        // Parse shell command variables to get a title
        let title = t_shell_command.getAlias() || t_shell_command.getShellCommand(); // May contain unparsed variables.
        let parsing_result;
        if (this.plugin.settings.preview_variables_in_command_palette) {
            // Parse variables in the title.
            parsing_result = t_shell_command.parseVariables(this);
            if (parsing_result.succeeded) {
                // Override title with a value whose variables are parsed.
                title = parsing_result.alias || parsing_result.shell_command;
            }
        }
        // Add a menu item.
        menu.addItem(item => item
            .setTitle(title)
            .onClick(() => {
            this.trigger(t_shell_command, parsing_result);
        }));
    }
}

class SC_AbstractFileMenuEvent extends SC_MenuEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "file-menu";
    }
    getTrigger(t_shell_command) {
        return (menu, file, source, leaf) => {
            // Check that it's the correct menu: if the SC_Event requires a folder menu, 'file' needs to be a TFile, otherwise it needs to be a TFolder.
            if ((this.file_or_folder === "folder" && file instanceof obsidian.TFolder) || (this.file_or_folder === "file" && file instanceof obsidian.TFile)) {
                // The menu is correct.
                // File/folder for declareExtraVariables()
                switch (this.file_or_folder) {
                    case "file":
                        this.file = file;
                        break;
                    case "folder":
                        this.folder = file;
                        break;
                }
                this.addTShellCommandToMenu(t_shell_command, menu);
            }
        };
    }
}

class SC_Event_FileMenu extends SC_AbstractFileMenuEvent {
    constructor() {
        super(...arguments);
        this.file_or_folder = "file";
    }
    getFile() {
        return this.file;
    }
    getFolder() {
        return this.file.parent;
    }
}
SC_Event_FileMenu.event_code = "file-menu";
SC_Event_FileMenu.event_title = "File menu";

class Variable_EventFileName extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        return this.sc_event.getFile().name;
    }
}
Variable_EventFileName.variable_name = "event_file_name";
Variable_EventFileName.help_text = "Gives the selected file name with a file extension. If you need it without the extension, use {{event_title}} instead.";
Variable_EventFileName.supported_sc_events = [
    SC_Event_FileMenu,
];

class Variable_EventFilePath extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const file = this.sc_event.getFile();
        return getFilePath(this.app, file, this.arguments.mode);
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the selected file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "Gives path to the selected file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "Gives path to the selected file, absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "Gives path to the selected file, relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_path:relative}}</strong> or <strong>{{event_file_path:absolute}}</strong>";
    }
}
Variable_EventFilePath.variable_name = "event_file_path";
Variable_EventFilePath.help_text = "Gives path to the selected file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.";
Variable_EventFilePath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};
Variable_EventFilePath.supported_sc_events = [
    SC_Event_FileMenu,
];

class SC_Event_FolderMenu extends SC_AbstractFileMenuEvent {
    constructor() {
        super(...arguments);
        this.file_or_folder = "folder";
    }
    getFolder() {
        return this.folder;
    }
}
SC_Event_FolderMenu.event_code = "folder-menu";
SC_Event_FolderMenu.event_title = "Folder menu";

class Variable_EventFolderName extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const folder = this.sc_event.getFolder();
        return folder.name;
    }
}
Variable_EventFolderName.variable_name = "event_folder_name";
Variable_EventFolderName.help_text = "File menu: Gives the selected file's parent folder name. Folder menu: Gives the selected folder's name. No ancestor folders are included.";
Variable_EventFolderName.supported_sc_events = [
    SC_Event_FileMenu,
    SC_Event_FolderMenu,
];

class Variable_EventFolderPath extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const folder = this.sc_event.getFolder();
        return getFolderPath(this.app, folder, this.arguments.mode);
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":absolute}}",
                help_text: "File menu: Gives path to the selected file's parent folder. Folder menu: Gives path to the selected folder. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":relative}}",
                help_text: "File menu: Gives path to the selected file's parent folder. Folder menu: Gives path to the selected folder. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":absolute}}",
                help_text: "File menu: Gives path to the selected file's parent folder. Folder menu: Gives path to the selected folder. The path is absolute from the root of the file system. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":relative}}",
                help_text: "File menu: Gives path to the selected file's parent folder. Folder menu: Gives path to the selected folder. The path is relative from the root of the Obsidian vault. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_folder_path:relative}}</strong> or <strong>{{event_folder_path:absolute}}</strong>";
    }
}
Variable_EventFolderPath.variable_name = "event_folder_path";
Variable_EventFolderPath.help_text = "File menu: Gives path to the selected file's parent folder. Folder menu: Gives path to the selected folder. The path is either absolute from the root of the file system, or relative from the root of the Obsidian vault.";
Variable_EventFolderPath.parameters = {
    mode: {
        options: ["absolute", "relative"],
        required: true,
    },
};
Variable_EventFolderPath.supported_sc_events = [
    SC_Event_FileMenu,
    SC_Event_FolderMenu,
];

class Variable_EventTitle extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        return this.sc_event.getFile().basename;
    }
}
Variable_EventTitle.variable_name = "event_title";
Variable_EventTitle.help_text = "Gives the current file name without a file extension. If you need it with the extension, use {{event_file_name}} instead.";
Variable_EventTitle.supported_sc_events = [
    SC_Event_FileMenu,
];

class Variable_EventFileExtension extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const file = this.sc_event.getFile();
        return getFileExtension(file, this.arguments.dot === "with-dot");
    }
    static getAutocompleteItems() {
        return [
            // Normal variables
            {
                value: "{{" + this.variable_name + ":no-dot}}",
                help_text: "Gives the selected file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            {
                value: "{{" + this.variable_name + ":with-dot}}",
                help_text: "Gives the selected file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "normal-variable",
            },
            // Unescaped variables
            {
                value: "{{!" + this.variable_name + ":no-dot}}",
                help_text: "Gives the selected file name's ending without a preceding dot. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
            {
                value: "{{!" + this.variable_name + ":with-dot}}",
                help_text: "Gives the selected file name's ending with a preceding dot. If the extension is empty, no dot is included. " + this.getAvailabilityText(),
                group: "Variables",
                type: "unescaped-variable",
            },
        ];
    }
    getHelpName() {
        return "<strong>{{event_file_extension:with-dot}}</strong> or <strong>{{event_file_extension:no-dot}}</strong>";
    }
}
Variable_EventFileExtension.variable_name = "event_file_extension";
Variable_EventFileExtension.help_text = "Gives the selected file name's ending. Use {{event_file_extension:with-dot}} to include a preceding dot. If the extension is empty, no dot is added. {{event_file_extension:no-dot}} never includes a dot.";
Variable_EventFileExtension.parameters = {
    "dot": {
        options: ["with-dot", "no-dot"],
        required: true,
    },
};
Variable_EventFileExtension.supported_sc_events = [
    SC_Event_FileMenu,
];

class Variable_EventTags extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const file = this.sc_event.getFile();
        return getFileTags(this.app, file).join(this.arguments.separator);
    }
}
Variable_EventTags.variable_name = "event_tags";
Variable_EventTags.help_text = "Gives all tags defined in the selected note. Replace the \"separator\" part with a comma, space or whatever characters you want to use as a separator between tags. A separator is always needed to be defined.";
Variable_EventTags.supported_sc_events = [
    SC_Event_FileMenu,
];
Variable_EventTags.parameters = {
    separator: {
        type: "string",
        required: true,
    }
};

class Variable_EventYAMLValue extends EventVariable {
    generateValue() {
        if (!this.checkSC_EventSupport()) {
            return null;
        }
        const file = this.sc_event.getFile();
        const result = getFileYAMLValue(this.app, file, this.arguments.property_name);
        if (Array.isArray(result)) {
            // The result contains error message(s).
            this.newErrorMessages(result);
            return null;
        }
        else {
            // The result is ok, it's a string.
            return result;
        }
    }
}
Variable_EventYAMLValue.variable_name = "event_yaml_value";
Variable_EventYAMLValue.help_text = "Reads a single value from the selected file's frontmatter. Takes a property name as an argument. You can access nested properties with dot notation: property1.property2";
Variable_EventYAMLValue.parameters = {
    property_name: {
        type: "string",
        required: true,
    },
};
Variable_EventYAMLValue.supported_sc_events = [
    SC_Event_FileMenu,
];

function getVariables(plugin, shell, sc_event) {
    const shell_command_variables = [
        // Normal variables
        new Variable_CaretPosition(plugin, shell),
        new Variable_Clipboard(plugin, shell),
        new Variable_Date(plugin, shell),
        new Variable_FileExtension(plugin, shell),
        new Variable_FileName(plugin, shell),
        new Variable_FilePath(plugin, shell),
        new Variable_FolderName(plugin, shell),
        new Variable_FolderPath(plugin, shell),
        new Variable_Selection(plugin, shell),
        new Variable_Tags(plugin, shell),
        new Variable_Title(plugin, shell),
        new Variable_VaultPath(plugin, shell),
        new Variable_Workspace(plugin, shell),
        new Variable_YAMLValue(plugin, shell),
        // Event variables
        new Variable_EventFileExtension(plugin, shell, sc_event),
        new Variable_EventFileName(plugin, shell, sc_event),
        new Variable_EventFilePath(plugin, shell, sc_event),
        new Variable_EventFolderName(plugin, shell, sc_event),
        new Variable_EventFolderPath(plugin, shell, sc_event),
        new Variable_EventTags(plugin, shell, sc_event),
        new Variable_EventTitle(plugin, shell, sc_event),
        new Variable_EventYAMLValue(plugin, shell, sc_event),
    ];
    if (DEBUG_ON) {
        // Variables that are only designed for 'Shell commands test suite'.
        shell_command_variables.push(new Variable_Passthrough(plugin, shell));
    }
    return shell_command_variables;
}
function getVariableClasses() {
    const shell_command_variables = [
        // Normal variables
        Variable_CaretPosition,
        Variable_Clipboard,
        Variable_Date,
        Variable_FileExtension,
        Variable_FileName,
        Variable_FilePath,
        Variable_FolderName,
        Variable_FolderPath,
        Variable_Selection,
        Variable_Tags,
        Variable_Title,
        Variable_VaultPath,
        Variable_Workspace,
        Variable_YAMLValue,
        // Event variables
        Variable_EventFileExtension,
        Variable_EventFileName,
        Variable_EventFilePath,
        Variable_EventFolderName,
        Variable_EventFolderPath,
        Variable_EventTags,
        Variable_EventTitle,
        Variable_EventYAMLValue,
    ];
    if (DEBUG_ON) {
        // Variables that are only designed for 'Shell commands test suite'.
        shell_command_variables.push(Variable_Passthrough);
    }
    return shell_command_variables;
}

/**
 * @param plugin
 * @param command
 * @param shell
 * @param sc_event Use undefined, if parsing is not happening during an event.
 * @return string|string[] If parsing fails, an array of string error messages is returned. If the parsing succeeds, the parsed shell command will be returned just as a string, not in an array.
 */
function parseShellCommandVariables(plugin, command, shell, sc_event) {
    const variables = getVariables(plugin, shell, sc_event);
    let parsed_command = command; // Create a copy of the variable because we don't want to alter the original value of 'command' during iterating its regex matches.
    for (const variable_index in variables) {
        const variable = variables[variable_index];
        const pattern = new RegExp(variable.getPattern(), "ig"); // i: case-insensitive; g: match all occurrences instead of just the first one.
        const parameter_names = variable.getParameterNames();
        let argument_matches; // Need to prefix with _ because JavaScript reserves the variable name 'arguments'.
        while ((argument_matches = pattern.exec(command)) !== null) {
            // Remove stuff that should not be iterated in a later loop.
            const _arguments = argument_matches.filter((value /* Won't be used */, key) => {
                return "number" === typeof key;
                // This leaves out for example the following non-numeric keys (and their values):
                // - "groups"
                // - "index"
                // - "input"
                // In the future, there can also come more elements that will be skipped. E.g. "indices". See: https://github.com/nothingislost/obsidian-dynamic-highlights/issues/25#issuecomment-1038563990 (referenced 2022-02-22).
            });
            // Get the {{variable}} string that will be substituted (= replaced with the actual value of the variable).
            const substitute = _arguments.shift(); // '_arguments[0]' contains the whole match, not just an argument. Get it and remove it from '_arguments'.
            // Iterate all arguments
            for (const i in _arguments) {
                // Check that the argument is not omitted. It can be omitted (= undefined), if the parameter is optional.
                if (undefined !== _arguments[i]) {
                    // The argument is present.
                    const argument = _arguments[i].slice(1); // .slice(1): Remove a preceding :
                    const parameter_name = parameter_names[i];
                    variable.setArgument(parameter_name, argument);
                }
            }
            // Should the variable's value be escaped? (Usually yes).
            let escape = true;
            if ("{{!" === substitute.slice(0, 3)) { // .slice(0, 3) = get characters 0...2, so stop before 3. The 'end' parameter is confusing.
                // The variable usage begins with {{! instead of {{
                // This means the variable's value should NOT be escaped.
                escape = false;
            }
            // Render the variable
            const variable_value = variable.getValue(escape);
            if (variable.getErrorMessages().length) {
                // There has been a problem and executing the command should be cancelled.
                debugLog("Parsing command " + command + " failed.");
                return variable.getErrorMessages(); // Returning now prevents parsing rest of the variables.
            }
            else {
                parsed_command = parsed_command.replace(substitute, () => {
                    // Do the replacing in a function in order to avoid a possible $ character to be interpreted by JavaScript to interact with the regex.
                    // More information: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter (referenced 2021-11-02.)
                    return variable_value;
                });
            }
        }
    }
    return parsed_command;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var autocomplete = createCommonjsModule(function (module, exports) {
(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {
  /*
   * https://github.com/kraaden/autocomplete
   * Copyright (c) 2016 Denys Krasnoshchok
   * MIT License
   */
  function autocomplete(settings) {
      // just an alias to minimize JS file size
      var doc = document;
      var container = settings.container || doc.createElement("div");
      var containerStyle = container.style;
      var userAgent = navigator.userAgent;
      var mobileFirefox = ~userAgent.indexOf("Firefox") && ~userAgent.indexOf("Mobile");
      var debounceWaitMs = settings.debounceWaitMs || 0;
      var preventSubmit = settings.preventSubmit || false;
      var disableAutoSelect = settings.disableAutoSelect || false;
      // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead
      var keyUpEventName = mobileFirefox ? "input" : "keyup";
      var items = [];
      var inputValue = "";
      var minLen = 2;
      var showOnFocus = settings.showOnFocus;
      var selected;
      var keypressCounter = 0;
      var debounceTimer;
      if (settings.minLength !== undefined) {
          minLen = settings.minLength;
      }
      if (!settings.input) {
          throw new Error("input undefined");
      }
      var input = settings.input;
      container.className = "autocomplete " + (settings.className || "");
      // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
      containerStyle.position = "absolute";
      /**
       * Detach the container from DOM
       */
      function detach() {
          var parent = container.parentNode;
          if (parent) {
              parent.removeChild(container);
          }
      }
      /**
       * Clear debouncing timer if assigned
       */
      function clearDebounceTimer() {
          if (debounceTimer) {
              window.clearTimeout(debounceTimer);
          }
      }
      /**
       * Attach the container to DOM
       */
      function attach() {
          if (!container.parentNode) {
              doc.body.appendChild(container);
          }
      }
      /**
       * Check if container for autocomplete is displayed
       */
      function containerDisplayed() {
          return !!container.parentNode;
      }
      /**
       * Clear autocomplete state and hide container
       */
      function clear() {
          // prevent the update call if there are pending AJAX requests
          keypressCounter++;
          items = [];
          inputValue = "";
          selected = undefined;
          detach();
      }
      /**
       * Update autocomplete position
       */
      function updatePosition() {
          if (!containerDisplayed()) {
              return;
          }
          containerStyle.height = "auto";
          containerStyle.width = input.offsetWidth + "px";
          var maxHeight = 0;
          var inputRect;
          function calc() {
              var docEl = doc.documentElement;
              var clientTop = docEl.clientTop || doc.body.clientTop || 0;
              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
              var scrollTop = window.pageYOffset || docEl.scrollTop;
              var scrollLeft = window.pageXOffset || docEl.scrollLeft;
              inputRect = input.getBoundingClientRect();
              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
              var left = inputRect.left + scrollLeft - clientLeft;
              containerStyle.top = top + "px";
              containerStyle.left = left + "px";
              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
              if (maxHeight < 0) {
                  maxHeight = 0;
              }
              containerStyle.top = top + "px";
              containerStyle.bottom = "";
              containerStyle.left = left + "px";
              containerStyle.maxHeight = maxHeight + "px";
          }
          // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
          calc();
          calc();
          if (settings.customize && inputRect) {
              settings.customize(input, inputRect, container, maxHeight);
          }
      }
      /**
       * Redraw the autocomplete div element with suggestions
       */
      function update() {
          // delete all children from autocomplete DOM container
          while (container.firstChild) {
              container.removeChild(container.firstChild);
          }
          // function for rendering autocomplete suggestions
          var render = function (item, currentValue) {
              var itemElement = doc.createElement("div");
              itemElement.textContent = item.label || "";
              return itemElement;
          };
          if (settings.render) {
              render = settings.render;
          }
          // function to render autocomplete groups
          var renderGroup = function (groupName, currentValue) {
              var groupDiv = doc.createElement("div");
              groupDiv.textContent = groupName;
              return groupDiv;
          };
          if (settings.renderGroup) {
              renderGroup = settings.renderGroup;
          }
          var fragment = doc.createDocumentFragment();
          var prevGroup = "#9?$";
          items.forEach(function (item) {
              if (item.group && item.group !== prevGroup) {
                  prevGroup = item.group;
                  var groupDiv = renderGroup(item.group, inputValue);
                  if (groupDiv) {
                      groupDiv.className += " group";
                      fragment.appendChild(groupDiv);
                  }
              }
              var div = render(item, inputValue);
              if (div) {
                  div.addEventListener("click", function (ev) {
                      settings.onSelect(item, input);
                      clear();
                      ev.preventDefault();
                      ev.stopPropagation();
                  });
                  if (item === selected) {
                      div.className += " selected";
                  }
                  fragment.appendChild(div);
              }
          });
          container.appendChild(fragment);
          if (items.length < 1) {
              if (settings.emptyMsg) {
                  var empty = doc.createElement("div");
                  empty.className = "empty";
                  empty.textContent = settings.emptyMsg;
                  container.appendChild(empty);
              }
              else {
                  clear();
                  return;
              }
          }
          attach();
          updatePosition();
          updateScroll();
      }
      function updateIfDisplayed() {
          if (containerDisplayed()) {
              update();
          }
      }
      function resizeEventHandler() {
          updateIfDisplayed();
      }
      function scrollEventHandler(e) {
          if (e.target !== container) {
              updateIfDisplayed();
          }
          else {
              e.preventDefault();
          }
      }
      function keyupEventHandler(ev) {
          var keyCode = ev.which || ev.keyCode || 0;
          var ignore = settings.keysToIgnore || [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];
          for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {
              var key = ignore_1[_i];
              if (keyCode === key) {
                  return;
              }
          }
          if (keyCode >= 112 /* F1 */ && keyCode <= 123 /* F12 */ && !settings.keysToIgnore) {
              return;
          }
          // the down key is used to open autocomplete
          if (keyCode === 40 /* Down */ && containerDisplayed()) {
              return;
          }
          startFetch(0 /* Keyboard */);
      }
      /**
       * Automatically move scroll bar if selected item is not visible
       */
      function updateScroll() {
          var elements = container.getElementsByClassName("selected");
          if (elements.length > 0) {
              var element = elements[0];
              // make group visible
              var previous = element.previousElementSibling;
              if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                  element = previous;
              }
              if (element.offsetTop < container.scrollTop) {
                  container.scrollTop = element.offsetTop;
              }
              else {
                  var selectBottom = element.offsetTop + element.offsetHeight;
                  var containerBottom = container.scrollTop + container.offsetHeight;
                  if (selectBottom > containerBottom) {
                      container.scrollTop += selectBottom - containerBottom;
                  }
              }
          }
      }
      /**
       * Select the previous item in suggestions
       */
      function selectPrev() {
          if (items.length < 1) {
              selected = undefined;
          }
          else {
              if (selected === items[0]) {
                  selected = items[items.length - 1];
              }
              else {
                  for (var i = items.length - 1; i > 0; i--) {
                      if (selected === items[i] || i === 1) {
                          selected = items[i - 1];
                          break;
                      }
                  }
              }
          }
      }
      /**
       * Select the next item in suggestions
       */
      function selectNext() {
          if (items.length < 1) {
              selected = undefined;
          }
          if (!selected || selected === items[items.length - 1]) {
              selected = items[0];
              return;
          }
          for (var i = 0; i < (items.length - 1); i++) {
              if (selected === items[i]) {
                  selected = items[i + 1];
                  break;
              }
          }
      }
      function keydownEventHandler(ev) {
          var keyCode = ev.which || ev.keyCode || 0;
          if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {
              var containerIsDisplayed = containerDisplayed();
              if (keyCode === 27 /* Esc */) {
                  clear();
              }
              else {
                  if (!containerIsDisplayed || items.length < 1) {
                      return;
                  }
                  keyCode === 38 /* Up */
                      ? selectPrev()
                      : selectNext();
                  update();
              }
              ev.preventDefault();
              if (containerIsDisplayed) {
                  ev.stopPropagation();
              }
              return;
          }
          if (keyCode === 13 /* Enter */) {
              if (selected) {
                  settings.onSelect(selected, input);
                  clear();
              }
              if (preventSubmit) {
                  ev.preventDefault();
              }
          }
      }
      function focusEventHandler() {
          if (showOnFocus) {
              startFetch(1 /* Focus */);
          }
      }
      function startFetch(trigger) {
          // If multiple keys were pressed, before we get an update from server,
          // this may cause redrawing autocomplete multiple times after the last key was pressed.
          // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.
          var savedKeypressCounter = ++keypressCounter;
          var inputText = input.value;
          var cursorPos = input.selectionStart || 0;
          if (inputText.length >= minLen || trigger === 1 /* Focus */) {
              clearDebounceTimer();
              debounceTimer = window.setTimeout(function () {
                  settings.fetch(inputText, function (elements) {
                      if (keypressCounter === savedKeypressCounter && elements) {
                          items = elements;
                          inputValue = inputText;
                          selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];
                          update();
                      }
                  }, trigger, cursorPos);
              }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);
          }
          else {
              clear();
          }
      }
      function blurEventHandler() {
          // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM
          setTimeout(function () {
              if (doc.activeElement !== input) {
                  clear();
              }
          }, 200);
      }
      /**
       * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
       */
      container.addEventListener("mousedown", function (evt) {
          evt.stopPropagation();
          evt.preventDefault();
      });
      /**
       * Fixes #30: autocomplete closes when scrollbar is clicked in IE
       * See: https://stackoverflow.com/a/9210267/13172349
       */
      container.addEventListener("focus", function () { return input.focus(); });
      /**
       * This function will remove DOM elements and clear event handlers
       */
      function destroy() {
          input.removeEventListener("focus", focusEventHandler);
          input.removeEventListener("keydown", keydownEventHandler);
          input.removeEventListener(keyUpEventName, keyupEventHandler);
          input.removeEventListener("blur", blurEventHandler);
          window.removeEventListener("resize", resizeEventHandler);
          doc.removeEventListener("scroll", scrollEventHandler, true);
          clearDebounceTimer();
          clear();
      }
      // setup event handlers
      input.addEventListener("keydown", keydownEventHandler);
      input.addEventListener(keyUpEventName, keyupEventHandler);
      input.addEventListener("blur", blurEventHandler);
      input.addEventListener("focus", focusEventHandler);
      window.addEventListener("resize", resizeEventHandler);
      doc.addEventListener("scroll", scrollEventHandler, true);
      return {
          destroy: destroy
      };
  }

  return autocomplete;

})));

});

/**
 *
 * @param input_element
 * @param autocomplete_items
 * @param call_on_completion A function that will be called when a user has selected a suggestion and performed the autocomplete action. onChange event will not be called, because it would trigger opening the autocomplete menu again, so that's why a separate callback is used.
 */
function createAutocomplete(input_element, autocomplete_items, call_on_completion) {
    autocomplete_items = merge_and_sort_autocomplete_items(autocomplete_items, CustomAutocompleteItems);
    autocomplete({
        input: input_element,
        fetch: (input_value_but_not_used, update) => {
            const max_suggestions = 30;
            // Get the so far typed text - exclude everything that is on the right side of the caret.
            const caret_position = input_element.selectionStart;
            const typed_text = input_element.value.slice(0, caret_position);
            const search_query = get_search_query(typed_text);
            if ("" === search_query.search_text) {
                // No suggestions for empty word.
                update([]);
            }
            else {
                // The word is not empty, so can suggest something.
                let matched_items = autocomplete_items.filter(item => item_match(item, search_query));
                matched_items = matched_items.slice(0, max_suggestions); // Limit to a reasonable amount of suggestions.
                update(matched_items);
            }
        },
        onSelect: (item) => {
            // A user has selected an item to be autocompleted
            // Get the item text and already typed text
            let supplement = item.value;
            let caret_position = input_element.selectionStart;
            const typed_text = input_element.value.slice(0, caret_position);
            const search_query = get_search_query(typed_text);
            const search_text = search_query.search_text;
            // Special case: Check if }} happens to appear after the caret
            const after_caret = input_element.value.slice(caret_position, caret_position + 2);
            if ("}}" === after_caret) {
                // The replacing will happen in a {{variable}}.
                // Do not accidentally insert another }} pair.
                supplement = supplement.replace(/}}$/, ""); // Only removes a trailing }} if there is one.
            }
            // Try to save part of the beginning, in case it seems like not being part of the search query.
            let replace_start = find_starting_position(search_text, supplement); // The length difference of typed_text and search_text will be added here below.
            if (false === replace_start) {
                // This should never happen, but if it does, do not replace anything, just insert.
                replace_start = caret_position;
            }
            else {
                // Adjust the position
                replace_start += typed_text.length - search_text.length;
            }
            // Choose a method for doing the inserting
            if (undefined !== document.execCommand) {
                // execCommand() is deprecated, but available.
                // Use it to do the insertion, because this way an undo history can be preserved.
                input_element.setSelectionRange(replace_start, caret_position); // First select the part that will be replaced, because execCommand() does not support defining positions. This adds a cumbersome selection step to the undo history, but at least undoing works.
                document.execCommand("insertText", false, supplement);
            }
            else {
                // execCommand() is not available anymore.
                // Use setRangeText() to do the insertion. It will clear undo history, but at least the insertion works.
                input_element.setRangeText(supplement, replace_start, caret_position);
            }
            // Move the caret to a logical continuation point
            caret_position = replace_start + supplement.length;
            if (supplement.match(/:}}$/)) {
                // Place the caret after the colon, instead of after }}.
                caret_position -= 2;
            }
            input_element.setSelectionRange(caret_position, caret_position);
            // Call a hook
            call_on_completion(input_element.value);
        },
        render: (item) => {
            const div_element = document.createElement("div");
            div_element.createSpan({ text: item.value, attr: { class: "SC-autocomplete-value" } });
            div_element.createSpan({ text: ": ", attr: { class: "SC-autocomplete-separator" } });
            div_element.createSpan({ attr: { class: "SC-autocomplete-help-text" } }).insertAdjacentHTML("beforeend", item.help_text);
            return div_element;
        },
        minLength: 2,
        className: "SC-autocomplete",
        keysToIgnore: [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */] // Defined just to prevent ignoring left and right keys.
    });
}
function item_match(item, search_query) {
    const item_value = item.value.toLocaleLowerCase();
    const search_text = search_query.search_text.toLocaleLowerCase();
    // Match query type
    if (item.type !== search_query.search_type) {
        // If the query type is different, do not include this item.
        // This can happen e.g. if {{ is typed, and the item is not a variable, or {{! is typed, and the item is not an unescaped variable.
        return false;
    }
    // Match text
    let search_character;
    let search_position = 0;
    for (let search_character_index = 0; search_character_index < search_text.length; search_character_index++) {
        search_character = search_text[search_character_index];
        if (item_value.includes(search_character, search_position)) {
            // This character was found in item_value.
            search_position = item_value.indexOf(search_character, search_position) + 1;
        }
        else {
            // This character was not found.
            return false;
        }
    }
    return true;
}
function find_starting_position(typed_text, supplement) {
    typed_text = typed_text.toLocaleLowerCase();
    supplement = supplement.toLocaleLowerCase();
    for (let supplement_index = supplement.length; supplement_index >= 0; supplement_index--) {
        const partial_supplement = supplement.slice(0, supplement_index);
        if (typed_text.contains(partial_supplement)) {
            return typed_text.indexOf(partial_supplement);
        }
    }
    return false;
}
const CustomAutocompleteItems = [];
function addCustomAutocompleteItems(custom_autocomplete_yaml) {
    // Ensure the content is not empty
    if (0 === custom_autocomplete_yaml.trim().length) {
        return "The content is empty.";
    }
    // Try to parse YAML syntax
    let yaml;
    try {
        yaml = obsidian.parseYaml(custom_autocomplete_yaml);
    }
    catch (error) {
        // A syntax error has appeared.
        return error.message;
    }
    if (null === yaml || typeof yaml !== "object") {
        return "Unable to parse the content due to unknown reason.";
    }
    // Iterate autocomplete item groups
    const group_names = Object.getOwnPropertyNames(yaml);
    group_names.forEach((group_name) => {
        const group_items = yaml[group_name];
        const group_item_values = Object.getOwnPropertyNames(group_items);
        // Iterate all autocomplete items in the group
        group_item_values.forEach((autocomplete_item_value) => {
            const autocomplete_item_label = group_items[autocomplete_item_value];
            if (typeof autocomplete_item_label !== "string") {
                return "Autocomplete item '" + autocomplete_item_value + "' has an incorrect help text type: " + typeof autocomplete_item_label;
            }
            // Determine a correct type for the item
            let type = "other";
            if (autocomplete_item_value.startsWith("{{")) {
                // This is a variable
                type = "normal-variable";
            }
            // The item is ok, add it to the list
            CustomAutocompleteItems.push({
                value: autocomplete_item_value,
                help_text: autocomplete_item_label,
                group: group_name,
                type: type,
            });
            if (type === "normal-variable") {
                // Add an unescaped version of the variable, too
                CustomAutocompleteItems.push({
                    value: autocomplete_item_value.replace(/^{{/, "{{!"),
                    help_text: autocomplete_item_label,
                    group: group_name,
                    type: "unescaped-variable",
                });
            }
        });
    });
    // All ok
    return true;
}
function merge_and_sort_autocomplete_items(...autocomplete_item_sets) {
    const merged_autocomplete_items = [].concat(...autocomplete_item_sets);
    return merged_autocomplete_items.sort((a, b) => {
        // First compare groups
        if (a.group < b.group) {
            // a's group should come before b's group.
            return -1;
        }
        else if (a.group > b.group) {
            // a's group should come after b's group.
            return 1;
        }
        else {
            // The groups are the same.
            // Compare values.
            if (a.value < b.value) {
                // a should come before b.
                return -1;
            }
            else if (a.value > b.value) {
                // a should come after b.
                return 1;
            }
            else {
                // The values are the same.
                // The order does not matter.
                return 0;
            }
        }
    });
}
/**
 * Reduces an input string to the nearest logical word.
 * @param typed_text
 */
function get_search_query(typed_text) {
    let search_text = typed_text.match(/\S*?$/)[0]; // Reduce the text - limit to a single word (= exclude spaces and everything before them).
    let search_type = "other"; // May be overwritten.
    if (search_text.contains("}}")) {
        // The query happens right after a {{variable}}.
        // Make the query string to start after the }} pair, i.e. remove }} and everything before it. This improves the search.
        search_text = search_text.replace(/.+}}/, "");
    }
    if (search_text.contains("{{")) {
        // A {{variable}} is being queried.
        // Make the query string to start from the {{ pair, i.e. remove everything before {{ . This improves the search.
        search_text = search_text.replace(/.+{{/, "{{");
        if (search_text.contains("{{!")) {
            // An _unescaped_ variable is searched for.
            search_type = "unescaped-variable";
        }
        else {
            // A normal variable is searched for.
            search_type = "normal-variable";
        }
    }
    return {
        search_text: search_text,
        search_type: search_type,
    };
}

function getVariableAutocompleteItems() {
    const autocomplete_items = [];
    getVariableClasses().forEach((variable_class) => {
        autocomplete_items.push(...variable_class.getAutocompleteItems());
    });
    return autocomplete_items;
}

function CreateShellCommandFieldCore(plugin, container_element, setting_name, shell_command, shell, show_autocomplete_menu, extra_on_change, shell_command_placeholder = "Enter your command") {
    let setting_group;
    function on_change(shell_command) {
        // Update preview
        setting_group.preview_setting.setDesc(getShellCommandPreview(plugin, shell_command, shell));
        // Let the caller extend this onChange, to preform saving the settings:
        extra_on_change(shell_command);
    }
    setting_group = {
        name_setting: new obsidian.Setting(container_element)
            .setName(setting_name)
            .setClass("SC-name-setting"),
        shell_command_setting: new obsidian.Setting(container_element)
            .addText(text => text
            .setPlaceholder(shell_command_placeholder)
            .setValue(shell_command)
            .onChange(on_change))
            .setClass("SC-shell-command-setting"),
        preview_setting: new obsidian.Setting(container_element)
            .setDesc(getShellCommandPreview(plugin, shell_command, shell))
            .setClass("SC-preview-setting"),
    };
    // Autocomplete menu
    if (show_autocomplete_menu) {
        // @ts-ignore
        const input_element = setting_group.shell_command_setting.settingEl.find("input");
        createAutocomplete(input_element, getVariableAutocompleteItems(), on_change);
    }
    return setting_group;
}
/**
 *
 * @param plugin
 * @param shell_command
 * @public Exported because createShellCommandField uses this.
 */
function getShellCommandPreview(plugin, shell_command, shell) {
    const parsed_shell_command = parseShellCommandVariables(plugin, shell_command, shell);
    if (Array.isArray(parsed_shell_command)) {
        // Variable parsing failed.
        // Return just the first error message, even if there are multiple errors, because the preview space is limited.
        return parsed_shell_command[0];
    }
    // Variable parsing succeeded
    return parsed_shell_command;
}

function createPlatformSpecificShellCommandField(plugin, container_element, t_shell_command, platform_id, show_autocomplete_menu) {
    const platform_name = PlatformNames[platform_id];
    const setting_group = CreateShellCommandFieldCore(plugin, container_element, "Shell command on " + platform_name, t_shell_command.getPlatformSpecificShellCommands()[platform_id] ?? "", t_shell_command.getShell(), show_autocomplete_menu, async (shell_command) => {
        if (shell_command.length) {
            // shell_command is not empty, so it's a normal command.
            t_shell_command.getPlatformSpecificShellCommands()[platform_id] = shell_command;
        }
        else {
            // shell_command is empty, so the default command should be used.
            delete t_shell_command.getPlatformSpecificShellCommands()[platform_id];
        }
        await plugin.saveSettings();
    }, t_shell_command.getDefaultShellCommand());
    setting_group.name_setting.setDesc("If empty, the default shell command will be used on " + platform_name + ".");
    return setting_group;
}

function createTabs(container_element, tabs) {
    const tab_header = container_element.createEl("div", { attr: { class: "SC-tab-header" } });
    const tab_content_containers = {};
    const tab_buttons = {};
    let first_button;
    for (const tab_id in tabs) {
        const tab = tabs[tab_id];
        // Create button
        const button = tab_header.createEl("button", {
            attr: {
                class: "SC-tab-header-button",
                activateTab: "SC-tab-" + tab_id,
            },
        });
        button.onclick = tab_button_clicked;
        obsidian.setIcon(button, tab.icon);
        button.insertAdjacentText("beforeend", " " + tab.title);
        tab_buttons[tab_id] = button;
        // Create content container
        tab_content_containers[tab_id] = container_element.createEl("div", { attr: { class: "SC-tab-content", id: "SC-tab-" + tab_id } });
        // Generate content
        tab.content_generator(tab_content_containers[tab_id]);
        // Memorize the first tab's button
        if (!first_button) {
            first_button = button;
        }
    }
    // Activate the first tab
    if (first_button) {
        first_button.click();
    }
    // Return a TabStructure
    return {
        header: tab_header,
        buttons: tab_buttons,
        contentContainers: tab_content_containers,
    };
}
function tab_button_clicked(event) {
    const tab_button = this; // Use 'this' instead of event.target because this way we'll always get a button element, not an element inside the  button (i.e. an icon).
    // Hide all tab contents and get the max dimensions
    let max_width = 0;
    let max_height = 0;
    const tab_header = tab_button.parentElement;
    const container_element = tab_header.parentElement;
    const tab_contents = container_element.findAll("div.SC-tab-content"); // Do not get all tab contents that exist, because there might be multiple tab systems open at the same time.
    const is_main_settings_modal = container_element.hasClass("vertical-tab-content");
    for (let index in tab_contents) {
        let tab_content = tab_contents[index];
        // Get the maximum tab dimensions so that all tabs can have the same dimensions.
        // But don't do it if this is the main settings modal
        if (!is_main_settings_modal) {
            tab_content.addClass("SC-tab-active"); // Need to make the tab visible temporarily in order to get the dimensions.
            if (tab_content.offsetHeight > max_height) {
                max_height = tab_content.offsetHeight;
            }
            if (tab_content.offsetWidth > max_width) {
                max_width = tab_content.offsetWidth;
            }
        }
        // Finally hide the tab
        tab_content.removeClass("SC-tab-active");
    }
    // Remove active status from all buttons
    const adjacent_tab_buttons = tab_header.findAll(".SC-tab-header-button"); // Do not get all tab buttons that exist, because there might be multiple tab systems open at the same time.
    for (const index in adjacent_tab_buttons) {
        let tab_button = adjacent_tab_buttons[index];
        tab_button.removeClass("SC-tab-active");
    }
    // Activate the clicked tab
    tab_button.addClass("SC-tab-active");
    const activate_tab_id = tab_button.attributes.getNamedItem("activateTab").value;
    const tab_content = document.getElementById(activate_tab_id);
    tab_content.addClass("SC-tab-active");
    // Focus an element (if a focusable element is present)
    tab_content.find(".SC-focus-element-on-tab-opening")?.focus(); // ? = If not found, do nothing.
    // Apply the max dimensions to this tab
    // But don't do it if this is the main settings modal
    if (!is_main_settings_modal) {
        tab_content.style.width = max_width + "px";
        tab_content.style.height = max_height + "px";
    }
    // Do nothing else (I don't know if this is needed or not)
    event.preventDefault();
}

class SC_Event_onLayoutReady extends SC_Event {
    constructor() {
        super(...arguments);
        this.register_after_changing_settings = false;
    }
    _register(t_shell_command) {
        this.app.workspace.onLayoutReady(() => this.trigger(t_shell_command));
        return false; // The base class does not need to register anything.
    }
    _unregister(t_shell_command) {
        // No need to unregister, because this event happens only once when Obsidian starts. If the event is not enabled for a shell command, next time Obsidian starts, this event won't get registered.
    }
}
SC_Event_onLayoutReady.event_code = "on-layout-ready";
SC_Event_onLayoutReady.event_title = "After Obsidian starts";

class SC_Event_onQuit extends SC_WorkspaceEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "quit";
    }
}
SC_Event_onQuit.event_code = "on-quit";
SC_Event_onQuit.event_title = "Before Obsidian quits";

class SC_Event_onActiveLeafChanged extends SC_WorkspaceEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "active-leaf-change";
    }
}
SC_Event_onActiveLeafChanged.event_code = "on-active-leaf-changed";
SC_Event_onActiveLeafChanged.event_title = "After switching the active pane";

class SC_Event_EveryNSeconds extends SC_Event {
    constructor() {
        super(...arguments);
        this.default_configuration = {
            enabled: false,
            seconds: 60,
        };
        this.intervals_ids = {};
    }
    _register(t_shell_command) {
        const milliseconds = this.getConfiguration(t_shell_command).seconds * 1000;
        const interval_id = window.setInterval(() => this.trigger(t_shell_command), milliseconds);
        this.plugin.registerInterval(interval_id);
        this.intervals_ids[t_shell_command.getId()] = interval_id;
        return false; // The base class does not need to register anything.
    }
    _unregister(t_shell_command) {
        window.clearInterval(this.intervals_ids[t_shell_command.getId()]);
    }
    /**
     * Overridden only to change the return type.
     * @param t_shell_command
     * @protected
     */
    getConfiguration(t_shell_command) {
        return super.getConfiguration(t_shell_command);
    }
    createExtraSettingsFields(extra_settings_container, t_shell_command) {
        const configuration = this.getConfiguration(t_shell_command);
        let apply_seconds;
        new obsidian.Setting(extra_settings_container)
            .setName("Seconds")
            .setDesc("Needs to be at least 1. Currently supports only integers.")
            .addText(text => text
            .setValue(configuration.seconds.toString())
            .onChange((raw_value) => {
            apply_seconds = parseInt(raw_value);
            // Don't save here, because the user might still be editing the number.
        }))
            .addButton(button => button
            .setButtonText("Apply")
            .onClick(async () => {
            if (undefined == apply_seconds || apply_seconds === this.getConfiguration(t_shell_command).seconds) {
                new obsidian.Notice("You didn't change the seconds!");
            }
            else if (isNaN(apply_seconds)) {
                new obsidian.Notice("The seconds need to be an integer!");
            }
            else if (apply_seconds <= 0) {
                new obsidian.Notice("The seconds need to be at least 1!");
            }
            else {
                // All ok, save.
                this.getConfiguration(t_shell_command).seconds = apply_seconds;
                await this.plugin.saveSettings();
                // Re-register to apply the change
                this.unregister(t_shell_command);
                this.register(t_shell_command);
                // Done
                this.noticeAboutEnabling(t_shell_command);
            }
        }));
    }
    onAfterEnabling(t_shell_command) {
        this.noticeAboutEnabling(t_shell_command);
    }
    noticeAboutEnabling(t_shell_command) {
        new obsidian.Notice("The shell command will run every " + this.getConfiguration(t_shell_command).seconds + " seconds");
    }
}
SC_Event_EveryNSeconds.event_code = "every-n-seconds";
SC_Event_EveryNSeconds.event_title = "Every n seconds";

class SC_Event_EditorMenu extends SC_MenuEvent {
    constructor() {
        super(...arguments);
        this.workspace_event = "editor-menu";
    }
    getTrigger(t_shell_command) {
        return (menu, editor, view) => {
            this.addTShellCommandToMenu(t_shell_command, menu);
        };
    }
}
SC_Event_EditorMenu.event_code = "editor-menu";
SC_Event_EditorMenu.event_title = "Editor menu";

function getSC_Events(plugin) {
    if (undefined === getSC_Events.events) {
        // Cache the list of SC_Event objects
        getSC_Events.events = [
            new SC_Event_onLayoutReady(plugin),
            new SC_Event_onQuit(plugin),
            new SC_Event_onActiveLeafChanged(plugin),
            new SC_Event_EveryNSeconds(plugin),
            new SC_Event_FileMenu(plugin),
            new SC_Event_FolderMenu(plugin),
            new SC_Event_EditorMenu(plugin),
        ];
    }
    return getSC_Events.events;
}
getSC_Events.events = undefined;

class ExtraOptionsModal extends obsidian.Modal {
    constructor(app, plugin, shell_command_id, setting_group, setting_tab) {
        super(app);
        this.plugin = plugin;
        this.shell_command_id = shell_command_id;
        this.t_shell_command = plugin.getTShellCommands()[shell_command_id];
        this.name_setting = setting_group.name_setting;
        this.setting_tab = setting_tab;
    }
    onOpen() {
        this.modalEl.createEl("h2", { text: this.t_shell_command.getDefaultShellCommand() });
        // Make the modal scrollable if it has more content than what fits in the screen.
        this.modalEl.addClass("SC-scrollable");
        // Tabs
        this.tab_structure = createTabs(this.modalEl, {
            "extra-options-general": {
                title: "General",
                icon: "gear",
                content_generator: (container_element) => {
                    this.tabGeneral(container_element);
                },
            },
            "extra-options-output": {
                title: "Output",
                icon: "lines-of-text",
                content_generator: (container_element) => {
                    this.tabOutput(container_element);
                },
            },
            "extra-options-operating-systems-and-shells": {
                title: "Operating systems & shells",
                icon: "stacked-levels",
                content_generator: (container_element) => {
                    this.tabOperatingSystemsAndShells(container_element);
                },
            },
            "extra-options-events": {
                title: "Events",
                icon: "dice",
                content_generator: (container_element) => {
                    this.tabEvents(container_element);
                },
            },
        });
    }
    tabGeneral(container_element) {
        // Alias field
        new obsidian.Setting(container_element)
            .setName("Alias")
            .setClass("SC-name-setting");
        const alias_setting = new obsidian.Setting(container_element)
            .addText(text => text
            .setValue(this.t_shell_command.getAlias())
            .onChange(async (value) => {
            // Change the actual alias value
            this.t_shell_command.getConfiguration().alias = value;
            // Update Obsidian command palette
            this.t_shell_command.renameObsidianCommand(this.t_shell_command.getShellCommand(), this.t_shell_command.getAlias());
            // UpdateShell commands settings panel
            this.name_setting.setName(generateShellCommandFieldName(this.shell_command_id, this.t_shell_command));
            // Save
            await this.plugin.saveSettings();
        }))
            .setClass("SC-shell-command-setting");
        alias_setting.controlEl.find("input").addClass("SC-focus-element-on-tab-opening"); // Focus without a need to click the field.
        container_element.createEl("p", { text: "If not empty, the alias will be displayed in the command palette instead of the actual command. An alias is never executed as a command." });
        container_element.createEl("p", { text: "You can also use the same {{}} style variables in aliases that are used in shell commands. When variables are used in aliases, they do not affect the command execution in any way, but it's a nice way to reveal what values your command will use, even when an alias hides most of the other technical details. Starting a variable with {{! will prevent escaping special characters in command palette." });
        // Confirm execution field
        new obsidian.Setting(container_element)
            .setName("Ask confirmation before execution")
            .addToggle(toggle => toggle
            .setValue(this.t_shell_command.getConfirmExecution())
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().confirm_execution = value;
            const icon_container = this.name_setting.nameEl.find("span.shell-commands-confirm-execution-icon-container");
            if (this.t_shell_command.getConfirmExecution()) {
                // Show icon
                icon_container.removeClass("SC-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("SC-hide");
            }
            await this.plugin.saveSettings();
        }));
    }
    tabOutput(container_element) {
        // Output channeling
        const stdout_channel_setting = this.newOutputChannelSetting(container_element, "Output channel for stdout", "stdout");
        this.newOutputChannelSetting(container_element, "Output channel for stderr", "stderr", "If both stdout and stderr use the same channel, stderr will be combined to same message with stdout.");
        new obsidian.Setting(container_element)
            .setName("Order of stdout/stderr output")
            .setDesc("When output contains both errors and normal output, which one should be presented first?")
            .addDropdown(dropdown => dropdown
            .addOptions({
            "stdout-first": "Stdout first, then stderr.",
            "stderr-first": "Stderr first, then stdout.",
        })
            .setValue(this.t_shell_command.getOutputChannelOrder())
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().output_channel_order = value;
            await this.plugin.saveSettings();
        }));
        // Focus on the stdout channel dropdown field
        stdout_channel_setting.controlEl.find("select").addClass("SC-focus-element-on-tab-opening");
        // Ignore errors field
        new obsidian.Setting(container_element)
            .setName("Ignore error codes")
            .setDesc("A comma separated list of numbers. If executing a shell command fails with one of these exit codes, no error message will be displayed, and the above stderr channel will be ignored. Stdout channel will still be used for stdout. Error codes must be integers and greater than or equal to 0. Anything else will be removed.")
            .addText(text => text
            .setValue(this.t_shell_command.getIgnoreErrorCodes().join(","))
            .onChange(async (value) => {
            // Parse the string of comma separated numbers
            const ignore_error_codes = [];
            const raw_error_codes = value.split(",");
            for (const i in raw_error_codes) {
                const raw_error_code = raw_error_codes[i];
                const error_code_candidate = parseInt(raw_error_code.trim()); // E.g. an empty string converts to NaN (= Not a Number).
                // Ensure that the error code is not NaN, 0 or a negative number.
                if (!isNaN(error_code_candidate) && error_code_candidate >= 0) {
                    // The candidate is legit.
                    ignore_error_codes.push(error_code_candidate);
                }
            }
            // Save the validated error numbers
            this.t_shell_command.getConfiguration().ignore_error_codes = ignore_error_codes;
            await this.plugin.saveSettings();
            // Update icon
            const icon_container = this.name_setting.nameEl.find("span.shell-commands-ignored-error-codes-icon-container");
            if (this.t_shell_command.getIgnoreErrorCodes().length) {
                // Show icon
                icon_container.setAttr("aria-label", generateIgnoredErrorCodesIconTitle(this.t_shell_command.getIgnoreErrorCodes()));
                icon_container.removeClass("SC-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("SC-hide");
            }
        }));
    }
    tabOperatingSystemsAndShells(container_element) {
        // Platform specific shell commands
        let platform_id;
        let is_first = true;
        for (platform_id in PlatformNames) {
            const setting_group = createPlatformSpecificShellCommandField(this.plugin, container_element, this.t_shell_command, platform_id, this.plugin.settings.show_autocomplete_menu);
            if (is_first) {
                // Focus on the first OS specific shell command field
                setting_group.shell_command_setting.controlEl.find("input").addClass("SC-focus-element-on-tab-opening");
                is_first = false;
            }
        }
        // Platform specific shell selection
        createShellSelectionField(this.plugin, container_element, this.t_shell_command.getShells(), false);
    }
    tabEvents(container_element) {
        // Command palette
        const command_palette_availability_setting = new obsidian.Setting(container_element)
            .setName("Availability in Obsidian's command palette")
            .addDropdown(dropdown => dropdown
            .addOptions(CommandPaletteOptions)
            .setValue(this.t_shell_command.getConfiguration().command_palette_availability)
            .onChange(async (value) => {
            // Store value
            this.t_shell_command.getConfiguration().command_palette_availability = value;
            // Update command palette
            if (this.t_shell_command.canAddToCommandPalette()) {
                // Register to command palette
                this.t_shell_command.registerToCommandPalette();
            }
            else {
                // Unregister from command palette
                this.t_shell_command.unregisterFromCommandPalette();
            }
            // Save
            await this.plugin.saveSettings();
        }));
        // Focus on the command palette availability field
        command_palette_availability_setting.controlEl.find("select").addClass("SC-focus-element-on-tab-opening");
        // Events
        new obsidian.Setting(container_element)
            .setName("Execute this shell command automatically on:")
            .setHeading() // Make the name bold
        ;
        getSC_Events(this.plugin).forEach((sc_event) => {
            const is_event_enabled = this.t_shell_command.isSC_EventEnabled(sc_event.static().getCode());
            const summary_of_extra_variables = sc_event.getSummaryOfEventVariables(this.t_shell_command.getShell());
            new obsidian.Setting(container_element)
                .setName(sc_event.static().getTitle())
                .setDesc(summary_of_extra_variables ? "Additional variables: " + summary_of_extra_variables : "")
                .addToggle(toggle => toggle
                .setValue(is_event_enabled)
                .onChange(async (enable) => {
                if (enable) {
                    // Enable the event
                    this.t_shell_command.enableSC_Event(sc_event);
                    extra_settings_container.style.display = "block"; // Show extra settings
                }
                else {
                    // Disable the event
                    this.t_shell_command.disableSC_Event(sc_event);
                    extra_settings_container.style.display = "none"; // Hide extra settings
                }
                // Save
                await this.plugin.saveSettings();
            }))
                // Documentation icon
                .addExtraButton(icon => icon
                .setIcon("help")
                .onClick(() => gotoURL(sc_event.static().getDocumentationLink()))
                .setTooltip("Documentation: " + sc_event.static().getTitle() + " event"));
            // Extra settings
            const extra_settings_container = container_element.createDiv();
            extra_settings_container.style.display = is_event_enabled ? "block" : "none";
            sc_event.createExtraSettingsFields(extra_settings_container, this.t_shell_command);
        });
    }
    activateTab(tab_id) {
        if (undefined === this.tab_structure.buttons[tab_id]) {
            throw Error("Invalid tab id: " + tab_id);
        }
        this.tab_structure.buttons[tab_id].click();
    }
    newOutputChannelSetting(container_element, title, output_stream_name, description = "") {
        const output_channel_options = getOutputChannelDriversOptionList(output_stream_name);
        return new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description)
            .addDropdown(dropdown => dropdown
            .addOptions(output_channel_options)
            .setValue(this.t_shell_command.getOutputChannels()[output_stream_name])
            .onChange(async (value) => {
            this.t_shell_command.getConfiguration().output_channels[output_stream_name] = value;
            await this.plugin.saveSettings();
        }));
    }
}
ExtraOptionsModal.GENERAL_OPTIONS_SUMMARY = "Alias, Confirmation";
ExtraOptionsModal.OUTPUT_OPTIONS_SUMMARY = "Stdout/stderr handling, Ignore errors";
ExtraOptionsModal.OPERATING_SYSTEMS_AND_SHELLS_OPTIONS_SUMMARY = "Shell selection, Operating system specific shell commands";
ExtraOptionsModal.EVENTS_SUMMARY = "Events";

class DeleteModal extends obsidian.Modal {
    constructor(plugin, shell_command_id, setting_group, container_element) {
        super(plugin.app);
        this.plugin = plugin;
        this.shell_command_id = shell_command_id;
        this.t_shell_command = plugin.getTShellCommands()[shell_command_id];
        this.setting_group = setting_group;
        this.container_element = container_element;
    }
    onOpen() {
        this.modalEl.createEl("h2", { text: "Delete: " + this.t_shell_command.getShellCommand() });
        if (this.t_shell_command.getAlias()) {
            this.modalEl.createEl("p", { text: "Alias: " + this.t_shell_command.getAlias() });
        }
        this.modalEl.createEl("p", { text: "Are you sure you want to delete this shell command?" });
        const delete_button = this.modalEl.createEl("button", { text: "Yes, delete" });
        delete_button.onclick = async () => {
            // Unregister possible events in order to prevent them becoming ghosts that just keep executing even after removing the configuration.
            this.t_shell_command.unregisterSC_Events();
            // Remove the command
            debugLog("Command " + this.shell_command_id + " gonna be removed.");
            this.t_shell_command.unregisterFromCommandPalette(); // Remove from the command palette.
            delete this.plugin.getTShellCommands()[this.shell_command_id]; // Remove the TShellCommand object.
            delete this.plugin.settings.shell_commands[this.shell_command_id]; // Remove from the plugin's settings.
            // Remove the setting fields
            this.container_element.removeChild(this.setting_group.name_setting.settingEl);
            this.container_element.removeChild(this.setting_group.shell_command_setting.settingEl);
            this.container_element.removeChild(this.setting_group.preview_setting.settingEl);
            await this.plugin.saveSettings();
            debugLog("Command removed.");
            this.close();
        };
    }
}

/**
 * TODO: Move this to TShellCommand.
 */
function getHotkeysForShellCommand(plugin, shell_command_id) {
    // Retrieve all hotkeys set by user.
    // @ts-ignore
    const app_custom_hotkeys = plugin.app.hotkeyManager?.customKeys;
    if (!app_custom_hotkeys) {
        debugLog("getHotkeysForShellCommand() failed, will return an empty array.");
        return [];
    }
    // Get only our hotkeys.
    const hotkey_index = plugin.getPluginId() + ":" + plugin.generateObsidianCommandId(shell_command_id); // E.g. "obsidian-shellcommands:shell-command-0"
    debugLog("getHotkeysForShellCommand() succeeded.");
    return app_custom_hotkeys[hotkey_index] ?? []; // If no hotkey array is set for this command, return an empty array. Although I do believe that all commands do have an array anyway, but have this check just in case.
}
/**
 * TODO: Is there a way to make Obsidian do this conversion for us?
 *
 * @param hotkey
 * @constructor
 */
function HotkeyToString(hotkey) {
    const keys = [];
    hotkey.modifiers.forEach((modifier) => {
        let modifier_key = modifier.toString(); // This is one of 'Mod' | 'Ctrl' | 'Meta' | 'Shift' | 'Alt'
        if ("Mod" === modifier_key) {
            // Change "Mod" to something more meaningful.
            modifier_key = obsidian.Platform.isMacOS ? "Cmd" : "Ctrl"; // isMacOS should also be true if the device is iPhone/iPad. Can be handy if this plugin gets mobile support some day.
        }
        keys.push(modifier_key);
    });
    keys.push(hotkey.key); // This is something like a letter ('A', 'B' etc) or space/enter/whatever.
    return keys.join(" + ");
}

/**
 *
 * @param plugin
 * @param container_element
 * @param shell_command_id Either a string formatted integer ("0", "1" etc) or "new" if it's a field for a command that does not exist yet.
 * @param show_autocomplete_menu
 */
function createShellCommandField(plugin, container_element, shell_command_id, show_autocomplete_menu) {
    const is_new = "new" === shell_command_id;
    let t_shell_command;
    if (is_new) {
        // Create an empty command
        t_shell_command = plugin.newTShellCommand();
        shell_command_id = t_shell_command.getId(); // Replace "new" with a real id.
    }
    else {
        // Use an old shell command
        t_shell_command = plugin.getTShellCommands()[shell_command_id];
    }
    debugLog("Create command field for command #" + shell_command_id + (is_new ? " (NEW)" : ""));
    let shell_command;
    if (is_new) {
        shell_command = "";
    }
    else {
        shell_command = t_shell_command.getDefaultShellCommand();
    }
    const setting_group = CreateShellCommandFieldCore(plugin, container_element, generateShellCommandFieldName(shell_command_id, t_shell_command), shell_command, t_shell_command.getShell(), show_autocomplete_menu, async (shell_command) => {
        if (is_new) {
            debugLog("Creating new command " + shell_command_id + ": " + shell_command);
        }
        else {
            debugLog("Command " + shell_command_id + " gonna change to: " + shell_command);
        }
        // Do this in both cases, when creating a new command and when changing an old one:
        t_shell_command.getConfiguration().platform_specific_commands.default = shell_command;
        if (is_new) {
            // Create a new command
            // plugin.registerShellCommand(t_shell_command); // I don't think this is needed to be done anymore
            debugLog("Command created.");
        }
        else {
            // Change an old command
            t_shell_command.renameObsidianCommand(t_shell_command.getShellCommand(), t_shell_command.getAlias()); // Change the command's name in Obsidian's command palette and in hotkey settings.
            debugLog("Command changed.");
        }
        await plugin.saveSettings();
    });
    // Icon buttons
    setting_group.name_setting
        .addExtraButton(button => button
        .setTooltip("Execute now")
        .setIcon("run-command")
        .onClick(() => {
        // Execute the shell command now (for trying it out in the settings)
        const t_shell_command = plugin.getTShellCommands()[shell_command_id]; // TODO: Is this redundant? Could the t_shell_command defined in lines 22 / 26 (near 'const is_new') be used?
        const parsing_result = t_shell_command.parseVariables();
        if (parsing_result.succeeded) {
            plugin.confirmAndExecuteShellCommand(t_shell_command, parsing_result);
        }
        else {
            plugin.newErrors(parsing_result.error_messages);
        }
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.GENERAL_OPTIONS_SUMMARY)
        .onClick(async () => {
        // Open an extra options modal: General tab
        const modal = new ExtraOptionsModal(plugin.app, plugin, shell_command_id, setting_group, this);
        modal.open();
        modal.activateTab("extra-options-general");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.OUTPUT_OPTIONS_SUMMARY)
        .setIcon("lines-of-text")
        .onClick(async () => {
        // Open an extra options modal: Output tab
        const modal = new ExtraOptionsModal(plugin.app, plugin, shell_command_id, setting_group, this);
        modal.open();
        modal.activateTab("extra-options-output");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.OPERATING_SYSTEMS_AND_SHELLS_OPTIONS_SUMMARY)
        .setIcon("stacked-levels")
        .onClick(async () => {
        // Open an extra options modal: Operating systems and shells tab
        const modal = new ExtraOptionsModal(plugin.app, plugin, shell_command_id, setting_group, this);
        modal.open();
        modal.activateTab("extra-options-operating-systems-and-shells");
    }))
        .addExtraButton(button => button
        .setTooltip(ExtraOptionsModal.EVENTS_SUMMARY)
        .setIcon("dice")
        .onClick(async () => {
        // Open an extra options modal: Operating systems and shells tab
        const modal = new ExtraOptionsModal(plugin.app, plugin, shell_command_id, setting_group, this);
        modal.open();
        modal.activateTab("extra-options-events");
    }))
        .addExtraButton(button => button
        .setTooltip("Delete this shell command")
        .setIcon("trash")
        .onClick(async () => {
        // Open a delete modal
        const modal = new DeleteModal(plugin, shell_command_id, setting_group, container_element);
        modal.open();
    }));
    // Informational icons (= non-clickable)
    const icon_container = setting_group.name_setting.nameEl.createEl("span", { attr: { class: "SC-main-icon-container" } });
    // "Ask confirmation" icon.
    const confirm_execution_icon_container = icon_container.createEl("span", { attr: { "aria-label": "Asks confirmation before execution.", class: "shell-commands-confirm-execution-icon-container" } });
    obsidian.setIcon(confirm_execution_icon_container, "languages");
    if (!t_shell_command.getConfirmExecution()) {
        // Do not display the icon for commands that do not use confirmation.
        confirm_execution_icon_container.addClass("SC-hide");
    }
    // "Ignored error codes" icon
    const ignored_error_codes_icon_container = icon_container.createEl("span", { attr: { "aria-label": generateIgnoredErrorCodesIconTitle(t_shell_command.getIgnoreErrorCodes()), class: "shell-commands-ignored-error-codes-icon-container" } });
    obsidian.setIcon(ignored_error_codes_icon_container, "strikethrough-glyph");
    if (!t_shell_command.getIgnoreErrorCodes().length) {
        // Do not display the icon for commands that do not ignore any errors.
        ignored_error_codes_icon_container.addClass("SC-hide");
    }
    // Add hotkey information
    if (!is_new) {
        const hotkeys = getHotkeysForShellCommand(plugin, shell_command_id);
        if (hotkeys) {
            let hotkeys_joined = "";
            hotkeys.forEach((hotkey) => {
                if (hotkeys_joined) {
                    hotkeys_joined += "<br>";
                }
                hotkeys_joined += HotkeyToString(hotkey);
            });
            const hotkey_div = setting_group.preview_setting.controlEl.createEl("div", { attr: { class: "setting-item-description SC-hotkey-info" } });
            // Comment out the icon because it would look like a clickable button (as there are other clickable icons in the settings).
            // setIcon(hotkey_div, "any-key", 22); // Hotkey icon
            hotkey_div.insertAdjacentHTML("beforeend", " " + hotkeys_joined);
        }
    }
    debugLog("Created.");
}
/**
 * @param shell_command_id String like "0" or "1" etc. TODO: Remove this parameter and use id from t_shell_command.
 * @param t_shell_command
 * @public Exported because ShellCommandExtraOptionsModal uses this too.
 */
function generateShellCommandFieldName(shell_command_id, t_shell_command) {
    if (t_shell_command.getAlias()) {
        return t_shell_command.getAlias();
    }
    return "Command #" + shell_command_id;
}
/**
 * @param ignored_error_codes
 * @public Exported because ShellCommandExtraOptionsModal uses this too.
 */
function generateIgnoredErrorCodesIconTitle(ignored_error_codes) {
    const plural = ignored_error_codes.length !== 1 ? "s" : "";
    return "Ignored error" + plural + ": " + ignored_error_codes.join(",");
}

class SC_MainSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.last_position = {
            scroll_position: 0,
            tab_name: "main-shell-commands",
        };
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        this.tab_structure = createTabs(containerEl, {
            "main-shell-commands": {
                title: "Shell commands",
                icon: "run-command",
                content_generator: (container_element) => {
                    this.tabShellCommands(container_element);
                },
            },
            "main-operating-systems-and-shells": {
                title: "Operating systems & shells",
                icon: "stacked-levels",
                content_generator: (container_element) => {
                    this.tabOperatingSystemsAndShells(container_element);
                },
            },
            "main-output": {
                title: "Output",
                icon: "lines-of-text",
                content_generator: (container_element) => {
                    this.tabOutput(container_element);
                },
            },
            "main-events": {
                title: "Events",
                icon: "dice",
                content_generator: (container_element) => {
                    this.tabEvents(container_element);
                },
            },
            "main-variables": {
                title: "Variables",
                icon: "code-glyph",
                content_generator: (container_element) => {
                    this.tabVariables(container_element);
                },
            },
        });
        // Documentation link & GitHub links
        containerEl.createEl("p").insertAdjacentHTML("beforeend", "<a href=\"" + DocumentationMainLink + "\">Documentation</a> - " +
            "<a href=\"" + GitHubLink + "\">SC on GitHub</a> - " +
            "<a href=\"" + ChangelogLink + "\">SC version: " + this.plugin.getPluginVersion() + "</a>");
        // KEEP THIS AFTER CREATING ALL ELEMENTS:
        this.rememberLastPosition(containerEl);
    }
    tabShellCommands(container_element) {
        // A <div> element for all command input fields. New command fields can be created at the bottom of this element.
        const command_fields_container = container_element.createEl("div");
        // Fields for modifying existing commands
        for (const command_id in this.plugin.getTShellCommands()) {
            createShellCommandField(this.plugin, command_fields_container, command_id, this.plugin.settings.show_autocomplete_menu);
        }
        // "New command" button
        new obsidian.Setting(container_element)
            .addButton(button => button
            .setButtonText("New command")
            .onClick(async () => {
            createShellCommandField(this.plugin, command_fields_container, "new", this.plugin.settings.show_autocomplete_menu);
            debugLog("New empty command created.");
        }));
    }
    tabEvents(container_element) {
        // A general description about events
        container_element.createEl("p", { text: "Events introduce a way to execute shell commands automatically in certain situations, e.g. when Obsidian starts. They are set up for each shell command separately, but this tab contains general options for them." });
        // Enable/disable all events
        new obsidian.Setting(container_element)
            .setName("Enable events")
            .setDesc("This is a quick way to immediately turn off all events, if you want.")
            .addToggle(toggle => toggle
            .setValue(this.plugin.settings.enable_events)
            .onChange(async (enable_events) => {
            // The toggle was clicked.
            this.plugin.settings.enable_events = enable_events;
            if (enable_events) {
                // Register events.
                this.plugin.registerSC_Events(true);
            }
            else {
                // Unregister events.
                this.plugin.unregisterSC_Events();
            }
            await this.plugin.saveSettings();
        }));
        // A list of current enable events
        container_element.createEl("p", { text: "The following gives just a quick glance over which events are enabled on which shell commands. To enable/disable events for a shell command, go to the particular shell command's settings via the 'Shell commands' tab. The list is only updated when you reopen the whole settings panel." });
        let found_enabled_event = false;
        getSC_Events(this.plugin).forEach((sc_event) => {
            const event_enabled_t_shell_commands = sc_event.getTShellCommands();
            // Has the event been enabled for any shell commands?
            if (event_enabled_t_shell_commands.length) {
                // Yes, it's enabled.
                // Show a list of shell commands
                const paragraph_element = container_element.createEl("p", { text: sc_event.static().getTitle() });
                const list_element = paragraph_element.createEl("ul");
                event_enabled_t_shell_commands.forEach((t_shell_command) => {
                    list_element.createEl("li", { text: t_shell_command.getAliasOrShellCommand() });
                });
                found_enabled_event = true;
            }
        });
        if (!found_enabled_event) {
            container_element.createEl("p", { text: "No events are enabled for any shell commands." });
        }
    }
    tabVariables(container_element) {
        // "Preview variables in command palette" field
        new obsidian.Setting(container_element)
            .setName("Preview variables in command palette and menus")
            .setDesc("If on, variable names are substituted with their realtime values when you view your commands in the command palette and right click context menus (if used). A nice way to ensure your commands will use correct values.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.preview_variables_in_command_palette)
            .onChange(async (value) => {
            debugLog("Changing preview_variables_in_command_palette to " + value);
            this.plugin.settings.preview_variables_in_command_palette = value;
            await this.plugin.saveSettings();
        }));
        // "Show autocomplete menu" field
        new obsidian.Setting(container_element)
            .setName("Show autocomplete menu")
            .setDesc("If on, a dropdown menu shows up when you begin writing {{variable}} names, showing matching variables and their instructions. Also allows defining custom suggestions in autocomplete.yaml file - see the documentation.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.show_autocomplete_menu)
            .onChange(async (value) => {
            debugLog("Changing show_autocomplete_menu to " + value);
            this.plugin.settings.show_autocomplete_menu = value;
            this.display(); // Re-render the whole settings view to apply the change.
            await this.plugin.saveSettings();
        }))
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Autocomplete")
            .onClick(() => {
            gotoURL(DocumentationAutocompleteLink);
        }));
        // Variable instructions
        new obsidian.Setting(container_element)
            .setName("Variables")
            .setHeading() // Make the "Variables" text bold.
            .addExtraButton(extra_button => extra_button
            .setIcon("help")
            .setTooltip("Documentation: Variables")
            .onClick(() => {
            gotoURL(DocumentationVariablesLink);
        }));
        const variables = getVariables(this.plugin, this.plugin.getDefaultShell());
        variables.forEach((variable) => {
            const paragraph = container_element.createEl("p");
            paragraph.insertAdjacentHTML("afterbegin", variable.getHelpName() +
                "<br>" +
                variable.getHelpText());
            const availability_text = variable.static().getAvailabilityText();
            if (availability_text) {
                paragraph.insertAdjacentHTML("beforeend", "<br>" + availability_text);
            }
        });
        container_element.createEl("p", { text: "When you type variables into commands, a preview text appears under the command field to show how the command will look like when it gets executed with variables substituted with their real values." });
        container_element.createEl("p", { text: "Special characters in variable values are tried to be escaped (except if you use CMD as the shell in Windows). This is to improve security so that a variable won't accidentally cause bad things to happen. If you want to use a raw, unescaped value, add an exclamation mark before the variable's name, e.g. {{!title}}, but be careful, it's dangerous!" });
        container_element.createEl("p", { text: "There is no way to prevent variable parsing. If you need {{ }} characters in your command, they won't be parsed as variables as long as they do not contain any of the variable names listed below. If you would need to pass e.g. {{title}} literally to your command, there is no way to do it atm, please raise an issue in GitHub." });
        container_element.createEl("p", { text: "All variables that access the current file, may cause the command preview to fail if you had no file panel active when you opened the settings window - e.g. you had focus on graph view instead of a note = no file is currently active. But this does not break anything else than the preview." });
    }
    tabOperatingSystemsAndShells(container_element) {
        // "Working directory" field
        new obsidian.Setting(container_element)
            .setName("Working directory")
            .setDesc("A directory where your commands will be run. If empty, defaults to your vault's location. Can be relative (= a folder in the vault) or absolute (= complete from filesystem root).")
            .addText(text => text
            .setPlaceholder(getVaultAbsolutePath(this.app))
            .setValue(this.plugin.settings.working_directory)
            .onChange(async (value) => {
            debugLog("Changing working_directory to " + value);
            this.plugin.settings.working_directory = value;
            await this.plugin.saveSettings();
        }));
        // Platforms' default shells
        createShellSelectionField(this.plugin, container_element, this.plugin.settings.default_shells, true);
    }
    tabOutput(container_element) {
        // "Error message duration" field
        this.createNotificationDurationField(container_element, "Error message duration", "Concerns messages about failed shell commands.", "error_message_duration");
        // "Notification message duration" field
        this.createNotificationDurationField(container_element, "Notification message duration", "Concerns informational, non fatal messages, e.g. output directed to 'Notification balloon'.", "notification_message_duration");
        // "Output channel 'Clipboard' displays a notification message, too" field
        new obsidian.Setting(container_element)
            .setName("Output channel 'Clipboard' displays a notification message, too")
            .setDesc("If a shell command's output is directed to the clipboard, also show the output in a popup box on the top right corner. This helps to notice what was inserted into clipboard.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.output_channel_clipboard_also_outputs_to_notification)
            .onChange(async (value) => {
            this.plugin.settings.output_channel_clipboard_also_outputs_to_notification = value;
            await this.plugin.saveSettings();
        }));
    }
    createNotificationDurationField(container_element, title, description, setting_name) {
        new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description + " In seconds, between 1 and 180.")
            .addText(field => field
            .setValue(String(this.plugin.settings[setting_name]))
            .onChange(async (duration_string) => {
            const duration = parseInt(duration_string);
            if (duration >= 1 && duration <= 180) {
                debugLog("Change " + setting_name + " from " + this.plugin.settings[setting_name] + " to " + duration);
                this.plugin.settings[setting_name] = duration;
                await this.plugin.saveSettings();
                debugLog("Changed.");
            }
            // Don't show a notice if duration is not between 1 and 180, because this function is called every time a user types in this field, so the value might not be final.
        }));
    }
    rememberLastPosition(container_element) {
        const last_position = this.last_position;
        // Go to last position now
        this.tab_structure.buttons[last_position.tab_name].click();
        container_element.scrollTo({
            top: this.last_position.scroll_position,
            behavior: "auto",
        });
        // Listen to changes
        container_element.addEventListener("scroll", (event) => {
            this.last_position.scroll_position = container_element.scrollTop;
        });
        for (const tab_name in this.tab_structure.buttons) {
            const button = this.tab_structure.buttons[tab_name];
            button.onClickEvent((event) => {
                last_position.tab_name = tab_name;
            });
        }
    }
}

class ConfirmExecutionModal extends obsidian.Modal {
    constructor(plugin, shell_command_parsing_result, t_shell_command) {
        super(plugin.app);
        this.plugin = plugin;
        this.shell_command_parsing_result = shell_command_parsing_result;
        this.t_shell_command = t_shell_command;
    }
    open() {
        super.open();
        // Information about the shell command
        this.modalEl.createEl("h2", { text: this.shell_command_parsing_result.shell_command, attr: { style: "margin-bottom: 0;" } });
        if (this.shell_command_parsing_result.alias) {
            this.modalEl.createEl("p", { text: "Alias: " + this.shell_command_parsing_result.alias, attr: { style: "margin-top: 0;" } });
        }
        this.modalEl.createEl("p", { text: "Execute this shell command?" });
        // Execute button
        new obsidian.Setting(this.modalEl)
            .addButton(button => button
            .setButtonText("Yes, execute!")
            .onClick(() => {
            debugLog("User confirmed execution of shell command: " + this.shell_command_parsing_result);
            this.plugin.executeShellCommand(this.t_shell_command, this.shell_command_parsing_result);
            this.close();
        }));
    }
}

class TShellCommand {
    constructor(plugin, shell_command_id, configuration) {
        this.plugin = plugin;
        this.id = shell_command_id;
        this.configuration = configuration;
    }
    getPlugin() {
        return this.plugin;
    }
    /**
     * Use this when you need to alter the configuration values. if you only need to read configuration values, use get*()
     * methods instead.
     */
    getConfiguration() {
        return this.configuration;
    }
    getId() {
        return this.id;
    }
    getShell() {
        const operating_system = getOperatingSystem();
        // Check if the shell command has defined a specific shell.
        if (undefined === this.configuration.shells[operating_system]) {
            // The shell command does not define an explicit shell.
            // Use a default shell from the plugin's settings.
            return this.plugin.getDefaultShell();
        }
        else {
            // The shell command has an explicit shell defined.
            return this.configuration.shells[operating_system];
        }
    }
    getShells() {
        return this.configuration.shells;
    }
    /**
     * Returns a shell command string specific for the current operating system, or a generic shell command if this shell
     * command does not have an explicit version for the current OS.
     */
    getShellCommand() {
        const operating_system = getOperatingSystem();
        // Check if the shell command has defined a specific command for this operating system.
        if (undefined === this.configuration.platform_specific_commands[operating_system]) {
            // No command is defined specifically for this operating system.
            // Return an "OS agnostic" command.
            return this.configuration.platform_specific_commands.default;
        }
        else {
            // The shell command has defined a specific command for this operating system.
            return this.configuration.platform_specific_commands[operating_system];
        }
    }
    /**
     * Returns a version of the shell command that should be used if no platform specific command is defined for the
     * current platform. If you plan to use this for execution, consider using getShellCommand() instead, as it takes the
     * current platform into account.
     */
    getDefaultShellCommand() {
        return this.configuration.platform_specific_commands.default;
    }
    getPlatformSpecificShellCommands() {
        return this.configuration.platform_specific_commands;
    }
    getAlias() {
        return this.configuration.alias;
    }
    /**
     * TODO: Use this method in all places where similar logic is needed.
     */
    getAliasOrShellCommand() {
        return this.configuration.alias || this.getShellCommand();
    }
    getConfirmExecution() {
        return this.configuration.confirm_execution;
    }
    getIgnoreErrorCodes() {
        return this.configuration.ignore_error_codes;
    }
    getOutputChannelOrder() {
        return this.configuration.output_channel_order;
    }
    getOutputChannels() {
        return this.configuration.output_channels;
    }
    getEventsConfiguration() {
        return this.configuration.events;
    }
    getEventConfiguration(sc_event) {
        return this.getEventsConfiguration()[sc_event.static().getCode()] || sc_event.getDefaultConfiguration(false);
    }
    isSC_EventEnabled(event_code) {
        const events_configuration = this.getEventsConfiguration();
        if (undefined === events_configuration[event_code]) {
            // Not enabled
            return false;
        }
        else {
            // Maybe enabled
            return events_configuration[event_code].enabled;
        }
    }
    /**
     * Called when changing event settings in ShellCommandExtraOptionsModal.
     * plugin.saveSettings() needs to be called after this!
     *
     * @param sc_event
     */
    enableSC_Event(sc_event) {
        const event_code = sc_event.static().getCode();
        const events_configuration = this.getEventsConfiguration();
        if (undefined === events_configuration[event_code]) {
            // Not enabled
            // Enable
            events_configuration[event_code] = sc_event.getDefaultConfiguration(true);
        }
        else {
            // Maybe enabled
            if (!events_configuration[event_code].enabled) {
                events_configuration[event_code].enabled = true;
            }
        }
        if (sc_event.canRegisterAfterChangingSettings()) {
            this.registerSC_Event(sc_event);
        }
        sc_event.onAfterEnabling(this);
    }
    /**
     * Called when changing event settings in ShellCommandExtraOptionsModal.
     * plugin.saveSettings() needs to be called after this!
     *
     * @param sc_event
     */
    disableSC_Event(sc_event) {
        const event_code = sc_event.static().getCode();
        const events_configuration = this.getEventsConfiguration();
        if (undefined !== events_configuration[event_code]) {
            // Maybe enabled
            if (events_configuration[event_code].enabled) {
                // Is enabled.
                // Disable.
                const configuration_property_names = Object.getOwnPropertyNames(events_configuration[event_code]);
                if (configuration_property_names.length > 1) {
                    // There's more settings than just 'enable'.
                    // Disable by setting 'enable' to false, don't flush the settings, they can be useful if the event gets re-enabled.
                    events_configuration[event_code].enabled = false;
                }
                else {
                    // 'enabled' is the only setting.
                    // Disable by removing the configuration object completely to make the settings file cleaner.
                    delete events_configuration[event_code];
                }
            }
        }
        if (sc_event.canRegisterAfterChangingSettings()) {
            this.unregisterSC_Event(sc_event);
        }
    }
    /**
     * Returns all SC_Events that are enabled fro this shell command.
     *
     * Private as it's currently only used domestically, but can be changed to public if needed.
     */
    getSC_Events() {
        const enabled_sc_events = [];
        getSC_Events(this.plugin).forEach((sc_event) => {
            if (this.isSC_EventEnabled(sc_event.static().getCode())) {
                enabled_sc_events.push(sc_event);
            }
        });
        return enabled_sc_events;
    }
    /**
     * Private, if you need access from outside, use enableSC_Event().
     *
     * @param sc_event
     * @private
     */
    registerSC_Event(sc_event) {
        sc_event.register(this);
    }
    /**
     * Private, if you need access from outside, use disableSC_Event().
     *
     * @param sc_event
     * @private
     */
    unregisterSC_Event(sc_event) {
        sc_event.unregister(this);
    }
    /**
     * Set's up all events that are enabled for this shell command.
     *
     * @param called_after_changing_settings Set to: true, if this happens after changing configuration; false, if this happens during loading the plugin.
     */
    registerSC_Events(called_after_changing_settings) {
        this.getSC_Events().forEach((sc_event) => {
            const can_register = !called_after_changing_settings || sc_event.canRegisterAfterChangingSettings();
            if (can_register) {
                this.registerSC_Event(sc_event);
            }
        });
    }
    unregisterSC_Events() {
        this.getSC_Events().forEach((sc_event) => {
            this.unregisterSC_Event(sc_event);
        });
    }
    registerToCommandPalette() {
        // TODO: Move the logic from plugin.registerShellCommand() to here, but split to multiple methods.
        this.plugin.registerShellCommand(this);
    }
    unregisterFromCommandPalette() {
        // FIXME: I think the unregistering does not work.
        delete this.plugin.obsidian_commands[this.getId()];
    }
    /**
     * Checks the configuration for command_palette_availability and returns:
     *  - true, if the value is "enabled" or "unlisted"
     *  - false, if the value is "disabled"
     *
     * Adding to command palette also enables hotkeys, which is why adding can be permitted, but showing denied, if a shell command should only be available via hotkeys.
     */
    canAddToCommandPalette() {
        return this.getConfiguration().command_palette_availability !== "disabled";
    }
    /**
     * Checks the configuration for command_palette_availability and returns:
     *  - true, if the value is "enabled"
     *  - false, if the value is "disabled" or "unlisted"
     */
    canShowInCommandPalette() {
        return this.getConfiguration().command_palette_availability === "enabled";
    }
    parseVariables(sc_event) {
        // Parse variables in the actual shell command
        const parsing_result = {
            shell_command: "",
            alias: "",
            succeeded: false,
            error_messages: [],
        };
        const parsed_shell_command = parseShellCommandVariables(this.plugin, this.getShellCommand(), this.getShell(), sc_event);
        if (Array.isArray(parsed_shell_command)) {
            // Variable parsing failed, because an array was returned, which contains error messages.
            debugLog("Shell command preview: Variable parsing failed for shell command " + this.getShellCommand());
            parsing_result.succeeded = false;
            parsing_result.error_messages = parsed_shell_command;
            return parsing_result;
        }
        else {
            // Variable parsing succeeded.
            // Use the parsed values.
            parsing_result.shell_command = parsed_shell_command;
        }
        // Also parse variables in an alias, in case the command has one. Variables in aliases do not do anything practical, but they can reveal the user what variables are used in the command.
        const parsed_alias = parseShellCommandVariables(this.plugin, this.getAlias(), this.getShell(), sc_event);
        if (Array.isArray(parsed_alias)) {
            // Variable parsing failed, because an array was returned, which contains error messages.
            debugLog("Shell command preview: Variable parsing failed for alias " + this.getAlias());
            parsing_result.succeeded = false;
            parsing_result.error_messages = parsed_alias;
            return parsing_result;
        }
        else {
            // Variable parsing succeeded.
            // Use the parsed values.
            parsing_result.alias = parsed_alias;
        }
        // All ok
        parsing_result.succeeded = true;
        return parsing_result;
    }
    setObsidianCommand(obsidian_command) {
        this.obsidian_command = obsidian_command;
    }
    /**
     * No renaming is done if the shell command is excluded from the command palette.
     */
    renameObsidianCommand(shell_command, alias) {
        // Rename the command in command palette
        const prefix = this.plugin.getPluginName() + ": "; // Normally Obsidian prefixes all commands with the plugin name automatically, but now that we are actually _editing_ a command in the palette (not creating a new one), Obsidian won't do the prefixing for us.
        // Check that the shell command is actually registered to Obsidian's command palette.
        if (undefined !== this.obsidian_command) {
            // Yes, the shell command is registered in Obsidian's command palette.
            // Update the command palette name.
            this.obsidian_command.name = prefix + generateObsidianCommandName(this.plugin, shell_command, alias);
        }
        // If the shell command's "command_palette_availability" settings is set to "disabled", then the shell command is not present in this.obsidian_command and so the command palette name does not need updating.
    }
}

/**
 * Copied 2021-10-29 from https://gist.github.com/TheDistantSea/8021359
 * Modifications:
 *  - Made compatible with TypeScript by adding type definitions.
 *  - Changed var to let.
 *
 * Compares two software version numbers (e.g. "1.7.1" or "1.2b").
 *
 * This function was born in http://stackoverflow.com/a/6832721.
 *
 * @param {string} v1 The first version to be compared.
 * @param {string} v2 The second version to be compared.
 * @param {object} [options] Optional flags that affect comparison behavior:
 * <ul>
 *     <li>
 *         <tt>lexicographical: true</tt> compares each part of the version strings lexicographically instead of
 *         naturally; this allows suffixes such as "b" or "dev" but will cause "1.10" to be considered smaller than
 *         "1.2".
 *     </li>
 *     <li>
 *         <tt>zeroExtend: true</tt> changes the result if one version string has less parts than the other. In
 *         this case the shorter string will be padded with "zero" parts instead of being considered smaller.
 *     </li>
 * </ul>
 * @returns {number|NaN}
 * <ul>
 *    <li>0 if the versions are equal</li>
 *    <li>a negative integer iff v1 < v2</li>
 *    <li>a positive integer iff v1 > v2</li>
 *    <li>NaN if either version string is in the wrong format</li>
 * </ul>
 *
 * @copyright by Jon Papaioannou (["john", "papaioannou"].join(".") + "@gmail.com")
 * @license This function is in the public domain. Do what you want with it, no strings attached.
 */
function versionCompare(v1, v2, options = {}) {
    let lexicographical = options && options.lexicographical, zeroExtend = options && options.zeroExtend, v1parts = v1.split('.'), v2parts = v2.split('.');
    function isValidPart(x) {
        return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }
    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
        return NaN;
    }
    if (zeroExtend) {
        while (v1parts.length < v2parts.length)
            v1parts.push("0");
        while (v2parts.length < v1parts.length)
            v2parts.push("0");
    }
    if (!lexicographical) {
        v1parts = v1parts.map(Number);
        v2parts = v2parts.map(Number);
    }
    for (let i = 0; i < v1parts.length; ++i) {
        if (v2parts.length == i) {
            return 1;
        }
        if (v1parts[i] == v2parts[i]) {
            continue;
        }
        else if (v1parts[i] > v2parts[i]) {
            return 1;
        }
        else {
            return -1;
        }
    }
    if (v1parts.length != v2parts.length) {
        return -1;
    }
    return 0;
}

class SC_Plugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.obsidian_commands = {};
        this.t_shell_commands = {};
        /**
         * Holder for shell commands and aliases, whose variables are parsed before the actual execution during command
         * palette preview. This array gets emptied after every time a shell command is executed via the command palette.
         *
         * This is only used for command palette, not when executing a shell command from the settings panel, nor when
         * executing shell commands via SC_Events.
         *
         * @private
         */
        this.cached_parsing_results = {};
    }
    async onload() {
        debugLog('loading plugin');
        // Load settings
        if (!await this.loadSettings()) {
            // Loading the settings has failed due to an unsupported settings file version.
            // The plugin should not be used, and it has actually disabled itself, but the code execution needs to be
            // stopped manually.
            return;
        }
        // Run possible configuration migrations
        await RunMigrations(this);
        // Generate TShellCommand objects from configuration (only after configuration migrations are done)
        this.loadTShellCommands();
        // Make all defined shell commands to appear in the Obsidian command palette.
        const shell_commands = this.getTShellCommands();
        for (const shell_command_id in shell_commands) {
            const t_shell_command = shell_commands[shell_command_id];
            if (t_shell_command.canAddToCommandPalette()) {
                this.registerShellCommand(t_shell_command);
            }
        }
        // Perform event registrations, if enabled.
        if (this.settings.enable_events) {
            this.registerSC_Events(false);
        }
        // Load a custom autocomplete list if it exists.
        this.loadCustomAutocompleteList();
        this.addSettingTab(new SC_MainSettingsTab(this.app, this));
    }
    loadTShellCommands() {
        this.t_shell_commands = {};
        const shell_command_configurations = this.getShellCommandConfigurations();
        for (const shell_command_id in shell_command_configurations) {
            this.t_shell_commands[shell_command_id] = new TShellCommand(this, shell_command_id, shell_command_configurations[shell_command_id]);
        }
    }
    getTShellCommands() {
        return this.t_shell_commands;
    }
    getShellCommandConfigurations() {
        return this.settings.shell_commands;
    }
    /**
     * Creates a new shell command object and registers it to Obsidian's command palette, but does not save the modified
     * configuration to disk. To save the addition, call saveSettings().
     */
    newTShellCommand() {
        const shell_command_id = this.generateNewShellCommandID();
        const shell_command_configuration = newShellCommandConfiguration();
        this.settings.shell_commands[shell_command_id] = shell_command_configuration;
        const t_shell_command = new TShellCommand(this, shell_command_id, shell_command_configuration);
        this.t_shell_commands[shell_command_id] = t_shell_command;
        if (t_shell_command.canAddToCommandPalette()) { // This is probably always true, because the default configuration enables adding to the command palette, but check just in case.
            this.registerShellCommand(t_shell_command);
        }
        return t_shell_command;
    }
    /**
     * TODO: Move to TShellCommand.registerToCommandPalette(), but split to multiple methods.
     *
     * @param t_shell_command
     */
    registerShellCommand(t_shell_command) {
        const shell_command_id = t_shell_command.getId();
        debugLog("Registering shell command #" + shell_command_id + "...");
        // Define a function for executing the shell command.
        const executor = (parsing_result) => {
            if (undefined === parsing_result) {
                parsing_result = t_shell_command.parseVariables();
            }
            if (parsing_result.succeeded) {
                // The command was parsed correctly.
                this.confirmAndExecuteShellCommand(t_shell_command, parsing_result);
            }
            else {
                // The command could not be parsed correctly.
                // Display error messages
                this.newErrors(parsing_result.error_messages);
            }
        };
        // Register an Obsidian command
        const obsidian_command = {
            id: this.generateObsidianCommandId(shell_command_id),
            name: generateObsidianCommandName(this, t_shell_command.getShellCommand(), t_shell_command.getAlias()),
            // Use 'checkCallback' instead of normal 'callback' because we also want to get called when the command palette is opened.
            checkCallback: (is_opening_command_palette) => {
                if (is_opening_command_palette) {
                    // The user is currently opening the command palette.
                    // Check can the shell command be shown in command palette
                    if (!t_shell_command.canShowInCommandPalette()) {
                        // Cancel preview and deny showing in command palette.
                        debugLog("Shell command #" + t_shell_command.getId() + " won't be shown in command palette.");
                        return false;
                    }
                    // Do not execute the command yet, but parse variables for preview, if enabled in the settings.
                    debugLog("Getting command palette preview for shell command #" + t_shell_command.getId());
                    if (this.settings.preview_variables_in_command_palette) {
                        // Preparse variables
                        const parsing_result = t_shell_command.parseVariables();
                        if (parsing_result.succeeded) {
                            // Parsing succeeded
                            // Rename Obsidian command
                            t_shell_command.renameObsidianCommand(parsing_result.shell_command, parsing_result.alias);
                            // Store the preparsed variables so that they will be used if this shell command gets executed.
                            this.cached_parsing_results[t_shell_command.getId()] = parsing_result;
                            // All done now
                            return true;
                        }
                    }
                    // If parsing failed (or was disabled), then use unparsed t_shell_command.getShellCommand() and t_shell_command.getAlias().
                    t_shell_command.renameObsidianCommand(t_shell_command.getShellCommand(), t_shell_command.getAlias());
                    this.cached_parsing_results[t_shell_command.getId()] = undefined;
                    return true;
                }
                else {
                    // The user has instructed to execute the command.
                    executor(this.cached_parsing_results[t_shell_command.getId()] // Can be undefined, if no preparsing was done. executor() will handle parsing then.
                    );
                    // Delete the whole array of preparsed commands. Even though we only used just one command from it, we need to notice that opening a command
                    // palette might generate multiple preparsed commands in the array, but as the user selects and executes only one command, all these temporary
                    // commands are now obsolete. Delete them just in case the user toggles the variable preview feature off in the settings, or executes commands via hotkeys. We do not want to
                    // execute obsolete commands accidentally.
                    // This deletion also needs to be done even if the executed command was not a preparsed command, because
                    // even when preparsing is turned on in the settings, some commands may fail to parse, and therefore they would not be in this array, but other
                    // commands might be.
                    this.cached_parsing_results = {}; // Removes obsolete preparsed variables from all shell commands.
                }
            }
        };
        this.addCommand(obsidian_command);
        this.obsidian_commands[shell_command_id] = obsidian_command; // Store the reference so that we can edit the command later in ShellCommandsSettingsTab if needed. TODO: Use tShellCommand instead.
        t_shell_command.setObsidianCommand(obsidian_command);
        debugLog("Registered.");
    }
    /**
     * Goes through all events and all shell commands, and for each shell command, registers all the events that the shell
     * command as enabled in its configuration. Does not modify the configurations.
     *
     * @param called_after_changing_settings Set to: true, if this happens after changing configuration; false, if this happens during loading the plugin.
     */
    registerSC_Events(called_after_changing_settings) {
        // Make sure that Obsidian is fully loaded before allowing any events to trigger.
        this.app.workspace.onLayoutReady(() => {
            // Even after Obsidian is fully loaded, wait a while in order to prevent SC_Event_onActiveLeafChanged triggering right after start-up.
            // At least on Obsidian 0.12.19 it's not enough to delay until onLayoutReady, need to wait a bit more in order to avoid the miss-triggering.
            window.setTimeout(() => {
                // Iterate all shell commands and register possible events.
                const shell_commands = this.getTShellCommands();
                for (const shell_command_id in shell_commands) {
                    const t_shell_command = shell_commands[shell_command_id];
                    t_shell_command.registerSC_Events(called_after_changing_settings);
                }
            }, 0); // 0 means to call the callback on "the next event cycle", according to window.setTimeout() documentation. It should be a long enough delay. But if SC_Event_onActiveLeafChanged still gets triggered during start-up, this value can be raised to for example 1000 (= one second).
        });
    }
    /**
     * Goes through all events and all shell commands, and makes sure all of them are unregistered, e.g. will not trigger
     * automatically. Does not modify the configurations.
     */
    unregisterSC_Events() {
        // Iterate all events
        getSC_Events(this).forEach((sc_event) => {
            // Iterate all shell commands
            const shell_commands = this.getTShellCommands();
            for (const shell_command_id in shell_commands) {
                const t_shell_command = shell_commands[shell_command_id];
                sc_event.unregister(t_shell_command);
            }
        });
    }
    generateObsidianCommandId(shell_command_id) {
        return "shell-command-" + shell_command_id;
    }
    /**
     *
     * @param t_shell_command Used for reading other properties. t_shell_command.shell_command won't be used!
     * @param shell_command_parsing_result The actual shell command that will be executed.
     */
    confirmAndExecuteShellCommand(t_shell_command, shell_command_parsing_result) {
        // Check if the command needs confirmation before execution
        if (t_shell_command.getConfirmExecution()) {
            // Yes, a confirmation is needed.
            // Open a confirmation modal.
            new ConfirmExecutionModal(this, shell_command_parsing_result, t_shell_command)
                .open();
            return; // Do not execute now. The modal will call executeShellCommand() later if needed.
        }
        else {
            // No need to confirm.
            // Execute.
            this.executeShellCommand(t_shell_command, shell_command_parsing_result);
        }
    }
    /**
     * Does not ask for confirmation before execution. This should only be called if: a) a confirmation is already asked from a user, or b) this command is defined not to need a confirmation.
     * Use confirmAndExecuteShellCommand() instead to have a confirmation asked before the execution.
     *
     * @param t_shell_command Used for reading other properties. t_shell_command.shell_command won't be used!
     * @param shell_command_parsing_result The actual shell command that will be executed is taken from this object's '.shell_command' property.
     */
    executeShellCommand(t_shell_command, shell_command_parsing_result) {
        const working_directory = this.getWorkingDirectory();
        // Check that the shell command is not empty
        const shell_command = shell_command_parsing_result.shell_command.trim();
        if (!shell_command.length) {
            // It is empty
            debugLog("The shell command is empty. :(");
            this.newError("The shell command is empty :(");
            return;
        }
        // Check that the currently defined shell is supported by this plugin. If using system default shell, it's possible
        // that the shell is something that is not supported. Also, the settings file can be edited manually, and incorrect
        // shell can be written there.
        const shell = t_shell_command.getShell();
        if (!isShellSupported(shell)) {
            debugLog("Shell is not supported: " + shell);
            this.newError("This plugin does not support the following shell: " + shell);
            return;
        }
        // Check that the working directory exists and is a folder
        if (!fs__namespace.existsSync(working_directory)) {
            // Working directory does not exist
            // Prevent execution
            debugLog("Working directory does not exist: " + working_directory);
            this.newError("Working directory does not exist: " + working_directory);
        }
        else if (!fs__namespace.lstatSync(working_directory).isDirectory()) {
            // Working directory is not a directory.
            // Prevent execution
            debugLog("Working directory exists but is not a folder: " + working_directory);
            this.newError("Working directory exists but is not a folder: " + working_directory);
        }
        else {
            // Working directory is OK
            // Prepare execution options
            const options = {
                "cwd": working_directory,
                "shell": shell,
            };
            // Execute the shell command
            debugLog("Executing command " + shell_command + " in " + working_directory + "...");
            child_process.exec(shell_command, options, (error, stdout, stderr) => {
                // Did the shell command execute successfully?
                if (null !== error) {
                    // Some error occurred
                    debugLog("Command executed and failed. Error number: " + error.code + ". Message: " + error.message);
                    // Check if this error should be displayed to the user or not
                    if (t_shell_command.getIgnoreErrorCodes().contains(error.code)) {
                        // The user has ignored this error.
                        debugLog("User has ignored this error, so won't display it.");
                        // Handle only stdout output stream
                        handleShellCommandOutput(this, t_shell_command, shell_command_parsing_result, stdout, "", null);
                    }
                    else {
                        // Show the error.
                        debugLog("Will display the error to user.");
                        // Check that stderr actually contains an error message
                        if (!stderr.length) {
                            // Stderr is empty, so the error message is probably given by Node.js's child_process.
                            // Direct error.message to the stderr variable, so that the user can see error.message when stderr is unavailable.
                            stderr = error.message;
                        }
                        // Handle both stdout and stderr output streams
                        handleShellCommandOutput(this, t_shell_command, shell_command_parsing_result, stdout, stderr, error.code);
                    }
                }
                else {
                    // Probably no errors, but do one more check.
                    // Even when 'error' is null and everything should be ok, there may still be error messages outputted in stderr.
                    if (stderr.length > 0) {
                        // Check a special case: should error code 0 be ignored?
                        if (t_shell_command.getIgnoreErrorCodes().contains(0)) {
                            // Exit code 0 is on the ignore list, so suppress stderr output.
                            stderr = "";
                            debugLog("Shell command executed: Encountered error code 0, but stderr is ignored.");
                        }
                        else {
                            debugLog("Shell command executed: Encountered error code 0, and stderr will be relayed to an output handler.");
                        }
                    }
                    else {
                        debugLog("Shell command executed: No errors.");
                    }
                    // Handle output
                    handleShellCommandOutput(this, t_shell_command, shell_command_parsing_result, stdout, stderr, 0); // Use zero as an error code instead of null (0 means no error). If stderr happens to contain something, exit code 0 gets displayed in an error balloon (if that is selected as a driver for stderr).
                }
            });
        }
    }
    getWorkingDirectory() {
        // Returns either a user defined working directory, or an automatically detected one.
        const working_directory = this.settings.working_directory;
        if (working_directory.length == 0) {
            // No working directory specified, so use the vault directory.
            return getVaultAbsolutePath(this.app);
        }
        else if (!path__namespace.isAbsolute(working_directory)) {
            // The working directory is relative.
            // Help to make it refer to the vault's directory. Without this, the relative path would refer to Obsidian's installation directory (at least on Windows).
            return path__namespace.join(getVaultAbsolutePath(this.app), working_directory);
        }
        return working_directory;
    }
    onunload() {
        debugLog('unloading plugin');
    }
    /**
     *
     * @param current_settings_version
     * @private
     * @return True if the given settings version is supported by this plugin version, or an error message string if it's not supported.
     */
    isSettingsVersionSupported(current_settings_version) {
        if (current_settings_version === "prior-to-0.7.0") {
            // 0.x.y supports all old settings formats that do not define a version number. This support will be removed in 1.0.0.
            return true;
        }
        else {
            // Compare the version number
            /** Note that the plugin version may be different than what will be used in the version comparison. The plugin version will be displayed in possible error messages. */
            const plugin_version = this.getPluginVersion();
            const version_comparison = versionCompare(SC_Plugin.SettingsVersion, current_settings_version);
            if (version_comparison === 0) {
                // The versions are equal.
                // Supported.
                return true;
            }
            else if (version_comparison < 0) {
                // The compared version is newer than what the plugin can support.
                return "The settings file is saved by a newer version of this plugin, so this plugin does not support the structure of the settings file. Please upgrade this plugin to at least version " + current_settings_version + ". Now the plugin version is " + plugin_version;
            }
            else {
                // The compared version is older than the version that the plugin currently uses to write settings.
                // 0.x.y supports all old settings versions. In 1.0.0, some old settings formats might lose their support, but that's not yet certain.
                return true;
            }
        }
    }
    getPluginVersion() {
        return this.manifest.version;
    }
    async loadSettings() {
        // Try to read a settings file
        let all_settings;
        this.settings = await this.loadData(); // May have missing main settings fields, if the settings file is from an older version of SC. It will be migrated later.
        if (null === this.settings) {
            // The settings file does not exist.
            // Use default settings
            this.settings = getDefaultSettings(true);
            all_settings = this.settings;
        }
        else {
            // Succeeded to load a settings file.
            // In case the settings file does not have 'debug' or 'settings_version' fields, create them.
            all_settings = combineObjects(getDefaultSettings(false), this.settings); // This temporary settings object always has all fields defined (except sub fields, such as shell command specific fields, may still be missing, but they are not needed this early). This is used so that it's certain that the fields 'debug' and 'settings_version' exist.
        }
        // Update debug status - before this line debugging is always OFF!
        setDEBUG_ON(all_settings.debug);
        // Ensure that the loaded settings file is supported.
        const version_support = this.isSettingsVersionSupported(all_settings.settings_version);
        if (typeof version_support === "string") {
            // The settings version is not supported.
            new obsidian.Notice("SHELL COMMANDS PLUGIN HAS DISABLED ITSELF in order to prevent misinterpreting settings / corrupting the settings file!", 120 * 1000);
            new obsidian.Notice(version_support, 120 * 1000);
            await this.disablePlugin();
            return false; // The plugin should not be used.
        }
        return true; // Settings are loaded and the plugin can be used.
    }
    async saveSettings() {
        // Update settings version in case it's old.
        this.settings.settings_version = SC_Plugin.SettingsVersion;
        // Write settings
        await this.saveData(this.settings);
    }
    loadCustomAutocompleteList() {
        const custom_autocomplete_file_name = "autocomplete.yaml";
        const custom_autocomplete_file_path = path__namespace.join(getPluginAbsolutePath(this), custom_autocomplete_file_name);
        if (fs__namespace.existsSync(custom_autocomplete_file_path)) {
            debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " exists, will load it now.");
            const custom_autocomplete_content = fs__namespace.readFileSync(custom_autocomplete_file_path).toLocaleString();
            const result = addCustomAutocompleteItems(custom_autocomplete_content);
            if (true === result) {
                // OK
                debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " loaded.");
            }
            else {
                // An error has occurred.
                debugLog("loadCustomAutocompleteList(): " + result);
                this.newError("Shell commands: Unable to parse " + custom_autocomplete_file_name + ": " + result);
            }
        }
        else {
            debugLog("loadCustomAutocompleteList(): " + custom_autocomplete_file_name + " does not exists, so won't load it. This is perfectly ok.");
        }
    }
    async disablePlugin() {
        // This unfortunately accesses a private API.
        // @ts-ignore
        await this.app.plugins.disablePlugin(this.manifest.id);
    }
    /**
     * @return string Returns "0" if there are no shell commands yet, otherwise returns the max ID + 1, as a string.
     */
    generateNewShellCommandID() {
        const existing_ids = Object.getOwnPropertyNames(this.getTShellCommands());
        let new_id = 0;
        for (const i in existing_ids) {
            const existing_id = parseInt(existing_ids[i]);
            if (existing_id >= new_id) {
                new_id = existing_id + 1;
            }
        }
        return String(new_id);
    }
    getPluginId() {
        return this.manifest.id;
    }
    getPluginName() {
        return this.manifest.name;
    }
    newError(message) {
        new obsidian.Notice(message, this.settings.error_message_duration * 1000); // * 1000 = convert seconds to milliseconds.
    }
    newErrors(messages) {
        messages.forEach((message) => {
            this.newError(message);
        });
    }
    newNotification(message) {
        new obsidian.Notice(message, this.settings.notification_message_duration * 1000); // * 1000 = convert seconds to milliseconds.
    }
    getDefaultShell() {
        const operating_system = getOperatingSystem();
        let shell_name = this.settings.default_shells[operating_system]; // Can also be undefined.
        if (undefined === shell_name) {
            shell_name = getUsersDefaultShell();
        }
        return shell_name;
    }
}
/**
 * Defines the settings structure version. Change this when a new plugin version is released, but only if that plugin
 * version introduces changes to the settings structure. Do not change if the settings structure stays unchanged.
 */
SC_Plugin.SettingsVersion = "0.11.0";

module.exports = SC_Plugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsic3JjL0RlYnVnLnRzIiwic3JjL0NvbW1vbi50cyIsInNyYy9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLnRzIiwic3JjL3NldHRpbmdzL1NDX01haW5TZXR0aW5ncy50cyIsInNyYy9NaWdyYXRpb25zLnRzIiwic3JjL1NoZWxsLnRzIiwic3JjL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxTZWxlY3Rpb25GaWVsZC50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlci50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9Ob3RpZmljYXRpb24udHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVDYXJldC50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVRvcC50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9TdGF0dXNCYXIudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVCb3R0b20udHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJfQ2xpcGJvYXJkLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyX01vZGFsLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyX09wZW5GaWxlcy50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9ucy50cyIsInNyYy92YXJpYWJsZXMvZXNjYXBlcnMvRXNjYXBlci50cyIsInNyYy92YXJpYWJsZXMvZXNjYXBlcnMvQWxsU3BlY2lhbENoYXJhY3RlcnNFc2NhcGVyLnRzIiwic3JjL3ZhcmlhYmxlcy9lc2NhcGVycy9TaEVzY2FwZXIudHMiLCJzcmMvdmFyaWFibGVzL2VzY2FwZXJzL1Bvd2VyU2hlbGxFc2NhcGVyLnRzIiwic3JjL3ZhcmlhYmxlcy9lc2NhcGVycy9Fc2NhcGVWYWx1ZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0NsaXBib2FyZC50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfQ2FyZXRQb3NpdGlvbi50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfRGF0ZS50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVIZWxwZXJzLnRzIiwic3JjL3ZhcmlhYmxlcy9GaWxlVmFyaWFibGUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZpbGVFeHRlbnNpb24udHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZpbGVOYW1lLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9GaWxlUGF0aC50cyIsInNyYy92YXJpYWJsZXMvRm9sZGVyVmFyaWFibGUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZvbGRlck5hbWUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX0ZvbGRlclBhdGgudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX1NlbGVjdGlvbi50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfVGFncy50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfVGl0bGUudHMiLCJzcmMvdmFyaWFibGVzL1ZhcmlhYmxlX1ZhdWx0UGF0aC50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfV29ya3NwYWNlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZV9QYXNzdGhyb3VnaC50cyIsInNyYy92YXJpYWJsZXMvVmFyaWFibGVfWUFNTFZhbHVlLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvRXZlbnRWYXJpYWJsZS50cyIsInNyYy9Eb2N1bWVudGF0aW9uLnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudC50cyIsInNyYy9ldmVudHMvU0NfV29ya3NwYWNlRXZlbnQudHMiLCJzcmMvZXZlbnRzL1NDX01lbnVFdmVudC50cyIsInNyYy9ldmVudHMvU0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50LnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudS50cyIsInNyYy92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50RmlsZU5hbWUudHMiLCJzcmMvdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudEZpbGVQYXRoLnRzIiwic3JjL2V2ZW50cy9TQ19FdmVudF9Gb2xkZXJNZW51LnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGb2xkZXJOYW1lLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGb2xkZXJQYXRoLnRzIiwic3JjL3ZhcmlhYmxlcy9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRUaXRsZS50cyIsInNyYy92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50RmlsZUV4dGVuc2lvbi50cyIsInNyYy92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50VGFncy50cyIsInNyYy92YXJpYWJsZXMvZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50WUFNTFZhbHVlLnRzIiwic3JjL3ZhcmlhYmxlcy9WYXJpYWJsZUxpc3RzLnRzIiwic3JjL3ZhcmlhYmxlcy9wYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcy50cyIsIm5vZGVfbW9kdWxlcy9hdXRvY29tcGxldGVyL2F1dG9jb21wbGV0ZS5qcyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZS50cyIsInNyYy92YXJpYWJsZXMvZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtcy50cyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0NyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZS50cyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0NyZWF0ZVBsYXRmb3JtU3BlY2lmaWNTaGVsbENvbW1hbmRGaWVsZC50cyIsInNyYy9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL1RhYnMudHMiLCJzcmMvZXZlbnRzL1NDX0V2ZW50X29uTGF5b3V0UmVhZHkudHMiLCJzcmMvZXZlbnRzL1NDX0V2ZW50X29uUXVpdC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZC50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRXZlcnlOU2Vjb25kcy50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRfRWRpdG9yTWVudS50cyIsInNyYy9ldmVudHMvU0NfRXZlbnRMaXN0LnRzIiwic3JjL3NldHRpbmdzL0V4dHJhT3B0aW9uc01vZGFsLnRzIiwic3JjL3NldHRpbmdzL0RlbGV0ZU1vZGFsLnRzIiwic3JjL0hvdGtleXMudHMiLCJzcmMvc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9DcmVhdGVTaGVsbENvbW1hbmRGaWVsZC50cyIsInNyYy9zZXR0aW5ncy9TQ19NYWluU2V0dGluZ3NUYWIudHMiLCJzcmMvQ29uZmlybUV4ZWN1dGlvbk1vZGFsLnRzIiwic3JjL1RTaGVsbENvbW1hbmQudHMiLCJzcmMvbGliL3ZlcnNpb25fY29tcGFyZS50cyIsInNyYy9tYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogSWYgdHJ1ZSwgbG9nZ2luZyBzdHVmZiB0byBjb25zb2xlLmxvZygpIHdpbGwgYmUgZW5hYmxlZC5cclxuICogTWlnaHQgYWxzbyBlbmFibGUgc29tZSB0ZXN0aW5nIHt7dmFyaWFibGVzfX0gaW4gdGhlIGZ1dHVyZSwgcGVyaGFwcy5cclxuICovXHJcbmV4cG9ydCBsZXQgREVCVUdfT04gPSBmYWxzZTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRERUJVR19PTih2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgREVCVUdfT04gPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGxzIGNvbnNvbGUubG9nKCksIGJ1dCBvbmx5IGlmIGRlYnVnZ2luZyBpcyBlbmFibGVkLlxyXG4gKiBAcGFyYW0gbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnTG9nKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgaWYgKERFQlVHX09OKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgQXBwLFxyXG4gICAgRWRpdG9yLFxyXG4gICAgRWRpdG9yUG9zaXRpb24sXHJcbiAgICBGaWxlU3lzdGVtQWRhcHRlcixcclxuICAgIE1hcmtkb3duVmlldyxcclxuICAgIG5vcm1hbGl6ZVBhdGgsXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7UGxhdGZvcm1JZH0gZnJvbSBcIi4vc2V0dGluZ3MvU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7cGxhdGZvcm19IGZyb20gXCJvc1wiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuL0RlYnVnXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG4vLyBAdHMtaWdub3JlXHJcbmltcG9ydCB7c2hlbGx9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhdWx0QWJzb2x1dGVQYXRoKGFwcDogQXBwKSB7XHJcbiAgICAvLyBPcmlnaW5hbCBjb2RlIHdhcyBjb3BpZWQgMjAyMS0wOC0yMiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waGlicjAvb2JzaWRpYW4tb3Blbi13aXRoL2Jsb2IvODRmMGUyNWJhOGU4MzU1ZmY4M2IyMmY0MDUwYWRkZTRjYzY3NjNlYS9tYWluLnRzI0w2Ni1MNjdcclxuICAgIC8vIEJ1dCB0aGUgY29kZSBoYXMgYmVlbiByZXdyaXR0ZW4gMjAyMS0wOC0yNyBhcyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL29ic2lkaWFubWQvb2JzaWRpYW4tcmVsZWFzZXMvcHVsbC80MzMjaXNzdWVjb21tZW50LTkwNjA4NzA5NVxyXG4gICAgY29uc3QgYWRhcHRlciA9IGFwcC52YXVsdC5hZGFwdGVyO1xyXG4gICAgaWYgKGFkYXB0ZXIgaW5zdGFuY2VvZiBGaWxlU3lzdGVtQWRhcHRlcikge1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsdWdpbkFic29sdXRlUGF0aChwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgyKHBhdGguam9pbihcclxuICAgICAgICBnZXRWYXVsdEFic29sdXRlUGF0aChwbHVnaW4uYXBwKSxcclxuICAgICAgICBwbHVnaW4uYXBwLnZhdWx0LmNvbmZpZ0RpcixcclxuICAgICAgICBcInBsdWdpbnNcIixcclxuICAgICAgICBwbHVnaW4uZ2V0UGx1Z2luSWQoKSkpO1xyXG59XHJcblxyXG4vKipcclxuICogRm9yIHNvbWUgcmVhc29uIHRoZXJlIGlzIG5vIFBsYXRmb3JtLmlzV2luZG93cyAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xyXG4gICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMganVzdCBhIHdyYXBwZXIgYXJvdW5kIHBsYXRmb3JtKCkgaW4gb3JkZXIgdG8gY2FzdCB0aGUgdHlwZSB0byBQbGF0Zm9ybUlkLlxyXG4gKiBUT0RPOiBDb25zaWRlciByZW5hbWluZyB0aGlzIHRvIGdldFBsYXRmb3JtSWQoKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpbmdTeXN0ZW0oKTogUGxhdGZvcm1JZCAge1xyXG4gICAgLy8gQHRzLWlnbm9yZSBJbiB0aGVvcnksIHBsYXRmb3JtKCkgY2FuIHJldHVybiBhbiBPUyBuYW1lIG5vdCBpbmNsdWRlZCBpbiBPcGVyYXRpbmdTeXN0ZW1OYW1lLiBCdXQgYXMgT2JzaWRpYW5cclxuICAgIC8vIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGFueXRoaW5nIGVsc2UgdGhhbiBXaW5kb3dzLCBNYWMgYW5kIExpbnV4IChleGNlcHQgbW9iaWxlIHBsYXRmb3JtcywgYnV0IHRoZXkgYXJlXHJcbiAgICAvLyBydWxlZCBvdXQgYnkgdGhlIG1hbmlmZXN0IG9mIHRoaXMgcGx1Z2luKSwgaXQgc2hvdWxkIGJlIHNhZmUgdG8gYXNzdW1lIHRoYXQgdGhlIGN1cnJlbnQgT1MgaXMgb25lIG9mIHRob3NlXHJcbiAgICAvLyB0aHJlZS5cclxuICAgIHJldHVybiBwbGF0Zm9ybSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlldyhhcHA6IEFwcCkge1xyXG4gICAgY29uc3QgdmlldyA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xyXG4gICAgaWYgKCF2aWV3KSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJnZXRWaWV3KCk6IENvdWxkIG5vdCBnZXQgYSB2aWV3LiBXaWxsIHJldHVybiBudWxsLlwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWRpdG9yKGFwcDogQXBwKTogRWRpdG9yIHtcclxuXHJcbiAgICBjb25zdCB2aWV3ID0gZ2V0VmlldyhhcHApO1xyXG4gICAgaWYgKG51bGwgPT09IHZpZXcpIHtcclxuICAgICAgICAvLyBDb3VsZCBub3QgZ2V0IGEgdmlldy5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgdGhhdCB2aWV3LmVkaXRvciBleGlzdHMhIEl0IGV4aXN0cyBhdCBsZWFzdCBpZiB0aGlzIGlzIGEgTWFya0Rvd25WaWV3LlxyXG4gICAgaWYgKFwiZWRpdG9yXCIgaW4gdmlldykge1xyXG4gICAgICAgIC8vIEdvb2QsIGl0IGV4aXN0cy5cclxuICAgICAgICAvLyBAdHMtaWdub3JlIFdlIGFscmVhZHkga25vdyB0aGF0IHZpZXcuZWRpdG9yIGV4aXN0cy5cclxuICAgICAgICByZXR1cm4gdmlldy5lZGl0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlkIG5vdCBmaW5kIGFuIGVkaXRvci5cclxuICAgIGRlYnVnTG9nKFwiZ2V0RWRpdG9yKCk6ICd2aWV3JyBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbmFtZWQgJ2VkaXRvcicuIFdpbGwgcmV0dXJuIG51bGwuXCIpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU9iamVjdChvYmplY3Q6IE9iamVjdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlci4gSWYgdGhleSBoYXZlIHNhbWUgcHJvcGVydHkgbmFtZXMsIGZvcm1lciBvYmplY3RzJyBwcm9wZXJ0aWVzIGdldCBvdmVyd3JpdHRlbiBieSBsYXRlciBvYmplY3RzJyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVPYmplY3RzKC4uLm9iamVjdHM6IE9iamVjdFtdKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgLi4ub2JqZWN0cyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIG5vcm1hbGl6ZVBhdGgoKSwgYnV0IGZpeGVzIHRoZXNlIGdsaXRjaGVzOlxyXG4gKiAtIExlYWRpbmcgZm9yd2FyZCBzbGFzaGVzIC8gYmFja3dhcmQgc2xhc2hlcyBzaG91bGQgbm90IGJlIHJlbW92ZWQuXHJcbiAqIC0gXFwgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gLyBpZiBwbGF0Zm9ybSBpcyBXaW5kb3dzLiBJbiBvdGhlciB3b3JkcywgLyBzaG91bGQgYmUgY29udmVydGVkIHRvIFxcIGlmIHBsYXRmb3JtIGlzIFdpbmRvd3MuXHJcbiAqXHJcbiAqIFRPRE86IEkndmUgb3BlbmVkIGEgZGlzY3Vzc2lvbiBhYm91dCB0aGlzIG9uIE9ic2lkaWFuJ3MgZm9ydW1zLiBJZiBhbnl0aGluZyBuZXcgY29tZXMgdXAgaW4gdGhlIGRpc2N1c3Npb24sIG1ha2UgY2hhbmdlcyBhY2NvcmRpbmdseS4gaHR0cHM6Ly9mb3J1bS5vYnNpZGlhbi5tZC90L25vcm1hbGl6ZXBhdGgtcmVtb3Zlcy1hLWxlYWRpbmcvMjQ3MTNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXRoMihwYXRoOiBzdHJpbmcpIHtcclxuICAgIC8vIDEuIFByZXBhcmF0aW9uc1xyXG4gICAgcGF0aCA9IHBhdGgudHJpbSgpO1xyXG4gICAgY29uc3QgbGVhZGluZ19zbGFzaGVzX3JlZ2V4cCA9IC9eWy9cXFxcXSovZzsgLy8gR2V0IGFzIG1hbnkgLyBvciBcXCBzbGFzaGVzIGFzIHRoZXJlIGFyZSBpbiB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgcGF0aC4gQ2FuIGFsc28gYmUgXCJcIiAoYW4gZW1wdHkgc3RyaW5nKS5cclxuICAgIGxldCBsZWFkaW5nX3NsYXNoZXMgPSBsZWFkaW5nX3NsYXNoZXNfcmVnZXhwLmV4ZWMocGF0aClbMF07XHJcblxyXG4gICAgLy8gMi4gUnVuIHRoZSBvcmlnaW5hbCBub3JtYWxpemVQYXRoKClcclxuICAgIHBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xyXG5cclxuICAgIC8vIDMuIEZpeGVzXHJcbiAgICAvLyBDaGVjayB0aGF0IGNvcnJlY3Qgc2xhc2hlcyBhcmUgdXNlZC5cclxuICAgIGlmIChpc1dpbmRvd3MoKSkge1xyXG4gICAgICAgIC8vIFRoZSBwbGF0Zm9ybSBpcyBXaW5kb3dzLlxyXG4gICAgICAgIC8vIENvbnZlcnQgLyB0byBcXFxyXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFxcIik7IC8vIE5lZWQgdG8gdXNlIGEgcmVnZXhwIGluc3RlYWQgb2YgYSBub3JtYWwgXCIvXCIgLT4gXCJcXFxcXCIgcmVwbGFjZSBiZWNhdXNlIHRoZSBub3JtYWwgcmVwbGFjZSB3b3VsZCBvbmx5IHJlcGxhY2UgZmlyc3Qgb2NjdXJyZW5jZSBvZiAvLlxyXG4gICAgICAgIGxlYWRpbmdfc2xhc2hlcyA9IGxlYWRpbmdfc2xhc2hlcy5yZXBsYWNlKC9cXC8vZywgXCJcXFxcXCIpOyAvLyBTYW1lIGhlcmUuXHJcbiAgICB9XHJcbiAgICAvLyBOb3cgZW5zdXJlIHRoYXQgcGF0aCBzdGlsbCBjb250YWlucyBsZWFkaW5nIHNsYXNoZXMgKGlmIHRoZXJlIHdlcmUgYW55IGJlZm9yZSBjYWxsaW5nIG5vcm1hbGl6ZVBhdGgoKSkuXHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBwYXRoIHNob3VsZCBoYXZlIGEgc2ltaWxhciBzZXQgb2YgbGVhZGluZyBzbGFzaGVzIGF0IHRoZSBiZWdpbm5pbmcuIEl0IGNhbiBiZSBhdCBsZWFzdCBcIi9cIiAob24gbGludXgvTWFjKSwgb3IgXCJcXFxcXCIgKG9uIFdpbmRvd3Mgd2hlbiBpdCdzIGEgbmV0d29yayBwYXRoKSwgaW4gdGhlb3J5IGV2ZW4gXCIvLy9cIiBvciBcIlxcXFxcXFxcXFxcIiB3aGF0ZXZlci5cclxuICAgIC8vIG5vcm1hbGl6ZVBhdGgoKSBzZWVtcyB0byByZW1vdmUgbGVhZGluZyBzbGFzaGVzIChhbmQgdGhleSBhcmUgbmVlZGVkIHRvIGJlIHJlLWFkZGVkKSwgYnV0IGl0J3MgbmVlZGVkIHRvIGNoZWNrIGZpcnN0LCBvdGhlcndpc2UgdGhlIHBhdGggd291bGQgaGF2ZSBkb3VibGUgbGVhZGluZyBzbGFzaGVzIGlmIG5vcm1hbGl6ZVBhdGgoKSBnZXRzIGZpeGVkIGluIHRoZSBmdXR1cmUuXHJcbiAgICBpZiAobGVhZGluZ19zbGFzaGVzLmxlbmd0aCAmJiBwYXRoLnNsaWNlKDAsIGxlYWRpbmdfc2xhc2hlcy5sZW5ndGgpICE9PSBsZWFkaW5nX3NsYXNoZXMpIHtcclxuICAgICAgICAvLyBUaGUgcGF0aCBkb2VzIG5vdCBjb250YWluIHRoZSByZXF1aXJlZCBzZXQgb2YgbGVhZGluZyBzbGFzaGVzLCBzbyBhZGQgdGhlbS5cclxuICAgICAgICBwYXRoID0gbGVhZGluZ19zbGFzaGVzICsgcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBEb25lXHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGaWxlTmFtZShmaWxlX3BhdGg6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHBhdGgucGFyc2UoZmlsZV9wYXRoKS5iYXNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gam9pbk9iamVjdFByb3BlcnRpZXMob2JqZWN0OiB7fSwgZ2x1ZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgIGZvciAoY29uc3QgcHJvcGVydHlfbmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gZ2x1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJlc3VsdCArPSBvYmplY3RbcHJvcGVydHlfbmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBJZGVhIGlzIGNvcGllZCAyMDIxLTEwLTA2IGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzMTIxODgwLzI3NTQwMjZcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVBcnJheShhcnJheTogYW55W10pIHtcclxuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xyXG59XHJcblxyXG4vKipcclxuICogT3BlbnMgYSB3ZWIgYnJvd3NlciBpbiB0aGUgc3BlY2lmaWVkIFVSTC5cclxuICogQHBhcmFtIHVybFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdvdG9VUkwodXJsOiBzdHJpbmcpIHtcclxuICAgIHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpOyAvLyBUaGlzIHJldHVybnMgYSBwcm9taXNlLCBidXQgaXQgY2FuIGJlIGlnbm9yZWQgYXMgdGhlcmUncyBub3RoaW5nIHRvIGRvIGFmdGVyIG9wZW5pbmcgdGhlIGJyb3dzZXIuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZE5hbWUocGx1Z2luOiBTQ19QbHVnaW4sIHNoZWxsX2NvbW1hbmQ6IHN0cmluZywgYWxpYXM6IHN0cmluZykge1xyXG4gICAgY29uc3QgcHJlZml4ID0gcGx1Z2luLnNldHRpbmdzLm9ic2lkaWFuX2NvbW1hbmRfcGFsZXR0ZV9wcmVmaXg7XHJcbiAgICBpZiAoYWxpYXMpIHtcclxuICAgICAgICAvLyBJZiBhbiBhbGlhcyBpcyBzZXQgZm9yIHRoZSBjb21tYW5kLCBPYnNpZGlhbidzIGNvbW1hbmQgcGFsZXR0ZSBzaG91bGQgZGlzcGxheSB0aGUgYWxpYXMgdGV4dCBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgY29tbWFuZC5cclxuICAgICAgICByZXR1cm4gcHJlZml4ICsgYWxpYXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlZml4ICsgc2hlbGxfY29tbWFuZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZTogc3RyaW5nLCBhbGxvd19taW51czogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGFsbG93X21pbnVzKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdmFsdWUubWF0Y2goL14tP1xcZCskLyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhIXZhbHVlLm1hdGNoKC9eXFxkKyQvKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgMS1pbmRleGVkIGNhcmV0IGxpbmUgYW5kIGNvbHVtbiB0byBhIDAtaW5kZXhlZCBFZGl0b3JQb3NpdGlvbiBvYmplY3QuIEFsc28gdHJhbnNsYXRlcyBhIHBvc3NpYmx5IG5lZ2F0aXZlIGxpbmVcclxuICogdG8gYSBwb3NpdGl2ZSBsaW5lIGZyb20gdGhlIGVuZCBvZiB0aGUgZmlsZSwgYW5kIGEgcG9zc2libHkgbmVnYXRpdmUgY29sdW1uIHRvIGEgcG9zaXRpdmUgY29sdW1uIGZyb20gdGhlIGVuZCBvZiB0aGUgbGluZS5cclxuICogQHBhcmFtIGVkaXRvclxyXG4gKiBAcGFyYW0gY2FyZXRfbGluZVxyXG4gKiBAcGFyYW0gY2FyZXRfY29sdW1uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUVkaXRvclBvc2l0aW9uKGVkaXRvcjogRWRpdG9yLCBjYXJldF9saW5lOiBudW1iZXIsIGNhcmV0X2NvbHVtbjogbnVtYmVyKTogRWRpdG9yUG9zaXRpb24ge1xyXG4gICAgLy8gRGV0ZXJtaW5lIGxpbmVcclxuICAgIGlmIChjYXJldF9saW5lIDwgMCkge1xyXG4gICAgICAgIC8vIE5lZ2F0aXZlIGxpbmUgbWVhbnMgdG8gY2FsY3VsYXRlIGl0IGZyb20gdGhlIGVuZCBvZiB0aGUgZmlsZS5cclxuICAgICAgICBjYXJldF9saW5lID0gTWF0aC5tYXgoMCwgZWRpdG9yLmxhc3RMaW5lKCkgKyBjYXJldF9saW5lICsgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFBvc2l0aXZlIGxpbmUgbmVlZHMganVzdCBhIHNtYWxsIGFkanVzdG1lbnQuXHJcbiAgICAgICAgLy8gRWRpdG9yIGxpbmUgaXMgemVyby1pbmRleGVkLCBsaW5lIG51bWJlcnMgYXJlIDEtaW5kZXhlZC5cclxuICAgICAgICBjYXJldF9saW5lIC09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGNvbHVtblxyXG4gICAgaWYgKGNhcmV0X2NvbHVtbiA8IDApIHtcclxuICAgICAgICAvLyBOZWdhdGl2ZSBjb2x1bW4gbWVhbnMgdG8gY2FsY3VsYXRlIGl0IGZyb20gdGhlIGVuZCBvZiB0aGUgbGluZS5cclxuICAgICAgICBjYXJldF9jb2x1bW4gPSBNYXRoLm1heCgwLCBlZGl0b3IuZ2V0TGluZShjYXJldF9saW5lKS5sZW5ndGggKyBjYXJldF9jb2x1bW4gKyAxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUG9zaXRpdmUgY29sdW1uIG5lZWRzIGp1c3QgYSBzbWFsbCBhZGp1c3RtZW50LlxyXG4gICAgICAgIC8vIEVkaXRvciBjb2x1bW4gaXMgemVyby1pbmRleGVkLCBjb2x1bW4gbnVtYmVycyBhcmUgMS1pbmRleGVkLlxyXG4gICAgICAgIGNhcmV0X2NvbHVtbiAtPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGluZTogY2FyZXRfbGluZSxcclxuICAgICAgICBjaDogY2FyZXRfY29sdW1uLFxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRnJvbVRleHRhcmVhKHRleHRhcmVhX2VsZW1lbnQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQsIHJldHVybl9udWxsX2lmX2VtcHR5OiB0cnVlKTogc3RyaW5nIHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkZyb21UZXh0YXJlYSh0ZXh0YXJlYV9lbGVtZW50OiBIVE1MVGV4dEFyZWFFbGVtZW50LCByZXR1cm5fbnVsbF9pZl9lbXB0eTogZmFsc2UpOiBzdHJpbmc7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb25Gcm9tVGV4dGFyZWEodGV4dGFyZWFfZWxlbWVudDogSFRNTFRleHRBcmVhRWxlbWVudCwgcmV0dXJuX251bGxfaWZfZW1wdHk6IGJvb2xlYW4pOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkX3RleHQgPSB0ZXh0YXJlYV9lbGVtZW50LnZhbHVlLnN1YnN0cmluZyh0ZXh0YXJlYV9lbGVtZW50LnNlbGVjdGlvblN0YXJ0LCB0ZXh0YXJlYV9lbGVtZW50LnNlbGVjdGlvbkVuZCk7XHJcbiAgICByZXR1cm4gXCJcIiA9PT0gc2VsZWN0ZWRfdGV4dCAmJiByZXR1cm5fbnVsbF9pZl9lbXB0eSA/IG51bGwgOiBzZWxlY3RlZF90ZXh0O1xyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsLCBPdXRwdXRDaGFubmVsT3JkZXJ9IGZyb20gXCIuLi9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQge1xyXG4gICAgSUNvbW1hbmRQYWxldHRlT3B0aW9ucyxcclxuICAgIElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nLFxyXG4gICAgSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmdXaXRoRGVmYXVsdCxcclxufSBmcm9tIFwiLi9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtTQ19FdmVudENvbmZpZ3VyYXRpb25zfSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50Q29uZmlndXJhdGlvblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaGVsbENvbW1hbmRzQ29uZmlndXJhdGlvbiB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWlucyBvcGVyYXRpbmcgc3lzdGVtIHNwZWNpZmljIHNoZWxsIGNvbW1hbmRzLlxyXG4gICAgICogIC0ga2V5OiBwbGF0Zm9ybSAoPSBPUykgbmFtZVxyXG4gICAgICogIC0gdmFsdWU6IHNoZWxsIGNvbW1hbmRcclxuICAgICAqL1xyXG4gICAgcGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHM6IElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nV2l0aERlZmF1bHQ7XHJcbiAgICBzaGVsbHM6IElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nO1xyXG4gICAgYWxpYXM6IHN0cmluZztcclxuICAgIGNvbmZpcm1fZXhlY3V0aW9uOiBib29sZWFuO1xyXG4gICAgaWdub3JlX2Vycm9yX2NvZGVzOiBudW1iZXJbXTtcclxuICAgIG91dHB1dF9jaGFubmVsczoge1xyXG4gICAgICAgIHN0ZG91dDogT3V0cHV0Q2hhbm5lbCxcclxuICAgICAgICBzdGRlcnI6IE91dHB1dENoYW5uZWwsXHJcbiAgICB9LFxyXG4gICAgb3V0cHV0X2NoYW5uZWxfb3JkZXI6IE91dHB1dENoYW5uZWxPcmRlcjtcclxuICAgIGV2ZW50czogU0NfRXZlbnRDb25maWd1cmF0aW9ucztcclxuICAgIGNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHk6IGtleW9mIElDb21tYW5kUGFsZXR0ZU9wdGlvbnM7XHJcblxyXG4gICAgLy8gTEVHQUNZXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgQ2FuIG9ubHkgYmUgdXNlZCBmb3IgbWlncmF0aW9uLiAqL1xyXG4gICAgc2hlbGxfY29tbWFuZD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5ld1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24oc2hlbGxfY29tbWFuZDogc3RyaW5nID0gXCJcIik6IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kczoge1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBzaGVsbF9jb21tYW5kLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hlbGxzOiB7fSxcclxuICAgICAgICBhbGlhczogXCJcIixcclxuICAgICAgICBjb25maXJtX2V4ZWN1dGlvbjogZmFsc2UsXHJcbiAgICAgICAgaWdub3JlX2Vycm9yX2NvZGVzOiBbXSxcclxuICAgICAgICBvdXRwdXRfY2hhbm5lbHM6IHtcclxuICAgICAgICAgICAgc3Rkb3V0OiBcImlnbm9yZVwiLFxyXG4gICAgICAgICAgICBzdGRlcnI6IFwibm90aWZpY2F0aW9uXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdXRwdXRfY2hhbm5lbF9vcmRlcjogXCJzdGRvdXQtZmlyc3RcIixcclxuICAgICAgICBldmVudHM6IHt9LFxyXG4gICAgICAgIGNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHk6IFwiZW5hYmxlZFwiLFxyXG4gICAgfVxyXG59IiwiLy8gU0VUVElOR1MgQU5EIERFRkFVTFQgVkFMVUVTXHJcbmltcG9ydCB7U2hlbGxDb21tYW5kc0NvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IHR5cGUgU2V0dGluZ3NWZXJzaW9uU3RyaW5nID0gXCJwcmlvci10by0wLjcuMFwiIHwgc3RyaW5nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTQ19NYWluU2V0dGluZ3Mge1xyXG5cclxuICAgIC8vIENvbW1vbjpcclxuICAgIHNldHRpbmdzX3ZlcnNpb246IFNldHRpbmdzVmVyc2lvblN0cmluZztcclxuXHJcbiAgICAvLyBIaWRkZW4gc2V0dGluZ3MgKG5vIFVJIGNvbnRyb2xzIGluIHRoZSBzZXR0aW5ncyBwYW5lbClcclxuICAgIC8qKlxyXG4gICAgICogSWYgdHJ1ZSwgbG9nZ2luZyBzdHVmZiB0byBjb25zb2xlLmxvZygpIHdpbGwgYmUgZW5hYmxlZC5cclxuICAgICAqIE1pZ2h0IGFsc28gZW5hYmxlIHNvbWUgdGVzdGluZyB7e3ZhcmlhYmxlc319IGluIHRoZSBmdXR1cmUsIHBlcmhhcHMuXHJcbiAgICAgKi9cclxuICAgIGRlYnVnOiBib29sZWFuO1xyXG4gICAgb2JzaWRpYW5fY29tbWFuZF9wYWxldHRlX3ByZWZpeDogc3RyaW5nO1xyXG5cclxuICAgIC8vIFZhcmlhYmxlczpcclxuICAgIHByZXZpZXdfdmFyaWFibGVzX2luX2NvbW1hbmRfcGFsZXR0ZTogYm9vbGVhbjtcclxuICAgIHNob3dfYXV0b2NvbXBsZXRlX21lbnU6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gT3BlcmF0aW5nIHN5c3RlbXMgJiBzaGVsbHM6XHJcbiAgICB3b3JraW5nX2RpcmVjdG9yeTogc3RyaW5nO1xyXG4gICAgZGVmYXVsdF9zaGVsbHM6IElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nO1xyXG5cclxuICAgIC8vIE91dHB1dDpcclxuICAgIGVycm9yX21lc3NhZ2VfZHVyYXRpb246IG51bWJlcjtcclxuICAgIG5vdGlmaWNhdGlvbl9tZXNzYWdlX2R1cmF0aW9uOiBudW1iZXI7XHJcbiAgICBvdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBFdmVudHM6XHJcbiAgICBlbmFibGVfZXZlbnRzOiBib29sZWFuO1xyXG5cclxuICAgIC8vIFNoZWxsIGNvbW1hbmRzOlxyXG4gICAgc2hlbGxfY29tbWFuZHM6IFNoZWxsQ29tbWFuZHNDb25maWd1cmF0aW9uO1xyXG5cclxuICAgIC8vIExlZ2FjeTpcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Ugc2hlbGxfY29tbWFuZHMgb2JqZWN0IGluc3RlYWQgb2YgdGhpcyBhcnJheS4gRnJvbSBub3cgb24sIHRoaXMgYXJyYXkgY2FuIGJlIHVzZWQgb25seSBmb3IgbWlncmF0aW5nIG9sZCBjb25maWd1cmF0aW9uIHRvIHNoZWxsX2NvbW1hbmRzLiovXHJcbiAgICBjb21tYW5kcz86IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFNldHRpbmdzKGlzX25ld19pbnN0YWxsYXRpb246IGJvb2xlYW4pOiBTQ19NYWluU2V0dGluZ3Mge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBDb21tb246XHJcbiAgICAgICAgc2V0dGluZ3NfdmVyc2lvbjogaXNfbmV3X2luc3RhbGxhdGlvblxyXG4gICAgICAgICAgICA/IFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb24gLy8gRm9yIG5ldyBpbnN0YWxsYXRpb25zLCBhIHNwZWNpZmljIHNldHRpbmdzIHZlcnNpb24gbnVtYmVyIGNhbiBiZSB1c2VkLCBhcyBtaWdyYXRpb25zIGRvIG5vdCBuZWVkIHRvIGJlIHRha2VuIGludG8gYWNjb3VudC5cclxuICAgICAgICAgICAgOiBcInByaW9yLXRvLTAuNy4wXCIgIC8vIFRoaXMgd2lsbCBiZSBzdWJzdGl0dXRlZCBieSBTaGVsbENvbW1hbmRzUGx1Z2luLnNhdmVTZXR0aW5ncygpIHdoZW4gdGhlIHNldHRpbmdzIGFyZSBzYXZlZC5cclxuICAgICAgICAsXHJcblxyXG4gICAgICAgIC8vIEhpZGRlbiBzZXR0aW5ncyAobm8gVUkgY29udHJvbHMgaW4gdGhlIHNldHRpbmdzIHBhbmVsKVxyXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcclxuICAgICAgICBvYnNpZGlhbl9jb21tYW5kX3BhbGV0dGVfcHJlZml4OiBcIkV4ZWN1dGU6IFwiLFxyXG5cclxuICAgICAgICAvLyBWYXJpYWJsZXM6XHJcbiAgICAgICAgcHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlOiB0cnVlLFxyXG4gICAgICAgIHNob3dfYXV0b2NvbXBsZXRlX21lbnU6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIE9wZXJhdGluZyBzeXN0ZW1zIGFuZCBzaGVsbHM6XHJcbiAgICAgICAgd29ya2luZ19kaXJlY3Rvcnk6IFwiXCIsXHJcbiAgICAgICAgZGVmYXVsdF9zaGVsbHM6IHt9LFxyXG5cclxuICAgICAgICAvLyBPdXRwdXQ6XHJcbiAgICAgICAgZXJyb3JfbWVzc2FnZV9kdXJhdGlvbjogMjAsXHJcbiAgICAgICAgbm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb246IDEwLFxyXG4gICAgICAgIG91dHB1dF9jaGFubmVsX2NsaXBib2FyZF9hbHNvX291dHB1dHNfdG9fbm90aWZpY2F0aW9uOiB0cnVlLFxyXG5cclxuICAgICAgICAvLyBFdmVudHM6XHJcbiAgICAgICAgZW5hYmxlX2V2ZW50czogdHJ1ZSxcclxuXHJcbiAgICAgICAgLy8gU2hlbGwgY29tbWFuZHM6XHJcbiAgICAgICAgc2hlbGxfY29tbWFuZHM6IHt9LFxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWxsIE9TZXMgc3VwcG9ydGVkIGJ5IHRoZSBTaGVsbCBjb21tYW5kcyBwbHVnaW4uXHJcbiAqIFZhbHVlcyBhcmUgYm9ycm93ZWQgZnJvbSBOb2RlSlMuUGxhdGZvcm0uXHJcbiAqIFwiZGFyd2luXCIgPSBNYWNpbnRvc2guXHJcbiAqXHJcbiAqIFRoaXMgdHlwZSBtdXN0IGJlIHN5bmNocm9ub3VzIHRvIElPcGVyYXRpbmdTeXN0ZW1TcGVjaWZpY1N0cmluZyBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEBzZWUgTm9kZUpTLlBsYXRmb3JtXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQbGF0Zm9ybUlkID0gXCJkYXJ3aW5cIiB8IFwibGludXhcIiB8IFwid2luMzJcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBQbGF0Zm9ybU5hbWVzOiBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZyA9IHtcclxuICAgIGRhcndpbjogXCJNYWNpbnRvc2hcIixcclxuICAgIGxpbnV4OiBcIkxpbnV4XCIsXHJcbiAgICB3aW4zMjogXCJXaW5kb3dzXCIsXHJcbn07XHJcblxyXG4vKipcclxuICogQWxsIE9TZXMgc3VwcG9ydGVkIGJ5IHRoZSBTaGVsbCBjb21tYW5kcyBwbHVnaW4uXHJcbiAqIFZhbHVlcyBhcmUgYm9ycm93ZWQgZnJvbSBOb2RlSlMuUGxhdGZvcm0uXHJcbiAqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIG11c3QgYmUgc3luY2hyb25vdXMgdG8gT3BlcmF0aW5nU3lzdGVtTmFtZSB0eXBlLlxyXG4gKlxyXG4gKiBAc2VlIE5vZGVKUy5QbGF0Zm9ybVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGxhdGZvcm1TcGVjaWZpY1N0cmluZyB7XHJcbiAgICAvKiogVGhpcyBpcyBNYWNpbnRvc2ggKi9cclxuICAgIGRhcndpbj86IHN0cmluZyxcclxuICAgIGxpbnV4Pzogc3RyaW5nLFxyXG4gICAgd2luMzI/OiBzdHJpbmcsXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBsYXRmb3JtU3BlY2lmaWNTdHJpbmdXaXRoRGVmYXVsdCBleHRlbmRzIElQbGF0Zm9ybVNwZWNpZmljU3RyaW5ne1xyXG4gICAgZGVmYXVsdDogc3RyaW5nLFxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBJQ29tbWFuZFBhbGV0dGVPcHRpb25zID0ge1xyXG4gICAgZW5hYmxlZDogc3RyaW5nO1xyXG4gICAgdW5saXN0ZWQ6IHN0cmluZztcclxuICAgIGRpc2FibGVkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBDb21tYW5kUGFsZXR0ZU9wdGlvbnM6IElDb21tYW5kUGFsZXR0ZU9wdGlvbnMgPSB7XHJcbiAgICBlbmFibGVkOiBcIkNvbW1hbmQgcGFsZXR0ZSAmIGhvdGtleXNcIixcclxuICAgIHVubGlzdGVkOiBcIkhvdGtleXMgb25seVwiLFxyXG4gICAgZGlzYWJsZWQ6IFwiRXhjbHVkZWRcIixcclxufSIsImltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge25ld1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24sIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb259IGZyb20gXCIuL3NldHRpbmdzL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4vRGVidWdcIjtcclxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XHJcbmltcG9ydCB7Y29tYmluZU9iamVjdHMsIGdldFBsdWdpbkFic29sdXRlUGF0aH0gZnJvbSBcIi4vQ29tbW9uXCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHtnZXREZWZhdWx0U2V0dGluZ3N9IGZyb20gXCIuL3NldHRpbmdzL1NDX01haW5TZXR0aW5nc1wiO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFJ1bk1pZ3JhdGlvbnMocGx1Z2luOiBTQ19QbHVnaW4pIHtcclxuICAgIGNvbnN0IHNob3VsZF9zYXZlID0gWyAvLyBJZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBpcyB0cnVlLCBzYXZpbmcgd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICAgICAgRW5zdXJlTWFpbkZpZWxkc0V4aXN0KHBsdWdpbiksIC8vIERvIHRoaXMgZWFybHkuXHJcbiAgICAgICAgTWlncmF0ZUNvbW1hbmRzVG9TaGVsbENvbW1hbmRzKHBsdWdpbiksXHJcbiAgICAgICAgTWlncmF0ZVNoZWxsQ29tbWFuZFRvUGxhdGZvcm1zKHBsdWdpbiksXHJcbiAgICAgICAgRW5zdXJlU2hlbGxDb21tYW5kc0hhdmVBbGxGaWVsZHMocGx1Z2luKSxcclxuICAgICAgICBEZWxldGVFbXB0eUNvbW1hbmRzRmllbGQocGx1Z2luKSxcclxuICAgIF07XHJcbiAgICBpZiAoc2hvdWxkX3NhdmUuaW5jbHVkZXModHJ1ZSkpIHtcclxuICAgICAgICAvLyBPbmx5IHNhdmUgaWYgdGhlcmUgd2VyZSBjaGFuZ2VzIHRvIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgZGVidWdMb2coXCJTYXZpbmcgbWlncmF0aW9ucy4uLlwiKVxyXG4gICAgICAgIGJhY2t1cFNldHRpbmdzRmlsZShwbHVnaW4pOyAvLyBNYWtlIGEgYmFja3VwIGNvcHkgb2YgdGhlIG9sZCBmaWxlIEJFRk9SRSB3cml0aW5nIHRoZSBuZXcsIG1pZ3JhdGVkIHNldHRpbmdzIGZpbGUuXHJcbiAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIGRlYnVnTG9nKFwiTWlncmF0aW9ucyBzYXZlZC4uLlwiKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2FuIGJlIHJlbW92ZWQgaW4gMS4wLjAuXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNaWdyYXRlQ29tbWFuZHNUb1NoZWxsQ29tbWFuZHMocGx1Z2luOiBTQ19QbHVnaW4pIHtcclxuICAgIGlmICh1bmRlZmluZWQgPT09IHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvdW50X3NoZWxsX2NvbW1hbmRzID0gcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzLmxlbmd0aDtcclxuICAgIGxldCBzYXZlID0gZmFsc2U7XHJcbiAgICBpZiAoMCA8IGNvdW50X3NoZWxsX2NvbW1hbmRzKSB7XHJcbiAgICAgICAgbGV0IGNvdW50X2VtcHR5X2NvbW1hbmRzID0gMDsgLy8gQSBjb3VudGVyIGZvciBlbXB0eSBvciBudWxsIGNvbW1hbmRzXHJcbiAgICAgICAgZGVidWdMb2coXCJzZXR0aW5ncy5jb21tYW5kcyBpcyBub3QgZW1wdHksIHdpbGwgbWlncmF0ZSBcIiArIGNvdW50X3NoZWxsX2NvbW1hbmRzICsgXCIgY29tbWFuZHMgdG8gc2V0dGluZ3Muc2hlbGxfY29tbWFuZHMuXCIpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNvbW1hbmQgaXMgbm90IGVtcHR5LiBKdXN0IGluIGNhc2UuXHJcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzaGVsbF9jb21tYW5kIHx8IDAgPT09IHNoZWxsX2NvbW1hbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tbWFuZCBpcyBlbXB0eVxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJNaWdyYXRpb24gZmFpbHVyZSBmb3Igc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFRoZSBvcmlnaW5hbCBzaGVsbCBjb21tYW5kIHN0cmluZyBpcyBlbXB0eSwgc28gaXQgY2Fubm90IGJlIG1pZ3JhdGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIGNvdW50X2VtcHR5X2NvbW1hbmRzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5kZWZpbmVkICE9PSBwbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIEEgY29tbWFuZCB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIk1pZ3JhdGlvbiBmYWlsdXJlIGZvciBzaGVsbCBjb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfaWQgKyBcIjogQSBzaGVsbCBjb21tYW5kIHdpdGggc2FtZSBJRCBhbHJlYWR5IGV4aXN0cyBpbiBzZXR0aW5ncy5zaGVsbF9jb21tYW5kcy5cIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgT0ssIG1pZ3JhdGUuXHJcbiAgICAgICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKHNoZWxsX2NvbW1hbmQpOyAvLyBDcmVhdGVzIGEgc2hlbGwgY29tbWFuZCB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCBkZWZpbmVzIHRoZSBjb21tYW5kIGZvciBpdC5cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF07IC8vIExlYXZlcyBhIG51bGwgaW4gcGxhY2UsIGJ1dCB3ZSBjYW4gZGVhbCB3aXRoIGl0IGJ5IGRlbGV0aW5nIHRoZSB3aG9sZSBhcnJheSBpZiBpdCBnZXRzIGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgY291bnRfZW1wdHlfY29tbWFuZHMrKzsgLy8gQWNjb3VudCB0aGUgbnVsbCBnZW5lcmF0ZWQgb24gdGhlIHByZXZpb3VzIGxpbmUuXHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiTWlncmF0ZWQgc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFwiICsgc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50X2VtcHR5X2NvbW1hbmRzID09PSBjb3VudF9zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgY29tbWFuZHMgYXJyYXkgbm93IGNvbnRhaW5zIG9ubHkgZW1wdHkvbnVsbCBjb21tYW5kcy5cclxuICAgICAgICAgICAgLy8gRGVsZXRlIGl0LlxyXG4gICAgICAgICAgICBkZWxldGUgcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJzZXR0aW5ncy5jb21tYW5kcyBpcyBlbXB0eSwgc28gbm8gbmVlZCB0byBtaWdyYXRlIGNvbW1hbmRzLiBHb29kIHRoaW5nISA6KVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzYXZlO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGdlbmVyYWwgbWlncmF0b3IgdGhhdCBhZGRzIG5ldywgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gb2JqZWN0cy4gVGhpcyBpcyBub3QgdGllZCB0byBhbnkgc3BlY2lmaWMgdmVyc2lvbiB1cGRhdGUsIHVubGlrZSBNaWdyYXRlQ29tbWFuZHNUb1NoZWxsQ29tbWFuZHMoKS5cclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgY29uc3Qgc2hlbGxfY29tbWFuZF9kZWZhdWx0X2NvbmZpZ3VyYXRpb24gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKCk7XHJcbiAgICBsZXQgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nO1xyXG4gICAgY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucyA9IHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcztcclxuICAgIGZvciAoc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uID0gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5X25hbWUgaW4gc2hlbGxfY29tbWFuZF9kZWZhdWx0X2NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlIGNhbiBoYXZlIChhbG1vc3QpIHdoYXRldmVyIGRhdGF0eXBlXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5X2RlZmF1bHRfdmFsdWU6IGFueSA9IHNoZWxsX2NvbW1hbmRfZGVmYXVsdF9jb25maWd1cmF0aW9uW3Byb3BlcnR5X25hbWVdO1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbltwcm9wZXJ0eV9uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaGVsbCBjb21tYW5kIGRvZXMgbm90IGhhdmUgdGhpcyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcHJvcGVydHkgdG8gdGhlIHNoZWxsIGNvbW1hbmQgYW5kIHVzZSBhIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKCk6IFNoZWxsIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiIGRvZXMgbm90IGhhdmUgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlfbmFtZSArIFwiJy4gV2lsbCBjcmVhdGUgdGhlIHByb3BlcnR5IGFuZCBhc3NpZ24gYSBkZWZhdWx0IHZhbHVlICdcIiArIHByb3BlcnR5X2RlZmF1bHRfdmFsdWUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uW3Byb3BlcnR5X25hbWVdID0gcHJvcGVydHlfZGVmYXVsdF92YWx1ZTtcclxuICAgICAgICAgICAgICAgIHNhdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNhdmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgZ2VuZXJhbCBtaWdyYXRvciB0aGF0IGFkZHMgbmV3LCBtaXNzaW5nIHByb3BlcnRpZXMgdG8gdGhlIG1haW4gc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGlzIG5vdCB0aWVkIHRvIGFueSBzcGVjaWZpYyB2ZXJzaW9uIHVwZGF0ZSwgdW5saWtlIE1pZ3JhdGVDb21tYW5kc1RvU2hlbGxDb21tYW5kcygpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRW5zdXJlTWFpbkZpZWxkc0V4aXN0KHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgaGFzX21pc3NpbmdfZmllbGRzID0gZmFsc2U7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IHBsdWdpbi5zZXR0aW5ncztcclxuICAgIGNvbnN0IGRlZmF1bHRfc2V0dGluZ3MgPSBnZXREZWZhdWx0U2V0dGluZ3MoZmFsc2UpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eV9uYW1lIGluIGRlZmF1bHRfc2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc2V0dGluZ3NbcHJvcGVydHlfbmFtZV0pIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgcHJvcGVydHkuXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgcHJvcGVydHlfZGVmYXVsdF92YWx1ZSBjYW4gaGF2ZSAoYWxtb3N0KSB3aGF0ZXZlciBkYXRhdHlwZVxyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF9zZXR0aW5nc1twcm9wZXJ0eV9uYW1lXTtcclxuICAgICAgICAgICAgZGVidWdMb2coXCJFbnN1cmVNYWluRmllbGRzRXhpc3QoKTogTWFpbiBzZXR0aW5ncyBkb2VzIG5vdCBoYXZlIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicuIFdpbGwgbGF0ZXIgY3JlYXRlIHRoZSBwcm9wZXJ0eSBhbmQgYXNzaWduIGEgZGVmYXVsdCB2YWx1ZSAnXCIgKyBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlICsgXCInLlwiKTtcclxuICAgICAgICAgICAgaGFzX21pc3NpbmdfZmllbGRzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc19taXNzaW5nX2ZpZWxkcykge1xyXG4gICAgICAgIGRlYnVnTG9nKFwiRW5zdXJlTWFpbkZpZWxkc0V4aXN0KCk6IERvaW5nIHRoZSBhYm92ZS1tZW50aW9uZWQgbmV3IGZpZWxkIGNyZWF0aW9ucy4uLlwiKTtcclxuICAgICAgICBwbHVnaW4uc2V0dGluZ3MgPSBjb21iaW5lT2JqZWN0cyhkZWZhdWx0X3NldHRpbmdzLCBwbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgIGRlYnVnTG9nKFwiRW5zdXJlTWFpbkZpZWxkc0V4aXN0KCk6IERvbmUuXCIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBTYXZlIHRoZSBjaGFuZ2VzXHJcbiAgICB9XHJcblxyXG4gICAgZGVidWdMb2coXCJFbnN1cmVNYWluRmllbGRzRXhpc3QoKTogTm8gbmV3IGZpZWxkcyB0byBjcmVhdGUsIGFsbCBvay5cIik7XHJcbiAgICByZXR1cm4gZmFsc2U7IC8vIE5vdGhpbmcgdG8gc2F2ZS5cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbiBiZSByZW1vdmVkIGluIDEuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTWlncmF0ZVNoZWxsQ29tbWFuZFRvUGxhdGZvcm1zKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgZm9yIChjb25zdCBzaGVsbF9jb21tYW5kX2lkIGluIHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgIGNvbnN0IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiA9IHBsdWdpbi5zZXR0aW5ncy5zaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2hlbGwgY29tbWFuZCBzaG91bGQgYmUgbWlncmF0ZWQuXHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kcyB8fCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHMuZGVmYXVsdCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJNaWdyYXRpbmcgc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IHNoZWxsX2NvbW1hbmQgc3RyaW5nIHdpbGwgYmUgbW92ZWQgdG8gcGxhdGZvcm1zLmRlZmF1bHQ6IFwiICsgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZDtcclxuICAgICAgICAgICAgICAgIHNhdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJNaWdyYXRpb24gZmFpbHVyZSBmb3Igc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IHBsYXRmb3JtcyBleGlzdHMgYWxyZWFkeS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2F2ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbiBiZSByZW1vdmVkIGluIDEuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRGVsZXRlRW1wdHlDb21tYW5kc0ZpZWxkKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgaWYgKHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcztcclxuICAgICAgICAgICAgc2F2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNhdmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJtYW5lbnQsIGRvIG5vdCByZW1vdmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwbHVnaW5cclxuICovXHJcbmZ1bmN0aW9uIGJhY2t1cFNldHRpbmdzRmlsZShwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgLy8gcGx1Z2luLmFwcC5maWxlTWFuYWdlci5cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvbiA9IChwbHVnaW4uc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbiA9PT0gXCJwcmlvci10by0wLjcuMFwiKSA/IFwiMC54XCIgOiBwbHVnaW4uc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbjtcclxuICAgIGNvbnN0IHBsdWdpbl9wYXRoID0gZ2V0UGx1Z2luQWJzb2x1dGVQYXRoKHBsdWdpbik7XHJcbiAgICBjb25zdCBzZXR0aW5nc19maWxlX3BhdGggPSBwYXRoLmpvaW4ocGx1Z2luX3BhdGgsIFwiZGF0YS5qc29uXCIpO1xyXG4gICAgY29uc3QgYmFja3VwX2ZpbGVfcGF0aF93aXRob3V0X2V4dGVuc2lvbiA9IHBhdGguam9pbihwbHVnaW5fcGF0aCwgXCJkYXRhLWJhY2t1cC12ZXJzaW9uLVwiICsgY3VycmVudF9zZXR0aW5nc192ZXJzaW9uICsgXCItYmVmb3JlLXVwZ3JhZGluZy10by1cIiArIFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb24pO1xyXG5cclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGN1cnJlbnQgc2V0dGluZ3MgZmlsZSBjYW4gYmUgZm91bmQuXHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc2V0dGluZ3NfZmlsZV9wYXRoKSkge1xyXG4gICAgICAgIC8vIE5vdCBmb3VuZC4gUHJvYmFibHkgdGhlIHZhdWx0IHVzZXMgYSBkaWZmZXJlbnQgY29uZmlnIGZvbGRlciB0aGFuIC5vYnNpZGlhbi5cclxuICAgICAgICBkZWJ1Z0xvZyhcImJhY2t1cFNldHRpbmdzRmlsZSgpOiBDYW5ub3QgZmluZCBkYXRhLmpzb25cIik7XHJcbiAgICAgICAgcGx1Z2luLm5ld0Vycm9yKFwiU2hlbGwgY29tbWFuZHM6IENhbm5vdCBjcmVhdGUgYSBiYWNrdXAgb2YgY3VycmVudCBzZXR0aW5ncyBmaWxlLCBiZWNhdXNlIGRhdGEuanNvbiBpcyBub3QgZm91bmQuXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYmFja3VwX2ZpbGVfcGF0aCA9IGJhY2t1cF9maWxlX3BhdGhfd2l0aG91dF9leHRlbnNpb24gKyBcIi5qc29uXCI7XHJcbiAgICBsZXQgcnVubmluZ19udW1iZXIgPSAxO1xyXG4gICAgd2hpbGUgKGZzLmV4aXN0c1N5bmMoYmFja3VwX2ZpbGVfcGF0aCkpIHtcclxuICAgICAgICBydW5uaW5nX251bWJlcisrOyAvLyBUaGUgZmlyc3QgbnVtYmVyIHdpbGwgYmUgMi5cclxuICAgICAgICBiYWNrdXBfZmlsZV9wYXRoID0gYmFja3VwX2ZpbGVfcGF0aF93aXRob3V0X2V4dGVuc2lvbiArIFwiLVwiICsgcnVubmluZ19udW1iZXIgKyBcIi5qc29uXCI7XHJcbiAgICAgICAgaWYgKHJ1bm5pbmdfbnVtYmVyID49IDEwMDApIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgc29tZSBwcm9ibGVtIHdpdGggZGV0ZWN0aW5nIGV4aXN0aW5nL2luZXhpc3RpbmcgZmlsZXMuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgaGFuZ2luZyB0aGUgcHJvZ3JhbSBpbiBhbiBldGVybmFsIGxvb3AuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhY2t1cFNldHRpbmdzRmlsZSgpOiBFdGVybmFsIGxvb3AgZGV0ZWN0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZzLmNvcHlGaWxlU3luYyhzZXR0aW5nc19maWxlX3BhdGgsIGJhY2t1cF9maWxlX3BhdGgpO1xyXG59IiwiaW1wb3J0IHtleHRyYWN0RmlsZU5hbWUsIGdldE9wZXJhdGluZ1N5c3RlbSwgaXNXaW5kb3dzfSBmcm9tIFwiLi9Db21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBQbGF0Zm9ybVNoZWxscyA9IHtcclxuICAgIGRhcndpbjoge1xyXG4gICAgICAgIFwiL2Jpbi9iYXNoXCI6IFwiQmFzaFwiLFxyXG4gICAgICAgIFwiL2Jpbi9kYXNoXCI6IFwiRGFzaFwiLFxyXG4gICAgICAgIFwiL2Jpbi96c2hcIjogXCJac2ggKFogc2hlbGwpXCIsXHJcbiAgICB9LFxyXG4gICAgbGludXg6IHtcclxuICAgICAgICBcIi9iaW4vYmFzaFwiOiBcIkJhc2hcIixcclxuICAgICAgICBcIi9iaW4vZGFzaFwiOiBcIkRhc2hcIixcclxuICAgICAgICBcIi9iaW4venNoXCI6IFwiWnNoIChaIHNoZWxsKVwiLFxyXG4gICAgfSxcclxuICAgIHdpbjMyOiB7XHJcbiAgICAgICAgXCJwd3NoLmV4ZVwiOiBcIlBvd2VyU2hlbGwgQ29yZVwiLFxyXG4gICAgICAgIFwiUG93ZXJTaGVsbC5leGVcIjogXCJQb3dlclNoZWxsIDVcIixcclxuICAgICAgICBcIkNNRC5FWEVcIjogXCJjbWQuZXhlXCIsXHJcbiAgICB9LFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlcnNEZWZhdWx0U2hlbGwoKTogc3RyaW5nIHtcclxuICAgIGlmIChpc1dpbmRvd3MoKSkge1xyXG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5Db21TcGVjO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuU0hFTEw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1NoZWxsU3VwcG9ydGVkKHNoZWxsOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNoZWxsX2ZpbGVfbmFtZSA9IGV4dHJhY3RGaWxlTmFtZShzaGVsbCk7XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRfc2hlbGxzID0gUGxhdGZvcm1TaGVsbHNbZ2V0T3BlcmF0aW5nU3lzdGVtKCldO1xyXG4gICAgZm9yIChjb25zdCBzdXBwb3J0ZWRfc2hlbGxfcGF0aCBpbiBzdXBwb3J0ZWRfc2hlbGxzKSB7XHJcbiAgICAgICAgaWYgKHN1cHBvcnRlZF9zaGVsbF9wYXRoLnN1YnN0cigtc2hlbGxfZmlsZV9uYW1lLmxlbmd0aCwgc2hlbGxfZmlsZV9uYW1lLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gc2hlbGxfZmlsZV9uYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgLy8gSWYgc3VwcG9ydGVkX3NoZWxsX3BhdGggKGUuZy4gL2Jpbi9iYXNoIG9yIENNRC5FWEUpIGVuZHMgd2l0aCBzaGVsbF9maWxlX25hbWUgKGUuZy4gYmFzaCwgZGVyaXZlZCBmcm9tIC9iaW4vYmFzaCBvciBDTUQuRVhFLCBkZXJpdmVkIGZyb20gQzpcXFN5c3RlbTMyXFxDTUQuRVhFKSwgdGhlbiB0aGUgc2hlbGwgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn0iLCJpbXBvcnQge0lQbGF0Zm9ybVNwZWNpZmljU3RyaW5nLCBQbGF0Zm9ybUlkLCBQbGF0Zm9ybU5hbWVzfSBmcm9tIFwiLi4vU0NfTWFpblNldHRpbmdzXCI7XHJcbmltcG9ydCB7ZXh0cmFjdEZpbGVOYW1lLCBnZXRPcGVyYXRpbmdTeXN0ZW19IGZyb20gXCIuLi8uLi9Db21tb25cIjtcclxuaW1wb3J0IHtnZXRVc2Vyc0RlZmF1bHRTaGVsbCwgUGxhdGZvcm1TaGVsbHN9IGZyb20gXCIuLi8uLi9TaGVsbFwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2hlbGxTZWxlY3Rpb25GaWVsZChwbHVnaW46IFNDX1BsdWdpbiwgY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCBzaGVsbHM6IElQbGF0Zm9ybVNwZWNpZmljU3RyaW5nLCBpc19nbG9iYWxfc2V0dGluZ3M6IGJvb2xlYW4pIHtcclxuICAgIGxldCBwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZDtcclxuICAgIGZvciAocGxhdGZvcm1faWQgaW4gUGxhdGZvcm1OYW1lcykge1xyXG4gICAgICAgIGNvbnN0IHBsYXRmb3JtX25hbWUgPSBQbGF0Zm9ybU5hbWVzW3BsYXRmb3JtX2lkXTtcclxuICAgICAgICBsZXQgb3B0aW9uczoge307XHJcbiAgICAgICAgaWYgKGlzX2dsb2JhbF9zZXR0aW5ncykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X3N5c3RlbV9kZWZhdWx0ID0gKGdldE9wZXJhdGluZ1N5c3RlbSgpID09PSBwbGF0Zm9ybV9pZCkgPyBcIiAoXCIgKyBleHRyYWN0RmlsZU5hbWUoZ2V0VXNlcnNEZWZhdWx0U2hlbGwoKSkgKyBcIilcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XCJkZWZhdWx0XCI6IFwiVXNlIHN5c3RlbSBkZWZhdWx0XCIgKyBjdXJyZW50X3N5c3RlbV9kZWZhdWx0fTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1wiZGVmYXVsdFwiOiBcIlVzZSBkZWZhdWx0XCJ9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxsX3BhdGggaW4gUGxhdGZvcm1TaGVsbHNbcGxhdGZvcm1faWRdKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLy8gVE9ETzogR2V0IHJpZCBvZiB0aGVzZSB0d28gdHMtaWdub3Jlcy5cclxuICAgICAgICAgICAgY29uc3Qgc2hlbGxfbmFtZSA9IFBsYXRmb3JtU2hlbGxzW3BsYXRmb3JtX2lkXVtzaGVsbF9wYXRoXTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBvcHRpb25zW3NoZWxsX3BhdGhdID0gc2hlbGxfbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKHBsYXRmb3JtX25hbWUgKyAoaXNfZ2xvYmFsX3NldHRpbmdzID8gXCIgZGVmYXVsdCBzaGVsbFwiIDogXCIgc2hlbGxcIikpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKChpc19nbG9iYWxfc2V0dGluZ3MgPyBcIkNhbiBiZSBvdmVycmlkZGVuIGJ5IGVhY2ggc2hlbGwgY29tbWFuZC4gXCIgOiBcIlwiKSArIChcIndpbjMyXCIgPT09IHBsYXRmb3JtX2lkID8gXCJQb3dlcnNoZWxsIGlzIHJlY29tbWVuZGVkIG92ZXIgY21kLmV4ZSwgYmVjYXVzZSB0aGlzIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IGVzY2FwaW5nIHZhcmlhYmxlcyBpbiBDTUQuXCIgOiBcIlwiKSlcclxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHNoZWxsc1twbGF0Zm9ybV9pZF0gPz8gXCJkZWZhdWx0XCIpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoKChfcGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQpID0+IHsgcmV0dXJuIGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7IC8vIE5lZWQgdG8gdXNlIGEgbmVzdGVkIGZ1bmN0aW9uIHNvIHRoYXQgcGxhdGZvcm1faWQgY2FuIGJlIHN0b3JlZCBzdGF0aWNhbGx5LCBvdGhlcndpc2UgaXQgd291bGQgYWx3YXlzIGJlIFwid2luMzJcIiAodGhlIGxhc3QgdmFsdWUgb2YgUGxhdGZvcm1OYW1lcykuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZGVmYXVsdFwiID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGRlZmF1bHQgc2hlbGwsIHRoZSB2YWx1ZSBzaG91bGQgYmUgdW5zZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzaGVsbHNbX3BsYXRmb3JtX2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgY2FzZTogYXNzaWduIHRoZSBzaGVsbCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxzW19wbGF0Zm9ybV9pZF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfX0pKHBsYXRmb3JtX2lkKSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxufSIsImltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtBcHB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbXN9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW19IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcbmltcG9ydCB7UGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogSHVtYW4gcmVhZGFibGUgbmFtZSwgdXNlZCBpbiBzZXR0aW5ncy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYWNjZXB0ZWRfb3V0cHV0X3N0cmVhbXM6IE91dHB1dFN0cmVhbVtdID0gW1wic3Rkb3V0XCIsIFwic3RkZXJyXCJdO1xyXG5cclxuICAgIHByb3RlY3RlZCBwbHVnaW46IFNDX1BsdWdpbjtcclxuICAgIHByb3RlY3RlZCBhcHA6IEFwcDtcclxuICAgIHByb3RlY3RlZCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0O1xyXG4gICAgcHJvdGVjdGVkIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZDtcclxuICAgIHByb3RlY3RlZCBhY2NlcHRzX2VtcHR5X291dHB1dCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG92ZXJyaWRkZW4gaW4gY2hpbGQgY2xhc3NlcyBpbiBvcmRlciB0byB2YXJ5IHRoZSB0aXRsZSBkZXBlbmRpbmcgb24gb3V0cHV0X3N0cmVhbS5cclxuICAgICAqIEBwYXJhbSBvdXRwdXRfc3RyZWFtXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaXRsZShvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZShwbHVnaW46IFNDX1BsdWdpbiwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xyXG4gICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kID0gdF9zaGVsbF9jb21tYW5kO1xyXG4gICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCA9IHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IF9oYW5kbGUob3V0cHV0OiBPdXRwdXRTdHJlYW1zLCBlcnJvcl9jb2RlOiBudW1iZXIgfCBudWxsKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgaGFuZGxlKG91dHB1dDogT3V0cHV0U3RyZWFtcywgZXJyb3JfY29kZTogbnVtYmVyIHwgbnVsbCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFF1YWxpZnkgb3V0cHV0XHJcbiAgICAgICAgaWYgKE91dHB1dENoYW5uZWxEcml2ZXIuaXNPdXRwdXRFbXB0eShvdXRwdXQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgaXMgZW1wdHlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2VwdHNfZW1wdHlfb3V0cHV0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIE91dHB1dENoYW5uZWxEcml2ZXIgZG9lcyBub3QgYWNjZXB0IGVtcHR5IG91dHB1dCwgaS5lLiBlbXB0eSBvdXRwdXQgc2hvdWxkIGJlIGp1c3QgaWdub3JlZC5cclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiOiBJZ25vcmluZyBlbXB0eSBvdXRwdXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYnVnTG9nKHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiOiBIYW5kbGluZyBvdXRwdXQuLi5cIik7XHJcblxyXG4gICAgICAgIC8vIE91dHB1dCBpcyBvay5cclxuICAgICAgICAvLyBIYW5kbGUgaXQuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlKG91dHB1dCwgZXJyb3JfY29kZSk7XHJcbiAgICAgICAgZGVidWdMb2coXCJPdXRwdXQgaGFuZGxpbmcgaXMgZG9uZS5cIilcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWNjZXB0c091dHB1dFN0cmVhbShvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY2NlcHRlZF9vdXRwdXRfc3RyZWFtcy5jb250YWlucyhvdXRwdXRfc3RyZWFtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBtb3ZlZCB0byBhIGdsb2JhbCBmdW5jdGlvbiBpc091dHB1dFN0cmVhbUVtcHR5KCkgaWYgbmVlZGVkLlxyXG4gICAgICogQHBhcmFtIG91dHB1dFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNPdXRwdXRFbXB0eShvdXRwdXQ6IE91dHB1dFN0cmVhbXMpIHtcclxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBvdXRwdXQuc3RkZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCA9PT0gb3V0cHV0LnN0ZG91dCB8fCBcIlwiID09PSBvdXRwdXQuc3Rkb3V0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtc30gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX05vdGlmaWNhdGlvbiBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOb3QgdXNlZCBiZWNhdXNlIGdldFRpdGxlKCkgZXhpc3RzLCBidXQgbXVzdCBiZSBwcmVzZW50LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgZ2V0VGl0bGUob3V0cHV0X3N0cmVhbTogT3V0cHV0U3RyZWFtKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKG91dHB1dF9zdHJlYW0pIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZG91dFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm90aWZpY2F0aW9uIGJhbGxvb25cIjtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZGVyclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3IgYmFsbG9vblwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX2hhbmRsZShvdXRwdXQ6IE91dHB1dFN0cmVhbXMsIGVycm9yX2NvZGU6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSBvdXRwdXQgc3RyZWFtcy5cclxuICAgICAgICAvLyBUaGVyZSBjYW4gYmUgYm90aCBcInN0ZG91dFwiIGFuZCBcInN0ZGVyclwiIHByZXNlbnQgYXQgdGhlIHNhbWUgdGltZSwgb3IganVzdCBvbmUgb2YgdGhlbS4gSWYgYm90aCBhcmUgcHJlc2VudCwgdHdvXHJcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgIGZvciAob3V0cHV0X3N0cmVhbV9uYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXRfbWVzc2FnZSA9IG91dHB1dFtvdXRwdXRfc3RyZWFtX25hbWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG91dHB1dF9zdHJlYW1fbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN0ZG91dFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBvdXRwdXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24ob3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN0ZGVyclwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiW1wiICsgZXJyb3JfY29kZSArIFwiXTogXCIgKyBvdXRwdXRfbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJ9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJcIjtcclxuaW1wb3J0IHtnZXRFZGl0b3IsIGdldFZpZXcsIGpvaW5PYmplY3RQcm9wZXJ0aWVzfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtc30gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQge0VkaXRvcn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2hhbmRsZShvdXRwdXQ6IE91dHB1dFN0cmVhbXMpIHtcclxuICAgICAgICBjb25zdCBlZGl0b3IgPSBnZXRFZGl0b3IodGhpcy5hcHApO1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRWaWV3KHRoaXMuYXBwKTtcclxuXHJcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIGJvdGggXCJzdGRvdXRcIiBhbmQgXCJzdGRlcnJcIiBwcmVzZW50IGF0IHRoZSBzYW1lIHRpbWUsIG9yIGp1c3Qgb25lIG9mIHRoZW0uIElmIGJvdGggYXJlIHByZXNlbnQsIHRoZXlcclxuICAgICAgICAvLyB3aWxsIGJlIGpvaW5lZCB0b2dldGhlciB3aXRoIFwiIFwiIGFzIGEgc2VwYXJhdG9yLlxyXG4gICAgICAgIGNvbnN0IG91dHB1dF9tZXNzYWdlID0gam9pbk9iamVjdFByb3BlcnRpZXMob3V0cHV0LCBcIiBcIik7XHJcblxyXG4gICAgICAgIGlmIChudWxsID09PSBlZGl0b3IpIHtcclxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGdldCBhbiBlZGl0b3IuXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiQ291bGQgbm90IGdldCBhbiBlZGl0b3IgaW5zdGFuY2UhIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBpbiBHaXRIdWIuIFRoZSBjb21tYW5kIG91dHB1dCBpcyBpbiB0aGUgbmV4dCBlcnJvciBib3g6XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihvdXRwdXRfbWVzc2FnZSk7IC8vIEdvb2QgdG8gb3V0cHV0IGl0IGF0IGxlYXN0IHNvbWUgd2F5LlxyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIk91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGU6IENvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlLlwiKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBpbiBzb3VyY2UgbW9kZVxyXG4gICAgICAgIGlmIChudWxsID09PSB2aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBpdCdzIG5vdCBwb3NzaWJsZSB0byBnZXQgYW4gZWRpdG9yLCBidXQgaXQncyBub3QgYSBiaWcgcHJvYmxlbS5cclxuICAgICAgICAgICAgZGVidWdMb2coXCJPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlOiBDb3VsZCBub3QgZ2V0IGEgdmlldyBpbnN0YW5jZS5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2UgZG8gaGF2ZSBhIHZpZXdcclxuICAgICAgICAgICAgaWYgKFwic291cmNlXCIgIT09IHZpZXcuZ2V0TW9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXYXJuIHRoYXQgdGhlIG91dHB1dCBtaWdodCBnbyB0byBhbiB1bmV4cGVjdGVkIHBsYWNlIGluIHRoZSBub3RlIGZpbGUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdOb3RpZmljYXRpb24oXCJOb3RlIHRoYXQgeW91ciBhY3RpdmUgbm90ZSBpcyBub3QgaW4gJ0VkaXQnIG1vZGUhIFRoZSBvdXRwdXQgY29tZXMgdmlzaWJsZSB3aGVuIHlvdSBzd2l0Y2ggdG8gJ0VkaXQnIG1vZGUgYWdhaW4hXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgY3VycmVudCBmaWxlXHJcbiAgICAgICAgdGhpcy5pbnNlcnRJbnRvRWRpdG9yKGVkaXRvciwgb3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbnNlcnRJbnRvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBvdXRwdXRfbWVzc2FnZTogc3RyaW5nKTogdm9pZDtcclxufSIsImltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVwiO1xyXG5pbXBvcnQge0VkaXRvcn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUNhcmV0IGV4dGVuZHMgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZSB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGUgPSBcIkN1cnJlbnQgZmlsZTogY2FyZXQgcG9zaXRpb25cIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgdGV4dCBpbnRvIHRoZSBnaXZlbiBlZGl0b3IsIGF0IGNhcmV0IHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0b3JcclxuICAgICAqIEBwYXJhbSBvdXRwdXRfbWVzc2FnZVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zZXJ0SW50b0VkaXRvcihlZGl0b3I6IEVkaXRvciwgb3V0cHV0X21lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKG91dHB1dF9tZXNzYWdlKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVwiO1xyXG5pbXBvcnQge0VkaXRvcn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVRvcCBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUge1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHRpdGxlID0gXCJDdXJyZW50IGZpbGU6IHRvcFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGludG8gdGhlIGdpdmVuIGVkaXRvciwgYXQgdG9wLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0b3JcclxuICAgICAqIEBwYXJhbSBvdXRwdXRfbWVzc2FnZVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zZXJ0SW50b0VkaXRvcihlZGl0b3I6IEVkaXRvciwgb3V0cHV0X21lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHRvcF9wb3NpdGlvbiA9IGVkaXRvci5vZmZzZXRUb1BvcygwKTtcclxuICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKG91dHB1dF9tZXNzYWdlLCB0b3BfcG9zaXRpb24pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtc30gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQge2pvaW5PYmplY3RQcm9wZXJ0aWVzfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7RU9MfSBmcm9tIFwib3NcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX1N0YXR1c0JhciBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXIge1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHRpdGxlID0gXCJTdGF0dXMgYmFyXCI7XHJcbiAgICBwcm90ZWN0ZWQgYWNjZXB0c19lbXB0eV9vdXRwdXQgPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdHVzX2Jhcl9lbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBwdWJsaWMgX2hhbmRsZShvdXRwdXQ6IE91dHB1dFN0cmVhbXMpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXNfYmFyX2VsZW1lbnQgPSB0aGlzLmdldFN0YXR1c0JhckVsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgLy8gQ29tYmluZSBzdGRvdXQgYW5kIHN0ZGVyciAoaW4gY2FzZSBib3RoIG9mIHRoZW0gaGFwcGVuIHRvIGJlIHByZXNlbnQpLlxyXG4gICAgICAgIGNvbnN0IHN0ZG91dF9hbmRfc3RkZXJyID0gam9pbk9iamVjdFByb3BlcnRpZXMob3V0cHV0LCBFT0wgKyBFT0wpLnRyaW0oKTsgLy8gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgJ291dHB1dCcgaXMgYW4gZW1wdHkgb2JqZWN0IChpLmUuIG5vICdzdGRvdXQnIG5vciAnc3RkZXJyJykuXHJcblxyXG4gICAgICAgIC8vIEZ1bGwgb3V0cHV0IChzaG93biB3aGVuIGhvdmVyaW5nIHdpdGggbW91c2UpXHJcbiAgICAgICAgc3RhdHVzX2Jhcl9lbGVtZW50LnNldEF0dHIoXCJhcmlhLWxhYmVsXCIsIHN0ZG91dF9hbmRfc3RkZXJyKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBsYXN0IGxpbmUgcGVybWFuZW50bHkuXHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X21lc3NhZ2VfbGluZXMgPSBzdGRvdXRfYW5kX3N0ZGVyci5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pO1xyXG4gICAgICAgIGNvbnN0IGxhc3Rfb3V0cHV0X2xpbmUgPSBvdXRwdXRfbWVzc2FnZV9saW5lc1tvdXRwdXRfbWVzc2FnZV9saW5lcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBzdGF0dXNfYmFyX2VsZW1lbnQuc2V0VGV4dChsYXN0X291dHB1dF9saW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFN0YXR1c0JhckVsZW1lbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c19iYXJfZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c19iYXJfZWxlbWVudCA9IHRoaXMucGx1Z2luLmFkZFN0YXR1c0Jhckl0ZW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzX2Jhcl9lbGVtZW50O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlXCI7XHJcbmltcG9ydCB7RWRpdG9yLCBFZGl0b3JQb3NpdGlvbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUJvdHRvbSBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUge1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHRpdGxlID0gXCJDdXJyZW50IGZpbGU6IGJvdHRvbVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGludG8gdGhlIGdpdmVuIGVkaXRvciwgYXQgYm90dG9tLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0b3JcclxuICAgICAqIEBwYXJhbSBvdXRwdXRfbWVzc2FnZVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zZXJ0SW50b0VkaXRvcihlZGl0b3I6IEVkaXRvciwgb3V0cHV0X21lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbV9wb3NpdGlvbjogRWRpdG9yUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIGNoOiBlZGl0b3IuZ2V0TGluZShlZGl0b3IubGFzdExpbmUoKSkubGVuZ3RoLCAgIC8vIFRoZSBsYXN0IGNoYXJhY3Rlciogb2YgLi4uXHJcbiAgICAgICAgICAgIGxpbmU6IGVkaXRvci5sYXN0TGluZSgpLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiB0aGUgbGFzdCBsaW5lLlxyXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqKSBCdXQgZG8gbm90IHN1YnRyYWN0IDEsIGJlY2F1c2UgY2ggaXMgemVyby1iYXNlZCwgc28gd2hlbiAubGVuZ3RoIGlzIHVzZWQgd2l0aG91dCAtMSwgd2UgYXJlIHBvaW50aW5nIEFGVEVSIHRoZSBsYXN0IGNoYXJhY3Rlci5cclxuICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKG91dHB1dF9tZXNzYWdlLCBib3R0b21fcG9zaXRpb24pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7am9pbk9iamVjdFByb3BlcnRpZXN9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbi8vIEB0cy1pZ25vcmUgXCJlbGVjdHJvblwiIGlzIGluc3RhbGxlZC5cclxuaW1wb3J0IHtjbGlwYm9hcmR9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmQgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB0aXRsZSA9IFwiQ2xpcGJvYXJkXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9oYW5kbGUob3V0cHV0OiBPdXRwdXRTdHJlYW1zKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIGJvdGggXCJzdGRvdXRcIiBhbmQgXCJzdGRlcnJcIiBwcmVzZW50IGF0IHRoZSBzYW1lIHRpbWUsIG9yIGp1c3Qgb25lIG9mIHRoZW0uIElmIGJvdGggYXJlIHByZXNlbnQsIHRoZXlcclxuICAgICAgICAvLyB3aWxsIGJlIGpvaW5lZCB0b2dldGhlciB3aXRoIFwiIFwiIGFzIGEgc2VwYXJhdG9yLlxyXG4gICAgICAgIGNvbnN0IG91dHB1dF9tZXNzYWdlID0gam9pbk9iamVjdFByb3BlcnRpZXMob3V0cHV0LCBcIiBcIik7XHJcbiAgICAgICAgY2xpcGJvYXJkLndyaXRlVGV4dChvdXRwdXRfbWVzc2FnZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vdXRwdXRfY2hhbm5lbF9jbGlwYm9hcmRfYWxzb19vdXRwdXRzX3RvX25vdGlmaWNhdGlvbikge1xyXG4gICAgICAgICAgICAvLyBOb3RpZnkgdGhlIHVzZXIgc28gdGhleSBrbm93IGEpIHdoYXQgd2FzIGNvcGllZCB0byBjbGlwYm9hcmQsIGFuZCBiKSB0aGF0IHRoZWlyIGNvbW1hbmQgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbi5cclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3Tm90aWZpY2F0aW9uKFwiQ29waWVkIHRvIGNsaXBib2FyZDogXCIgKyBFT0wgKyBvdXRwdXRfbWVzc2FnZSArIEVPTCArIEVPTCArIFwiKE5vdGlmaWNhdGlvbiBjYW4gYmUgdHVybmVkIG9mZiBpbiBzZXR0aW5ncy4pXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcn0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbERyaXZlcnMsXHJcbiAgICBPdXRwdXRTdHJlYW1zLFxyXG59IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtNb2RhbCwgU2V0dGluZywgVGV4dEFyZWFDb21wb25lbnR9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWwsIE91dHB1dFN0cmVhbX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7UGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtnZXRTZWxlY3Rpb25Gcm9tVGV4dGFyZWF9IGZyb20gXCIuLi9Db21tb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX01vZGFsIGV4dGVuZHMgT3V0cHV0Q2hhbm5lbERyaXZlciB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGUgPSBcIkFzayBhZnRlciBleGVjdXRpb25cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2hhbmRsZShvdXRwdXRzOiBPdXRwdXRTdHJlYW1zLCBlcnJvcl9jb2RlOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhIG1vZGFsIGFuZCBwYXNzIG91dHB1dHNcclxuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBPdXRwdXRNb2RhbCh0aGlzLnBsdWdpbiwgb3V0cHV0cywgdGhpcy50X3NoZWxsX2NvbW1hbmQsIHRoaXMuc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBhIHBvc3NpYmxlIGVycm9yIGNvZGUgdG8gYmUgc2hvd24gb24gdGhlIG1vZGFsLlxyXG4gICAgICAgIGlmIChlcnJvcl9jb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vZGFsLnNldEV4aXRDb2RlKGVycm9yX2NvZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9uZVxyXG4gICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE91dHB1dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGx1Z2luOiBTQ19QbHVnaW47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dFN0cmVhbXM7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZDtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdDtcclxuICAgIHByaXZhdGUgZXhpdF9jb2RlOiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogU0NfUGx1Z2luLCBvdXRwdXRzOiBPdXRwdXRTdHJlYW1zLCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQsIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQ6IFBhcnNpbmdSZXN1bHQpIHtcclxuICAgICAgICBzdXBlcihwbHVnaW4uYXBwKTtcclxuXHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCA9IHRfc2hlbGxfY29tbWFuZDtcclxuICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQgPSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgdGhlIG1vZGFsIHNjcm9sbGFibGUgaWYgaXQgaGFzIG1vcmUgY29udGVudCB0aGFuIHdoYXQgZml0cyBpbiB0aGUgc2NyZWVuLlxyXG4gICAgICAgIHRoaXMubW9kYWxFbC5hZGRDbGFzcyhcIlNDLXNjcm9sbGFibGVcIik7IC8vIFRPRE86IE1heWJlIG1ha2UgYSBjb21tb24gcGFyZW50IGNsYXNzIGZvciBhbGwgU0MncyBtb2RhbHMgYW5kIGRvIHRoaXMgdGhlcmU/XHJcblxyXG4gICAgICAgIC8vIEhlYWRpbmdcclxuICAgICAgICBjb25zdCBoZWFkaW5nID0gdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LmFsaWFzO1xyXG4gICAgICAgIHRoaXMudGl0bGVFbC5pbm5lclRleHQgPSBoZWFkaW5nID8gaGVhZGluZyA6IFwiU2hlbGwgY29tbWFuZCBvdXRwdXRcIjtcclxuXHJcbiAgICAgICAgLy8gU2hlbGwgY29tbWFuZCBwcmV2aWV3XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicHJlXCIsIHt0ZXh0OiB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQuc2hlbGxfY29tbWFuZCwgYXR0cjoge2NsYXNzOiBcIlNDLW5vLW1hcmdpblwifX0pOyAvLyBubyBtYXJnaW4gc28gdGhhdCBleGl0IGNvZGUgd2lsbCBiZSBjbG9zZS5cclxuXHJcbiAgICAgICAgLy8gRXhpdCBjb2RlXHJcbiAgICAgICAgaWYgKHRoaXMuZXhpdF9jb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVFbChcInNtYWxsXCIsIHt0ZXh0OiBcIkV4aXQgY29kZTogXCIgKyB0aGlzLmV4aXRfY29kZX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3V0cHV0c1xyXG4gICAgICAgIGxldCBpc19maXJzdCA9IHRydWU7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5vdXRwdXRzKS5mb3JFYWNoKChvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0X3NldHRpbmcgPSB0aGlzLmNyZWF0ZU91dHB1dEZpZWxkKG91dHB1dF9zdHJlYW0sIHRoaXMub3V0cHV0c1tvdXRwdXRfc3RyZWFtXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgZmlyc3Qgb3V0cHV0IGZpZWxkXHJcbiAgICAgICAgICAgIGlmIChpc19maXJzdCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0X3NldHRpbmcuY29udHJvbEVsLmZpbmQoXCJ0ZXh0YXJlYVwiKS5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaXNfZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBIHRpcCBhYm91dCBzZWxlY3RpbmcgdGV4dC5cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRGl2KHtcclxuICAgICAgICAgICAgdGV4dDogXCJUaXAhIElmIHlvdSBzZWxlY3Qgc29tZXRoaW5nLCBvbmx5IHRoZSBzZWxlY3RlZCB0ZXh0IHdpbGwgYmUgdXNlZC5cIixcclxuICAgICAgICAgICAgYXR0cjoge2NsYXNzOiBcInNldHRpbmctaXRlbS1kZXNjcmlwdGlvblwiIC8qIEEgQ1NTIGNsYXNzIGRlZmluZWQgYnkgT2JzaWRpYW4uICovfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZU91dHB1dEZpZWxkKG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSwgb3V0cHV0OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgb3V0cHV0X3RleHRhcmVhOiBUZXh0QXJlYUNvbXBvbmVudDtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiaHJcIiwge2F0dHI6IHtjbGFzczogXCJTQy1uby1tYXJnaW5cIn19KTtcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IHN0cmVhbSBuYW1lXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShvdXRwdXRfc3RyZWFtKVxyXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpXHJcbiAgICAgICAgICAgIC5zZXRDbGFzcyhcIlNDLW5vLWJvdHRvbS1ib3JkZXJcIilcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFRleHRhcmVhXHJcbiAgICAgICAgY29uc3QgdGV4dGFyZWFfc2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMubW9kYWxFbClcclxuICAgICAgICAgICAgLmFkZFRleHRBcmVhKHRleHRhcmVhID0+IG91dHB1dF90ZXh0YXJlYSA9IHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUob3V0cHV0KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgICAgIHRleHRhcmVhX3NldHRpbmcuaW5mb0VsLmFkZENsYXNzKFwiU0MtaGlkZVwiKTsgLy8gTWFrZSByb29tIGZvciB0aGUgdGV4dGFyZWEgYnkgaGlkaW5nIHRoZSBsZWZ0IGNvbHVtbi5cclxuICAgICAgICB0ZXh0YXJlYV9zZXR0aW5nLnNldHRpbmdFbC5hZGRDbGFzcyhcIlNDLW91dHB1dC1jaGFubmVsLW1vZGFsLXRleHRhcmVhLWNvbnRhaW5lclwiLCBcIlNDLW5vLXRvcC1ib3JkZXJcIik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBjb250cm9scyBmb3IgcmVkaXJlY3RpbmcgdGhlIG91dHB1dCB0byBhbm90aGVyIGNoYW5uZWwuXHJcbiAgICAgICAgY29uc3QgcmVkaXJlY3Rfc2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMubW9kYWxFbClcclxuICAgICAgICAgICAgLnNldERlc2MoXCJSZWRpcmVjdDpcIilcclxuICAgICAgICAgICAgLnNldENsYXNzKFwiU0Mtbm8tdG9wLWJvcmRlclwiKVxyXG4gICAgICAgIDtcclxuICAgICAgICBjb25zdCBleGNsdWRlZF9vdXRwdXRfY2hhbm5lbHM6IE91dHB1dENoYW5uZWxbXSA9IFtcclxuICAgICAgICAgICAgXCJub3RpZmljYXRpb25cIiwgLy8gV291bGQgbm90IG1ha2Ugc2Vuc2UgdG8gY3JlYXRlIGEgdGVtcG9yYXJ5IGJhbGxvb24gZm9yIHRleHQgdGhhdCBpcyBhbHJlYWR5IHZpc2libGUuXHJcbiAgICAgICAgICAgIFwibW9kYWxcIiwgICAgICAgIC8vIFdvdWxkIG5vdCBtYWtlIHNlbnNlIHRvIG9wZW4gYSBuZXcgbW9kYWwgZm9yIHRoZSBzYW1lIHRoaW5nLlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X2NoYW5uZWxfZHJpdmVycyA9IGdldE91dHB1dENoYW5uZWxEcml2ZXJzKCk7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3V0cHV0X2NoYW5uZWxfZHJpdmVycykuZm9yRWFjaCgob3V0cHV0X2NoYW5uZWxfbmFtZTogT3V0cHV0Q2hhbm5lbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBjaGFubmVsIGlzIG5vdCBleGNsdWRlZFxyXG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVkX291dHB1dF9jaGFubmVscy5jb250YWlucyhvdXRwdXRfY2hhbm5lbF9uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0X2NoYW5uZWxfZHJpdmVyID0gb3V0cHV0X2NoYW5uZWxfZHJpdmVyc1tvdXRwdXRfY2hhbm5lbF9uYW1lXTtcclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgb3V0cHV0IGNoYW5uZWwgYWNjZXB0cyB0aGlzIG91dHB1dCBzdHJlYW0uIEUuZy4gT3V0cHV0Q2hhbm5lbERyaXZlcl9PcGVuRmlsZXMgZG9lcyBub3QgYWNjZXB0IFwic3RkZXJyXCIuXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0X2NoYW5uZWxfZHJpdmVyLmFjY2VwdHNPdXRwdXRTdHJlYW0ob3V0cHV0X3N0cmVhbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdF9zZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KG91dHB1dF9jaGFubmVsX2RyaXZlci5nZXRUaXRsZShvdXRwdXRfc3RyZWFtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Qgb3V0cHV0IHRvIHRoZSBzZWxlY3RlZCBkcml2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dF9zdHJlYW1zOiBPdXRwdXRTdHJlYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0YXJlYV9lbGVtZW50ID0gdGV4dGFyZWFfc2V0dGluZy5zZXR0aW5nRWwuZmluZChcInRleHRhcmVhXCIpIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfc3RyZWFtc1tvdXRwdXRfc3RyZWFtXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2VsZWN0aW9uRnJvbVRleHRhcmVhKHRleHRhcmVhX2VsZW1lbnQsIHRydWUpIC8vIFVzZSB0aGUgc2VsZWN0aW9uLCBvci4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8/IG91dHB1dF90ZXh0YXJlYS5nZXRWYWx1ZSgpIC8vIC4uLnVzZSB0aGUgd2hvbGUgdGV4dCwgaWYgbm90aGluZyBpcyBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9jaGFubmVsX2RyaXZlci5pbml0aWFsaXplKHRoaXMucGx1Z2luLCB0aGlzLnRfc2hlbGxfY29tbWFuZCwgdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9jaGFubmVsX2RyaXZlci5oYW5kbGUob3V0cHV0X3N0cmVhbXMsIHRoaXMuZXhpdF9jb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhX2VsZW1lbnQuZm9jdXMoKTsgLy8gQnJpbmcgdGhlIGZvY3VzIGJhY2sgdG8gdGhlIHRleHRhcmVhIGluIG9yZGVyIHRvIHNob3cgYSBwb3NzaWJsZSBoaWdobGlnaHQgKD1zZWxlY3Rpb24pIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0YXJlYV9zZXR0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCBvbmx5IGlmIGFuIGV4aXQgY29kZSB3YXMgcmVjZWl2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV4aXRfY29kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RXhpdENvZGUoZXhpdF9jb2RlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmV4aXRfY29kZSA9IGV4aXRfY29kZTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJ9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJcIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsXCI7XHJcbmltcG9ydCB7XHJcbiAgICBFZGl0b3JTZWxlY3Rpb25PckNhcmV0LFxyXG4gICAgbm9ybWFsaXplUGF0aCxcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuICAgIGdldEVkaXRvcixcclxuICAgIGdldFZhdWx0QWJzb2x1dGVQYXRoLFxyXG4gICAgaXNJbnRlZ2VyLFxyXG4gICAgaXNXaW5kb3dzLFxyXG4gICAgcHJlcGFyZUVkaXRvclBvc2l0aW9uLFxyXG59IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9PcGVuRmlsZXMgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB0aXRsZSA9IFwiT3BlbiBhIGZpbGVcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgb3V0cHV0IGNoYW5uZWwgaXMgbm90IHN1aXRhYmxlIGZvciBzdGRlcnIsIGFzIHN0ZGVyciBjYW4gY29udGFpbiB1bmV4cGVjdGVkIG1lc3NhZ2VzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYWNjZXB0ZWRfb3V0cHV0X3N0cmVhbXM6IE91dHB1dFN0cmVhbVtdID0gW1wic3Rkb3V0XCJdO1xyXG5cclxuICAgIHByb3RlY3RlZCBfaGFuZGxlKG91dHB1dDogT3V0cHV0U3RyZWFtcywgZXJyb3JfY29kZTogbnVtYmVyIHwgbnVsbCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBvdXRwdXRfc3RyZWFtX25hbWU6IE91dHB1dFN0cmVhbTtcclxuICAgICAgICBmb3IgKG91dHB1dF9zdHJlYW1fbmFtZSBpbiBvdXRwdXQpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHBhcnRzIHRoYXQgZGVmaW5lIGRpZmZlcmVudCBkZXRhaWxzIGFib3V0IGhvdyB0aGUgZmlsZSBzaG91bGQgYmUgb3BlbmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVfZGVmaW5pdGlvbiA9IG91dHB1dFtvdXRwdXRfc3RyZWFtX25hbWVdLnRyaW0oKTsgLy8gQ29udGFpbnMgYXQgbGVhc3QgYSBmaWxlIG5hbWUsIGFuZCBNQVlCRTogYSBjYXJldCBwb3NpdGlvbiwgbmV3IHBhbmUgb3B0aW9uLCBhbmQgdmlldyBzdGF0ZVxyXG4gICAgICAgICAgICBjb25zdCBmaWxlX2RlZmluaXRpb25fcGFydHMgPSBmaWxlX2RlZmluaXRpb24uc3BsaXQoXCI6XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gRnV0dXJlIGNvbXBhdGliaWxpdHk6IEVuc3VyZSB0aGVyZSBpcyBubyBuZXdsaW5lIGNoYXJhY3RlcnMgaW4tYmV0d2VlbiB0aGUgb3V0cHV0LlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHJlc2VydmUgbmV3bGluZSB1c2FnZSB0byBmdXR1cmUgd2hlbiB0aGlzIG91dHB1dCBjaGFubmVsIHdpbGwgc3VwcG9ydCBvcGVuaW5nIG11bHRpcGxlIGZpbGVzIGF0IG9uY2UuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gbXVsdGktZmlsZSBzdXBwb3J0IGlzIGltcGxlbWVudGVkLlxyXG4gICAgICAgICAgICBpZiAoZmlsZV9kZWZpbml0aW9uLm1hdGNoKC9bXFxyXFxuXS8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCYWQsIHRoZSBvdXRwdXQgY29udGFpbnMgYSBuZXdsaW5lLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3JzKFtcclxuICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCBvcGVuIGZpbGU6IFRoZSBvdXRwdXQgY29udGFpbnMgbGluZWJyZWFrczogXCIgKyBmaWxlX2RlZmluaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJMaW5lYnJlYWtzIHdpbGwgYmUgc3VwcG9ydGVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgU0MgdGhhdCBhbGxvd3MgZGVmaW5pbmcgbXVsdGlwbGUgZmlsZXMgdG8gb3BlbiBhdCBvbmNlLlwiLFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGFsd2F5cyB0aGUgZmlsZSBwYXRoXHJcbiAgICAgICAgICAgIGxldCBvcGVuX2ZpbGVfcGF0aCA9IGZpbGVfZGVmaW5pdGlvbl9wYXJ0cy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gT24gV2luZG93czogQ2hlY2sgaWYgYW4gYWJzb2x1dGUgcGF0aCB3YXMgc3BsaXQgaW5jb3JyZWN0bHkuIChFLmcuIGEgcGF0aCBzdGFydGluZyB3aXRoIFwiQzpcXC4uLlwiKS5cclxuICAgICAgICAgICAgaWYgKGlzV2luZG93cygpICYmIGZpbGVfZGVmaW5pdGlvbl9wYXJ0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZF9wYXRoID0gb3Blbl9maWxlX3BhdGggKyBcIjpcIiArIGZpbGVfZGVmaW5pdGlvbl9wYXJ0c1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUoY29tYmluZWRfcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBZZXMsIHRoZSBmaXJzdCB0d28gcGFydHMgZG8gZm9ybSBhbiBhYnNvbHV0ZSBwYXRoIHRvZ2V0aGVyLCBzbyB0aGV5IHNob3VsZCBub3QgYmUgc3BsaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbl9maWxlX3BhdGggPSBjb21iaW5lZF9wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfZGVmaW5pdGlvbl9wYXJ0cy5zaGlmdCgpOyAvLyBSZW1vdmUgdGhlIHNlY29uZCBwYXJ0IHNvIHRoYXQgaXQgd29uJ3QgYmUgYWNjaWRlbnRhbGx5IHByb2Nlc3NlZCBpbiB0aGUgJ1NwZWNpYWwgZmVhdHVyZXMnIHBhcnQuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRyaW0gdGhlIGZpbGUgcGF0aCwgZm9yIGJlaW5nIGFibGUgdG8gdXNlIGNsZWFuZXIgc2VwYXJhdGlvbiBiZXR3ZWVuIGZpbGUgbmFtZSBhbmQgb3RoZXIgcGFydHMsIGUuZzogTXlGaWxlLm1kIDogbmV3LXBhbmVcclxuICAgICAgICAgICAgb3Blbl9maWxlX3BhdGggPSBvcGVuX2ZpbGVfcGF0aC50cmltKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGZlYXR1cmVzXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0X3BhcnRzOiBudW1iZXJbXSA9IFtdOyAvLyBJZiBjYXJldCBwb3NpdGlvbiBpcyBwcmVzZW50IGluIGZpbGVfZGVmaW5pdGlvbl9wYXJ0cywgdGhlIGZpcnN0IGl0ZW0gaW4gdGhpcyBhcnJheSB3aWxsIGJlIHRoZSBjYXJldCBsaW5lLCB0aGUgc2Vjb25kIHdpbGwgYmUgdGhlIGNvbHVtbi4gSWYgbW9yZSBwYXJ0cyBhcmUgcHJlc2VudCwgdGhleSB3aWxsIGJlIHVzZWQgZm9yIG1ha2luZyBzZWxlY3Rpb25zLlxyXG4gICAgICAgICAgICBsZXQgbmV3X3BhbmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGNhbl9jcmVhdGVfZmlsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgZmlsZV9kZWZpbml0aW9uX2ludGVycHJldGluZ19mYWlsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVfZGVmaW5pdGlvbl9wYXJ0cy5mb3JFYWNoKChmaWxlX2RlZmluaXRpb25fcGFydDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmaWxlX2RlZmluaXRpb25fcGFydCA9IGZpbGVfZGVmaW5pdGlvbl9wYXJ0LnRvTG9jYWxlTG93ZXJDYXNlKCkudHJpbSgpOyAvLyAudHJpbSgpIGlzIGZvciBiZWluZyBhYmxlIHRvIHVzZSBjbGVhbmVyIHNlcGFyYXRpb24gYmV0d2VlbiBlLmcuIGRpZmZlcmVudCBzZWxlY3Rpb25zOiBNeUZpbGUubWQ6MToxOjE6LTEgOiA1OjE6NTotMVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgcGFydCB0eXBlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlZ2VyKGZpbGVfZGVmaW5pdGlvbl9wYXJ0LCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBudW1iZXIsIHNvIGNvbnNpZGVyIGl0IGFzIGEgY2FyZXQgcG9zaXRpb24gcGFydC5cclxuICAgICAgICAgICAgICAgICAgICBjYXJldF9wYXJ0cy5wdXNoKHBhcnNlSW50KGZpbGVfZGVmaW5pdGlvbl9wYXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmlsZV9kZWZpbml0aW9uX3BhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5ldy1wYW5lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcGFuZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbi1jcmVhdGUtZmlsZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuX2NyZWF0ZV9maWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJDYW5ub3Qgb3BlbiBmaWxlOiBVbnJlY29nbmlzZWQgZGVmaW5pdGlvbiBwYXJ0OiBcIiArIGZpbGVfZGVmaW5pdGlvbl9wYXJ0ICsgXCIgaW4gXCIgKyBmaWxlX2RlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9kZWZpbml0aW9uX2ludGVycHJldGluZ19mYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlX2RlZmluaXRpb25faW50ZXJwcmV0aW5nX2ZhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHBhdGggaXMgcmVsYXRpdmVcclxuICAgICAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZShvcGVuX2ZpbGVfcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXRoIGlzIGFic29sdXRlLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byByZWxhdGl2ZS5cclxuICAgICAgICAgICAgICAgIGxldCB2YXVsdF9hYnNvbHV0ZV9wYXRoOiBzdHJpbmcgPSBnZXRWYXVsdEFic29sdXRlUGF0aCh0aGlzLmFwcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3Blbl9maWxlX3BhdGgudG9Mb2NhbGVMb3dlckNhc2UoKS5zdGFydHNXaXRoKHZhdWx0X2Fic29sdXRlX3BhdGgudG9Mb2NhbGVMb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0aW5nIHRvIHJlbGF0aXZlIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbl9maWxlX3BhdGggPSBvcGVuX2ZpbGVfcGF0aC5zdWJzdHIodmF1bHRfYWJzb2x1dGVfcGF0aC5sZW5ndGgpOyAvLyBHZXQgZXZlcnl0aGluZyBhZnRlciB0aGUgcG9pbnQgd2hlcmUgdGhlIHZhdWx0IHBhdGggZW5kcy5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IGNvbnZlcnQgdG8gcmVsYXRpdmUsIGJlY2F1c2UgdGhlIGZpbGUgZG9lcyBub3QgcmVzaWRlIGluIHRoZSB2YXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiQ2Fubm90IG9wZW4gZmlsZSAnXCIgKyBvcGVuX2ZpbGVfcGF0aCArIFwiJyBhcyB0aGUgcGF0aCBpcyBvdXRzaWRlIHRoaXMgdmF1bHQuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZmlsZSBwYXRoXHJcbiAgICAgICAgICAgIG9wZW5fZmlsZV9wYXRoID0gbm9ybWFsaXplUGF0aChvcGVuX2ZpbGVfcGF0aCk7IC8vIG5vcm1hbGl6ZVBhdGgoKSBpcyB1c2VkIG9uIHB1cnBvc2UsIGluc3RlYWQgb2Ygbm9ybWFsaXplUGF0aDIoKSwgYmVjYXVzZSBiYWNrc2xhc2hlcyBcXCBzaG91bGQgYmUgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlcyAvXHJcblxyXG4gICAgICAgICAgICB0aGlzLm9wZW5GaWxlSW5UYWIob3Blbl9maWxlX3BhdGgsICBuZXdfcGFuZSwgY2FuX2NyZWF0ZV9maWxlKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGlzIG5vdyBvcGVuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjaywgZGlkIHdlIGhhdmUgYSBjYXJldCBwb3NpdGlvbiBhdmFpbGFibGUuIElmIG5vdCwgZG8gbm90aGluZy5cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudF9jYXJldF9wYXJ0czogbnVtYmVyID0gY2FyZXRfcGFydHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50X2NhcmV0X3BhcnRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFllcywgYSBjYXJldCBwb3NpdGlvbiB3YXMgZGVmaW5lZCBpbiB0aGUgb3V0cHV0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvcnJlY3QgYW1vdW50IG9mIGNhcmV0IHBvc2l0aW9uIHBhcnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDAgcGFydHM6IG5vIGNhcmV0IHBvc2l0aW9uaW5nIG5lZWRzIHRvIGJlIGRvbmUgKGJ1dCBpbiB0aGlzIHBhcnQgb2YgY29kZSB0aGUgYW1vdW50IG9mIHBhcnRzIGlzIGFsd2F5cyBncmVhdGVyIHRoYW4gMCkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMSBwYXJ0OiBjYXJldCBsaW5lIGlzIGRlZmluZWQsIG5vIGNvbHVtbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyAyIHBhcnRzOiBjYXJldCBsaW5lIGFuZCBjb2x1bW4gYXJlIGRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMyBwYXJ0czogTk9UIEFMTE9XRUQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBwYXJ0czogc2VsZWN0aW9uIHN0YXJ0aW5nIHBvc2l0aW9uIChsaW5lLCBjb2x1bW4pIGFuZCBzZWxlY3Rpb24gZW5kIHBvc2l0aW9uIChsaW5lLCBjb2x1bW4pIGFyZSBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDUgcGFydHMgb3IgbW9yZTogTk9UIEFMTE9XRUQuIEV4Y2VwdGlvbjogYW55IG51bWJlciBvZiBzZXRzIG9mIGZvdXIgcGFydHMgaXMgYWxsb3dlZCwgaS5lLiA4IHBhcnRzLCAxMiBwYXJ0cywgMTYgcGFydHMgZXRjLiBhcmUgYWxsb3dlZCBhcyB0aGV5IGNhbiBkZWZpbmUgbXVsdGlwbGUgc2VsZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcl9tZXNzYWdlX2Jhc2U6IHN0cmluZyA9IFwiRmlsZSBvcGVuZWQsIGJ1dCBjYXJldCBjYW5ub3QgYmUgcG9zaXRpb25lZCBkdWUgdG8gYW4gaW5jb3JyZWN0IGFtb3VudCAoXCIgKyBjb3VudF9jYXJldF9wYXJ0cyArIFwiKSBvZiBudW1lcmljIHZhbHVlcyBpbiB0aGUgb3V0cHV0OiBcIiArIGZpbGVfZGVmaW5pdGlvbiArIEVPTCArIEVPTDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRfY2FyZXRfcGFydHMgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnJlY3QgYW1vdW50IG9mIGNhcmV0IHBhcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKGVycm9yX21lc3NhZ2VfYmFzZSArIFwiVGhyZWUgbnVtZXJpYyBwYXJ0cyBpcyBhbiBpbmNvcnJlY3QgYW1vdW50LCBjb3JyZWN0IHdvdWxkIGJlIDEsMiBvciA0IHBhcnRzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfY2FyZXRfcGFydHMgPiA0ICYmIGNvdW50X2NhcmV0X3BhcnRzICUgNCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnJlY3QgYW1vdW50IG9mIGNhcmV0IHBhcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKGVycm9yX21lc3NhZ2VfYmFzZSArIFwiUGVyaGFwcyB0b28gbWFueSBudW1lcmljIHBhcnRzIGFyZSBkZWZpbmVkPyBJZiBtb3JlIHRoYW4gZm91ciBwYXJ0cyBhcmUgZGVmaW5lZCwgbWFrZSBzdXJlIHRvIGRlZmluZSBjb21wbGV0ZSBzZXRzIG9mIGZvdXIgcGFydHMuIFRoZSBhbW91bnQgb2YgbnVtZXJpYyBwYXJ0cyBuZWVkcyB0byBiZSBkaXZpZGFibGUgYnkgNC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSBmaWxlIGlzIGFscmVhZHkgbG9hZGVkLCByZW5kZXJpbmcgaXQgbWF5IHRha2Ugc29tZSB0aW1lLCB0aHVzIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRlbnQgbWF5IGluY3JlYXNlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHJlYXNvbiwgdGhlcmUgbmVlZHMgdG8gYmUgYSB0aW55IGRlbGF5IGJlZm9yZSBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbi4gSWYgdGhlIGNhcmV0IHBvc2l0aW9uIGlzIHNldCBpbW1lZGlhdGVseSxcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2FyZXQgd2lsbCBiZSBwbGFjZWQgaW4gYSBjb3JyZWN0IHBvc2l0aW9uLCBidXQgaXQgbWlnaHQgYmUgdGhhdCB0aGUgZWRpdG9yIGRvZXMgbm90IHNjcm9sbCBpbnRvIGNvcnJlY3QgcG9zaXRpb24sIHNvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcmV0IG1pZ2h0IGJlIG91dCBvZiB0aGUgdmlldywgZXZlbiB3aGVuIGl0J3MgaW4gYSBjb3JyZWN0IHBsYWNlLiAoT2JzaWRpYW4gdmVyc2lvbiAwLjEzLjIzKS5cclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50X2NhcmV0X3BhcnRzID49IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24gbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBzZWxlY3Rpb25zIGRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25PckNhcmV0W10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2FyZXRfcGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21fbGluZSA9IGNhcmV0X3BhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21fY29sdW1uID0gY2FyZXRfcGFydHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9fbGluZSA9IGNhcmV0X3BhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvX2NvbHVtbiA9IGNhcmV0X3BhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I6IHByZXBhcmVFZGl0b3JQb3NpdGlvbihlZGl0b3IsIGZyb21fbGluZSwgZnJvbV9jb2x1bW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZDogcHJlcGFyZUVkaXRvclBvc2l0aW9uKGVkaXRvciwgdG9fbGluZSwgdG9fY29sdW1uKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldFNlbGVjdGlvbnMoc2VsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBjYXJldCBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZXRfbGluZTogbnVtYmVyID0gY2FyZXRfcGFydHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZXRfY29sdW1uOiBudW1iZXIgPSBjYXJldF9wYXJ0c1sxXSA/PyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IocHJlcGFyZUVkaXRvclBvc2l0aW9uKGVkaXRvciwgY2FyZXRfbGluZSwgY2FyZXRfY29sdW1uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApOyAvLyA1MDBtcyBpcyBwcm9iYWJseSBsb25nIGVub3VnaCBldmVuIGlmIGEgbmV3IHRhYiBpcyBvcGVuZWQgKHRha2VzIG1vcmUgdGltZSB0aGFuIG9wZW5pbmcgYSBmaWxlIGludG8gYW4gZXhpc3RpbmcgdGFiKS4gVGhpcyBjYW4gYmUgbWFkZSBpbnRvIGEgc2V0dGluZyBzb21ldGltZS4gSWYgeW91IGNoYW5nZSB0aGlzLCByZW1lbWJlciB0byBjaGFuZ2UgaXQgaW4gdGhlIGRvY3VtZW50YXRpb24sIHRvby5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb3BlbkZpbGVJblRhYihmaWxlX3BhdGg6IHN0cmluZywgbmV3X3BhbmU6IGJvb2xlYW4sIGNhbl9jcmVhdGVfZmlsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaWxlIGV4aXN0cyAob3IgY2FuIGJlIGNyZWF0ZWQpXHJcbiAgICAgICAgY29uc3Qgc291cmNlX3BhdGggPSBcIlwiOyAvLyBUT0RPOiBXaGVuIGFkZGluZyBhbiBvcHRpb24gZm9yIGNyZWF0aW5nIG5ldyBmaWxlcywgcmVhZCB0aGlzIGRvY3VtZW50YXRpb24gZnJvbSBPYnNpZGlhbiBBUEkncyBnZXROZXdGaWxlUGFyZW50KCk6IFwic291cmNlUGF0aCDigJMgVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgb3Blbi9mb2N1c2VkIGZpbGUsIHVzZWQgd2hlbiB0aGUgdXNlciB3YW50cyBuZXcgZmlsZXMgdG8gYmUgY3JlYXRlZCDigJxpbiB0aGUgc2FtZSBmb2xkZXLigJ0uIFVzZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGZpbGUuXCJcclxuICAgICAgICBjb25zdCBmaWxlX2V4aXN0c19vcl9jYW5fYmVfY3JlYXRlZCA9IGNhbl9jcmVhdGVfZmlsZSB8fCBudWxsICE9PSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGZpbGVfcGF0aCwgc291cmNlX3BhdGgpO1xyXG4gICAgICAgIGlmIChmaWxlX2V4aXN0c19vcl9jYW5fYmVfY3JlYXRlZCkge1xyXG4gICAgICAgICAgICAvLyBZZXMsIHRoZSBmaWxlIGV4aXN0cyAob3IgY2FuIGJlIGNyZWF0ZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC53b3Jrc3BhY2Uub3BlbkxpbmtUZXh0KGZpbGVfcGF0aCwgc291cmNlX3BhdGgsIG5ld19wYW5lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObywgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIGFuZCBpdCBtYXkgbm90IGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKFwiQ2Fubm90IG9wZW4gZmlsZSAnXCIgKyBmaWxlX3BhdGggKyBcIicsIGFzIGl0IGRvZXMgbm90IGV4aXN0LiAoSWYgeW91IHdhbnQgdG8gYWxsb3cgZmlsZSBjcmVhdGlvbiwgYWRkIDpjYW4tY3JlYXRlLWZpbGUgdG8gdGhlIHNoZWxsIGNvbW1hbmQgb3V0cHV0LilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4uL3NldHRpbmdzL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJfTm90aWZpY2F0aW9ufSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX05vdGlmaWNhdGlvblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJ9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQ2FyZXR9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVDYXJldFwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVUb3B9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVUb3BcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsLCBPdXRwdXRTdHJlYW19IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX1N0YXR1c0Jhcn0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlcl9TdGF0dXNCYXJcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQm90dG9tfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQm90dG9tXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmR9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ2xpcGJvYXJkXCI7XHJcbmltcG9ydCB7UGFyc2luZ1Jlc3VsdCwgVFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX01vZGFsfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX01vZGFsXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcl9PcGVuRmlsZXN9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfT3BlbkZpbGVzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dFN0cmVhbXMge1xyXG4gICAgc3Rkb3V0Pzogc3RyaW5nO1xyXG4gICAgc3RkZXJyPzogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzOiB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBPdXRwdXRDaGFubmVsRHJpdmVyO1xyXG59ID0ge307XHJcblxyXG4vLyBSZWdpc3RlciBvdXRwdXQgY2hhbm5lbCBkcml2ZXJzXHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbERyaXZlcihcInN0YXR1cy1iYXJcIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfU3RhdHVzQmFyKCkpO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIoXCJub3RpZmljYXRpb25cIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfTm90aWZpY2F0aW9uKCkpO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIoXCJjdXJyZW50LWZpbGUtY2FyZXRcIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVDYXJldCgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwiY3VycmVudC1maWxlLXRvcFwiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVRvcCgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwiY3VycmVudC1maWxlLWJvdHRvbVwiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUJvdHRvbSgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwib3Blbi1maWxlc1wiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9PcGVuRmlsZXMoKSk7XHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbERyaXZlcihcImNsaXBib2FyZFwiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmQoKSk7XHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbERyaXZlcihcIm1vZGFsXCIsIG5ldyBPdXRwdXRDaGFubmVsRHJpdmVyX01vZGFsKCkpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVNoZWxsQ29tbWFuZE91dHB1dChwbHVnaW46IFNDX1BsdWdpbiwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0LCBzdGRvdXQ6IHN0cmluZywgc3RkZXJyOiBzdHJpbmcsIGVycm9yX2NvZGU6IG51bWJlciB8IG51bGwpIHtcclxuICAgIC8vIFRlcm1pbm9sb2d5OiBTdHJlYW0gPSBvdXRwdXRzIHN0cmVhbSBmcm9tIGEgY29tbWFuZCwgY2FuIGJlIFwic3Rkb3V0XCIgb3IgXCJzdGRlcnJcIi4gQ2hhbm5lbCA9IGEgbWV0aG9kIGZvciB0aGlzIGFwcGxpY2F0aW9uIHRvIHByZXNlbnQgdGhlIG91dHB1dCBvdCB1c2VyLCBlLmcuIFwibm90aWZpY2F0aW9uXCIuXHJcblxyXG4gICAgY29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uID0gdF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKTsgLy8gVE9ETzogUmVmYWN0b3IgT3V0cHV0Q2hhbm5lbERyaXZlcnMgdG8gdXNlIFRTaGVsbENvbW1hbmQgaW5zdGVhZCBvZiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3RzIGRpcmVjdGx5LlxyXG5cclxuICAgIC8vIEluc2VydCBzdGRvdXQgYW5kIHN0ZGVyciB0byBhbiBvYmplY3QgaW4gYSBjb3JyZWN0IG9yZGVyXHJcbiAgICBsZXQgb3V0cHV0OiBPdXRwdXRTdHJlYW1zID0ge307XHJcbiAgICBpZiAoc3Rkb3V0Lmxlbmd0aCAmJiBzdGRlcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gQm90aCBzdGRvdXQgYW5kIHN0ZGVyciBoYXZlIGNvbnRlbnRcclxuICAgICAgICAvLyBEZWNpZGUgdGhlIG91dHB1dCBvcmRlciA9PSBGaW5kIG91dCB3aGljaCBkYXRhIHN0cmVhbSBzaG91bGQgYmUgcHJvY2Vzc2VkIGZpcnN0LCBzdGRvdXQgb3Igc3RkZXJyLlxyXG4gICAgICAgIHN3aXRjaCAoc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLm91dHB1dF9jaGFubmVsX29yZGVyKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGRvdXQtZmlyc3RcIjpcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGRvdXQ6IHN0ZG91dCxcclxuICAgICAgICAgICAgICAgICAgICBzdGRlcnI6IHN0ZGVycixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0ZGVyci1maXJzdFwiOlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZGVycjogc3RkZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZG91dDogc3Rkb3V0LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc3Rkb3V0Lmxlbmd0aCkge1xyXG4gICAgICAgIC8vIE9ubHkgc3Rkb3V0IGhhcyBjb250ZW50XHJcbiAgICAgICAgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICBzdGRvdXQ6IHN0ZG91dCxcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChzdGRlcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gT25seSBzdGRlcnIgaGFzIGNvbnRlbnRcclxuICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHN0ZGVycjogc3RkZXJyLFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5laXRoZXIgc3Rkb3V0IG5vciBzdGRlcnIgaGF2ZSBjb250ZW50XHJcbiAgICAgICAgLy8gUHJvdmlkZSBlbXB0eSBvdXRwdXQsIHNvbWUgb3V0cHV0IGNoYW5uZWxzIHdpbGwgcHJvY2VzcyBpdCwgd2hpbGUgb3RoZXIgd2lsbCBqdXN0IGlnbm9yZSBpdC5cclxuICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIFwic3Rkb3V0XCI6IFwiXCIsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG91bGQgc3RkZXJyIGJlIHByb2Nlc3NlZCBzYW1lIHRpbWUgd2l0aCBzdGRvdXQ/XHJcbiAgICBpZiAoc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLm91dHB1dF9jaGFubmVscy5zdGRvdXQgPT09IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHMuc3RkZXJyKSB7XHJcbiAgICAgICAgLy8gU3Rkb3V0IGFuZCBzdGRlcnIgdXNlIHRoZSBzYW1lIGNoYW5uZWwuXHJcbiAgICAgICAgLy8gTWFrZSBvbmUgaGFuZGxpbmcgY2FsbC5cclxuICAgICAgICBoYW5kbGVfc3RyZWFtKFxyXG4gICAgICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCxcclxuICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLm91dHB1dF9jaGFubmVscy5zdGRvdXQsXHJcbiAgICAgICAgICAgIG91dHB1dCxcclxuICAgICAgICAgICAgZXJyb3JfY29kZSxcclxuICAgICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBTdGRvdXQgYW5kIHN0ZGVyciB1c2UgZGlmZmVyZW50IGNoYW5uZWxzLlxyXG4gICAgICAgIC8vIE1ha2UgdHdvIGhhbmRsaW5nIGNhbGxzLlxyXG4gICAgICAgIGxldCBvdXRwdXRfc3RyZWFtX25hbWU6IE91dHB1dFN0cmVhbTtcclxuICAgICAgICBmb3IgKG91dHB1dF9zdHJlYW1fbmFtZSBpbiBvdXRwdXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0X2NoYW5uZWxfbmFtZSA9IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHNbb3V0cHV0X3N0cmVhbV9uYW1lXTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0X21lc3NhZ2UgPSBvdXRwdXRbb3V0cHV0X3N0cmVhbV9uYW1lXTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGVkX291dHB1dDogT3V0cHV0U3RyZWFtcyA9IHt9O1xyXG4gICAgICAgICAgICBzZXBhcmF0ZWRfb3V0cHV0W291dHB1dF9zdHJlYW1fbmFtZV0gPSBvdXRwdXRfbWVzc2FnZTtcclxuICAgICAgICAgICAgaGFuZGxlX3N0cmVhbShcclxuICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZCxcclxuICAgICAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXRfY2hhbm5lbF9uYW1lLFxyXG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkX291dHB1dCxcclxuICAgICAgICAgICAgICAgIGVycm9yX2NvZGUsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlX3N0cmVhbShcclxuICAgICAgICBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQsXHJcbiAgICAgICAgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdCxcclxuICAgICAgICBvdXRwdXRfY2hhbm5lbF9uYW1lOiBPdXRwdXRDaGFubmVsLFxyXG4gICAgICAgIG91dHB1dDogT3V0cHV0U3RyZWFtcyxcclxuICAgICAgICBlcnJvcl9jb2RlOiBudW1iZXJ8bnVsbFxyXG4gICAgKSB7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG91dHB1dCBzaG91bGQgYmUgaWdub3JlZFxyXG4gICAgaWYgKFwiaWdub3JlXCIgIT09IG91dHB1dF9jaGFubmVsX25hbWUpIHtcclxuICAgICAgICAvLyBUaGUgb3V0cHV0IHNob3VsZCBub3QgYmUgaWdub3JlZC5cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBhbiBvdXRwdXQgZHJpdmVyIGV4aXN0c1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG91dHB1dF9jaGFubmVsX2RyaXZlcnNbb3V0cHV0X2NoYW5uZWxfbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IGRyaXZlciBmb3VuZCBmb3IgY2hhbm5lbCAnXCIgKyBvdXRwdXRfY2hhbm5lbF9uYW1lICsgXCInLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHJpdmVyOiBPdXRwdXRDaGFubmVsRHJpdmVyID0gb3V0cHV0X2NoYW5uZWxfZHJpdmVyc1tvdXRwdXRfY2hhbm5lbF9uYW1lXTtcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBoYW5kbGluZyB0aGUgb3V0cHV0XHJcbiAgICAgICAgZHJpdmVyLmluaXRpYWxpemUocGx1Z2luLCB0X3NoZWxsX2NvbW1hbmQsIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQpO1xyXG4gICAgICAgIGRyaXZlci5oYW5kbGUob3V0cHV0LCBlcnJvcl9jb2RlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE91dHB1dENoYW5uZWxEcml2ZXJzT3B0aW9uTGlzdChvdXRwdXRfc3RyZWFtOiBPdXRwdXRTdHJlYW0pIHtcclxuICAgIGNvbnN0IGxpc3Q6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9ID0ge2lnbm9yZTogXCJJZ25vcmVcIn07XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3V0cHV0X2NoYW5uZWxfZHJpdmVycykge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dF9jaGFubmVsX2RyaXZlcjogYW55ID0gb3V0cHV0X2NoYW5uZWxfZHJpdmVyc1tuYW1lXTtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzdHJlYW0gaXMgc3VpdGFibGUgZm9yIHRoZSBjaGFubmVsXHJcbiAgICAgICAgaWYgKG91dHB1dF9jaGFubmVsX2RyaXZlci5hY2NlcHRzT3V0cHV0U3RyZWFtKG91dHB1dF9zdHJlYW0pKSB7XHJcbiAgICAgICAgICAgIGxpc3RbbmFtZV0gPSBvdXRwdXRfY2hhbm5lbF9kcml2ZXIuZ2V0VGl0bGUob3V0cHV0X3N0cmVhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPdXRwdXRDaGFubmVsRHJpdmVycygpIHtcclxuICAgIHJldHVybiBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIobmFtZTogT3V0cHV0Q2hhbm5lbCwgZHJpdmVyOiBPdXRwdXRDaGFubmVsRHJpdmVyKSB7XHJcbiAgICBpZiAodW5kZWZpbmVkICE9PSBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzW25hbWVdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0Q2hhbm5lbERyaXZlciBuYW1lZCAnXCIgKyBuYW1lICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCFcIik7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzW25hbWVdID0gZHJpdmVyO1xyXG59IiwiZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVzY2FwZXIge1xyXG4gICAgcHJvdGVjdGVkIHJhd192YWx1ZTogc3RyaW5nO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihyYXdfdmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMucmF3X3ZhbHVlID0gcmF3X3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBlc2NhcGUoKTogc3RyaW5nO1xyXG59IiwiaW1wb3J0IHtFc2NhcGVyfSBmcm9tIFwiLi9Fc2NhcGVyXCI7XHJcblxyXG4vKipcclxuICogUHJlZml4ZXMgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGxldHRlcnMsIG51bWJlcnMgb3IgdW5kZXJzY29yZXMgd2l0aCBhIHByZWZpeCBjaGFyYWN0ZXIgdGhhdCBjYW4gYmUgZGVmaW5lZCBieSBjaGlsZCBjbGFzc2VzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFsbFNwZWNpYWxDaGFyYWN0ZXJzRXNjYXBlciBleHRlbmRzIEVzY2FwZXIge1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHByZWZpeDogc3RyaW5nO1xyXG5cclxuICAgIHB1YmxpYyBlc2NhcGUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYXdfdmFsdWUucmVwbGFjZSgvW15cXHdcXGRdL2csIChzcGVjaWFsX2NoYXJhY3Rlcjogc3RyaW5nKSA9PiB7ICAvLyAvZyBtZWFucyB0byByZXBsYWNlIGFsbCBvY2N1cnJlbmNlcyBpbnN0ZWFkIG9mIGp1c3QgdGhlIGZpcnN0IG9uZS5cclxuICAgICAgICAgICAgLy8gRG8gdGhlIHJlcGxhY2luZyBpbiBhIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGEgcG9zc2libGUgJCBjaGFyYWN0ZXIgdG8gYmUgaW50ZXJwcmV0ZWQgYnkgSmF2YVNjcmlwdCB0byBpbnRlcmFjdCB3aXRoIHRoZSByZWdleC5cclxuICAgICAgICAgICAgLy8gTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGxhY2Ujc3BlY2lmeWluZ19hX3N0cmluZ19hc19hX3BhcmFtZXRlciAocmVmZXJlbmNlZCAyMDIxLTExLTAyLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXggKyBzcGVjaWFsX2NoYXJhY3RlcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImltcG9ydCB7QWxsU3BlY2lhbENoYXJhY3RlcnNFc2NhcGVyfSBmcm9tIFwiLi9BbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXJcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaEVzY2FwZXIgZXh0ZW5kcyBBbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXIge1xyXG4gICAgcHJvdGVjdGVkIHByZWZpeCA9IFwiXFxcXFwiOyAvLyBJbiAqc2gsIGVzY2FwaW5nIHNob3VsZCB1c2UgYSBiYWNrc2xhc2gsIGUuZy4gXCJIZWxsbywgd29ybGQhXCIgYmVjb21lcyBcXFwiSGVsbG9cXCxcXCB3b3JsZFxcIVxcXCJcclxuXHJcbiAgICBwdWJsaWMgZXNjYXBlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZV9uZXdsaW5lcyhzdXBlci5lc2NhcGUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBlc2NhcGVkIG5ld2xpbmUgY2hhcmFjdGVycyB0byBhIGZvcm0gdGhhdCB0aGUgQm91cm5lIGZhbWlseSBzaGVsbHMgd2lsbCBpbnRlcnByZXQgYXMgbGl0ZXJhbCBuZXdsaW5lcyxcclxuICAgICAqIG5vdCBhcyBpZ25vcmFibGUgY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXNjYXBlZF92YWx1ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXBsYWNlX25ld2xpbmVzKGVzY2FwZWRfdmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGVzY2FwZWRfdmFsdWVcclxuICAgICAgICAgICAgLnJlcGxhY2VBbGwodGhpcy5wcmVmaXgrXCJcXHJcIiwgdGhpcy5wcmVmaXgrdGhpcy5wcmVmaXgrXCJyXCIpIC8vIFJlcGxhY2UgYSByZWFsIGxpbmVmZWVkIHdpdGggYSBsaXRlcmFsIFwiXFxcXHJcIi5cclxuICAgICAgICAgICAgLnJlcGxhY2VBbGwodGhpcy5wcmVmaXgrXCJcXG5cIiwgdGhpcy5wcmVmaXgrdGhpcy5wcmVmaXgrXCJuXCIpIC8vIFJlcGxhY2UgYSByZWFsIG5ld2xpbmUgd2l0aCBhIGxpdGVyYWwgXCJcXFxcblwiLlxyXG4gICAgICAgIDtcclxuICAgIH1cclxufSIsImltcG9ydCB7QWxsU3BlY2lhbENoYXJhY3RlcnNFc2NhcGVyfSBmcm9tIFwiLi9BbGxTcGVjaWFsQ2hhcmFjdGVyc0VzY2FwZXJcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQb3dlclNoZWxsRXNjYXBlciBleHRlbmRzIEFsbFNwZWNpYWxDaGFyYWN0ZXJzRXNjYXBlciB7XHJcbiAgICBwcm90ZWN0ZWQgcHJlZml4ID0gXCJgXCI7IC8vIEluIFBvd2VyU2hlbGwsIGVzY2FwaW5nIHNob3VsZCB1c2UgYSBgIGNoYXJhY3RlciwgZS5nLiBcIkhlbGxvLCB3b3JsZCFcIiBiZWNvbWVzIGBcIkhlbGxvYCxgIHdvcmxkYCFgXCJcclxufSIsImltcG9ydCB7RXNjYXBlcn0gZnJvbSBcIi4vRXNjYXBlclwiO1xyXG5pbXBvcnQge1NoRXNjYXBlcn0gZnJvbSBcIi4vU2hFc2NhcGVyXCI7XHJcbmltcG9ydCB7UG93ZXJTaGVsbEVzY2FwZXJ9IGZyb20gXCIuL1Bvd2VyU2hlbGxFc2NhcGVyXCI7XHJcbmltcG9ydCB7Tm90aWNlfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtleHRyYWN0RmlsZU5hbWV9IGZyb20gXCIuLi8uLi9Db21tb25cIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVWYWx1ZShzaGVsbDogc3RyaW5nLCByYXdfdmFsdWU6IHN0cmluZykge1xyXG4gICAgc2hlbGwgPSBleHRyYWN0RmlsZU5hbWUoc2hlbGwudG9Mb3dlckNhc2UoKSk7XHJcbiAgICBsZXQgZXNjYXBlcjogRXNjYXBlcjtcclxuICAgIHN3aXRjaCAoc2hlbGwpIHtcclxuICAgICAgICBjYXNlIFwiYmFzaFwiOlxyXG4gICAgICAgIGNhc2UgXCJkYXNoXCI6XHJcbiAgICAgICAgY2FzZSBcInpzaFwiOlxyXG4gICAgICAgICAgICBlc2NhcGVyID0gbmV3IFNoRXNjYXBlcihyYXdfdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwicG93ZXJzaGVsbC5leGVcIjogIC8vIFBvd2VyU2hlbGwgNSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgV2luZG93cy5cclxuICAgICAgICBjYXNlIFwicHdzaC5leGVcIjogICAgICAgIC8vIEluIFdpbmRvd3MuXHJcbiAgICAgICAgY2FzZSBcInB3c2hcIjogICAgICAgICAgICAvLyBJbiBMaW51eCBhbmQgTWFjLiAoU0MgZG9lcyBub3QgYWN0dWFsbHkgc3VwcG9ydCB1c2luZyBQb3dlclNoZWxsIG9uIExpbnV4L01hYyBqdXN0IHlldCwgYnV0IHN1cHBvcnQgY2FuIGJlIGFkZGVkKS5cclxuICAgICAgICAgICAgZXNjYXBlciA9IG5ldyBQb3dlclNoZWxsRXNjYXBlcihyYXdfdmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiY21kLmV4ZVwiOlxyXG4gICAgICAgICAgICAvLyBFeGNlcHRpb246IFRoZXJlIGlzIG5vIGVzY2FwaW5nIHN1cHBvcnQgZm9yIENNRCwgc28gYWxsIHZhbHVlcyB3aWxsIGJlIGxlZnQgdW5lc2NhcGVkIHdoZW4gQ01EIGlzIHVzZWQuIDooXHJcbiAgICAgICAgICAgIHJldHVybiByYXdfdmFsdWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gU2hlbGwgd2FzIG5vdCByZWNvZ25pc2VkLlxyXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRXNjYXBlVmFsdWUoKTogVW5yZWNvZ25pc2VkIHNoZWxsOiBcIiArIHNoZWxsKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjYXBlVmFsdWUoKTogVW5yZWNvZ25pc2VkIHNoZWxsOiBcIiArIHNoZWxsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlc2NhcGVyLmVzY2FwZSgpO1xyXG59IiwiaW1wb3J0IHtBcHB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7ZXNjYXBlVmFsdWV9IGZyb20gXCIuL2VzY2FwZXJzL0VzY2FwZVZhbHVlXCI7XHJcbmltcG9ydCB7SUF1dG9jb21wbGV0ZUl0ZW19IGZyb20gXCIuLi9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZVwiO1xyXG5cclxuaW50ZXJmYWNlIElBcmd1bWVudHMge1xyXG4gICAgW2tleTogc3RyaW5nXTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICoga2V5ID0gc3RyaW5nLCBwYXJhbWV0ZXIgbmFtZVxyXG4gKiB2YWx1ZSA9IGJvb2xlYW4sIGlzIHRoZSBwYXJhbWV0ZXIgbWFuZGF0b3J5IG9yIG5vdD9cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBhcmFtZXRlcnMge1xyXG4gICAgW2tleTogc3RyaW5nXToge1xyXG4gICAgICAgIC8qKiBXaGF0IGRhdGEgdHlwZSBpcyBhbGxvd2VkLiAoTmV3IHR5cGVzIGNhbiBiZSBhZGRlZCBsYXRlcikuIFNob3VsZCBiZSBvbWl0dGVkLCBpZiAnb3B0aW9ucycgaXMgdXNlZC4gKi9cclxuICAgICAgICB0eXBlPzogXCJzdHJpbmdcIiB8IFwiaW50ZWdlclwiO1xyXG4gICAgICAgIC8qKiBUaGlzIGNhbiBkZWZpbmUgc3RhdGljIHZhbHVlcyBmb3IgdGhpcyBwYXJhbWV0ZXIuIFNob3VsZCBiZSBvbWl0dGVkLCBpZiAndHlwZScgaXMgdXNlZC4gKi9cclxuICAgICAgICBvcHRpb25zPzogc3RyaW5nW107XHJcbiAgICAgICAgLyoqIElzIHRoaXMgcGFyYW1ldGVyIG1hbmRhdG9yeT8gKi9cclxuICAgICAgICByZXF1aXJlZDogYm9vbGVhbjtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYXJpYWJsZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBpbmplY3QgdmFsdWVzIHRvIHNoZWxsIGNvbW1hbmRzIHVzaW5nIHt7dmFyaWFibGU6YXJndW1lbnR9fSBzeW50YXguXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVmFyaWFibGUge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyX3NlcGFyYXRvciA9IFwiOlwiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHBsdWdpbjogU0NfUGx1Z2luO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGFwcDogQXBwO1xyXG4gICAgcHJpdmF0ZSBlcnJvcl9tZXNzYWdlczogc3RyaW5nW10gPSBbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdmFyaWFibGVfbmFtZTogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIHNoZWxsOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGhlbHBfdGV4dDogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBkZWZpbml0aW9uIGZvciB3aGF0IHBhcmFtZXRlcnMgdGhpcyB2YXJpYWJsZXMgdGFrZXMuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29udGFpbnMgYWN0dWFsIHZhbHVlcyBmb3IgcGFyYW1ldGVycy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czogSUFyZ3VtZW50cyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwbHVnaW5cclxuICAgICAqIEBwYXJhbSBzaGVsbCBVc2VkIHRvIGRldGVybWluZSB3aGF0IGtpbmQgb2YgZXNjYXBpbmcgc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogU0NfUGx1Z2luLCBzaGVsbDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cclxuICAgICAgICB0aGlzLmFwcCA9IHBsdWdpbi5hcHA7XHJcbiAgICAgICAgdGhpcy5zaGVsbCA9IHNoZWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRWYWx1ZShlc2NhcGU6IGJvb2xlYW4pIHtcclxuICAgICAgICBjb25zdCByYXdfdmFsdWUgPSB0aGlzLmdlbmVyYXRlVmFsdWUoKTtcclxuICAgICAgICBpZiAobnVsbCA9PT0gcmF3X3ZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIFNvbWUgZXJyb3IocykgaGFzIG9jY3VycmVkIHdoZW4gZ2VuZXJhdGluZyB0aGUgdmFyaWFibGUncyB2YWx1ZS5cclxuICAgICAgICAgICAgLy8gUHJldmVudCBwYXNzaW5nIG51bGwgdG8gZXNjYXBlVmFsdWUoKS5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICAgICAgLy8gVmFsdWUgc2hvdWxkIGJlIGVzY2FwZWQuXHJcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVWYWx1ZSh0aGlzLnNoZWxsLCByYXdfdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEEgcmF3LCB1bmVzY2FwZWQgdmFsdWUgaXMgZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgIHJldHVybiByYXdfdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZ3xudWxsO1xyXG5cclxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZU5hbWUoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRfY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBWYXJpYWJsZTtcclxuICAgICAgICByZXR1cm4gY2hpbGRfY2xhc3MudmFyaWFibGVfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0UGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCBjaGlsZF9jbGFzcyA9IHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFZhcmlhYmxlO1xyXG4gICAgICAgIHJldHVybiBjaGlsZF9jbGFzcy5wYXJhbWV0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0UGFyYW1ldGVyU2VwYXJhdG9yKCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkX2NsYXNzID0gdGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgVmFyaWFibGU7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkX2NsYXNzLnBhcmFtZXRlcl9zZXBhcmF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBhdHRlcm4oKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JfcHJlZml4ID0gdGhpcy5nZXRWYXJpYWJsZU5hbWUoKSArIFwiLmdldFBhdHRlcm4oKTogXCI7XHJcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAnXFx7XFx7XFwhPycgKyB0aGlzLmdldFZhcmlhYmxlTmFtZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyX25hbWUgaW4gdGhpcy5nZXRQYXJhbWV0ZXJzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXJzKClbcGFyYW1ldGVyX25hbWVdO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyX3R5cGVfcGF0dGVybjogc3RyaW5nID0gdGhpcy5nZXRQYXJhbWV0ZXJTZXBhcmF0b3IoKTsgIC8vIEhlcmUgdGhpcy5wYXJhbWV0ZXJfc2VwYXJhdG9yICg9IDogKSBpcyBpbmNsdWRlZCBpbiB0aGUgcGFyYW1ldGVyIHZhbHVlIGp1c3Qgc28gdGhhdCBpdCdzIG5vdCBuZWVkZWQgdG8gZG8gbmVzdGVkIHBhcmVudGhlc2lzIHRvIGFjY29tcGxpc2ggcG9zc2libGUgb3B0aW9uYWxpdHk6ICg6KCkpPy4gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXMoKSB3aWxsIHJlbW92ZSB0aGUgbGVhZGluZyA6IC5cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHNob3VsZCB3ZSB1c2UgcGFyYW1ldGVyLm9wdGlvbnMgb3IgcGFyYW1ldGVyLnR5cGUuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gcGFyYW1ldGVyLm9wdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gcGFyYW1ldGVyLnR5cGVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGlzIGRlZmluZWQgOihcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGVycm9yX3ByZWZpeCArIFwiUGFyYW1ldGVyICdcIiArIHBhcmFtZXRlcl9uYW1lICsgXCInIHNob3VsZCBkZWZpbmUgZWl0aGVyICd0eXBlJyBvciAnb3B0aW9ucycsIG5laXRoZXIgaXMgZGVmaW5lZCFcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBhcmFtZXRlci5vcHRpb25zICYmXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgIT09IHBhcmFtZXRlci50eXBlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQm90aCBhcmUgZGVmaW5lZCA6KFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyb3JfcHJlZml4ICsgXCJQYXJhbWV0ZXIgJ1wiICsgcGFyYW1ldGVyX25hbWUgKyBcIicgc2hvdWxkIGRlZmluZSBlaXRoZXIgJ3R5cGUnIG9yICdvcHRpb25zJywgbm90IGJvdGghXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuZGVmaW5lZCAhPT0gcGFyYW1ldGVyLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBwYXJhbWV0ZXIub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArPSBwYXJhbWV0ZXIub3B0aW9ucy5qb2luKFwifFwiICsgdGhpcy5nZXRQYXJhbWV0ZXJTZXBhcmF0b3IoKSk7IC8vIEUuZy4gXCJhYnNvbHV0ZXw6cmVsYXRpdmVcIiBmb3Ige3tmaWxlX3BhdGg6bW9kZX19IHZhcmlhYmxlJ3MgJ21vZGUnIHBhcmFtZXRlci5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBwYXJhbWV0ZXIudHlwZVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArPSBcIi4qP1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfdHlwZV9wYXR0ZXJuICs9IFwiXFxcXGQrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGVycm9yX3ByZWZpeCArIFwiUGFyYW1ldGVyICdcIiArIHBhcmFtZXRlcl9uYW1lICsgXCInIGhhcyBhbiB1bnJlY29nbmlzZWQgdHlwZTogXCIgKyBwYXJhbWV0ZXIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc3VicGF0dGVybiB0byAncGF0dGVybicuXHJcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gXCIoXCIgKyBwYXJhbWV0ZXJfdHlwZV9wYXR0ZXJuICsgXCIpXCI7XHJcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBwYXJhbWV0ZXIgb3B0aW9uYWwuXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IFwiP1wiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXR0ZXJuICs9ICdcXH1cXH0nO1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQYXJhbWV0ZXJOYW1lcygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5nZXRQYXJhbWV0ZXJzKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcl9uYW1lXHJcbiAgICAgKiBAcGFyYW0gYXJndW1lbnQgQXQgdGhpcyBwb2ludCAnYXJndW1lbnQnIGlzIGFsd2F5cyBhIHN0cmluZywgYnV0IHRoaXMgbWV0aG9kIG1heSBjb252ZXJ0IGl0IHRvIGFub3RoZXIgZGF0YSB0eXBlLCBkZXBlbmRpbmcgb24gdGhlIHBhcmFtZXRlcidzIGRhdGEgdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFyZ3VtZW50KHBhcmFtZXRlcl9uYW1lOiBzdHJpbmcsIGFyZ3VtZW50OiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJfdHlwZSA9IHRoaXMuZ2V0UGFyYW1ldGVycygpW3BhcmFtZXRlcl9uYW1lXS50eXBlID8/IFwic3RyaW5nXCI7IC8vIElmIHRoZSB2YXJpYWJsZSB1c2VzIFwib3B0aW9uc1wiIGluc3RlYWQgb2YgXCJ0eXBlXCIsIHRoZW4gdGhlIHR5cGUgaXMgYWx3YXlzIFwic3RyaW5nXCIuXHJcbiAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXJfdHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50c1twYXJhbWV0ZXJfbmFtZV0gPSBhcmd1bWVudDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHNbcGFyYW1ldGVyX25hbWVdID0gcGFyc2VJbnQoYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90ZSB0aGF0IGVycm9yIG1lc3NhZ2VzIGNhbiBvbmx5IGV4aXN0IGFmdGVyIGdldFZhbHVlKCkgaXMgY2FsbGVkIVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXJyb3JNZXNzYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcl9tZXNzYWdlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbmV3RXJyb3JNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IFwie3tcIiArIHRoaXMuZ2V0VmFyaWFibGVOYW1lKCkgKyBcIn19OiBcIjtcclxuICAgICAgICB0aGlzLmVycm9yX21lc3NhZ2VzLnB1c2gocHJlZml4ICsgbWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG5ld0Vycm9yTWVzc2FnZXMobWVzc2FnZXM6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QXV0b2NvbXBsZXRlSXRlbXMoKTogSUF1dG9jb21wbGV0ZUl0ZW1bXSB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB2YXJpYWJsZSBoYXMgYXQgbGVhc3Qgb25lIF9tYW5kYXRvcnlfIHBhcmFtZXRlci5cclxuICAgICAgICBsZXQgcGFyYW1ldGVycyA9IFwiXCJcclxuICAgICAgICBsZXQgcGFyYW1ldGVyX2luZGljYXRvciA9IFwiXCI7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyX25hbWVzID1cclxuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wYXJhbWV0ZXJzKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihwYXJhbWV0ZXJfbmFtZSA9PiB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyX25hbWVdLnJlcXVpcmVkID09PSB0cnVlKSAvLyBPbmx5IGluY2x1ZGUgbWFuZGF0b3J5IHBhcmFtZXRlcnNcclxuICAgICAgICA7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcl9uYW1lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcl9zZXBhcmF0b3IgKyBwYXJhbWV0ZXJfbmFtZXMuam9pbih0aGlzLnBhcmFtZXRlcl9zZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJfaW5kaWNhdG9yID0gdGhpcy5wYXJhbWV0ZXJfc2VwYXJhdG9yOyAvLyBXaGVuIHRoZSB2YXJpYWJsZSBuYW1lIGVuZHMgd2l0aCBhIHBhcmFtZXRlciBzZXBhcmF0b3IgY2hhcmFjdGVyLCBpdCBpbmRpY2F0ZXMgdG8gYSB1c2VyIHRoYXQgYW4gYXJndW1lbnQgc2hvdWxkIGJlIHN1cHBsaWVkLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgcGFyYW1ldGVyX2luZGljYXRvciArIFwifX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogdGhpcy5oZWxwX3RleHQgKyBcIiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVW5lc2NhcGVkIHZlcnNpb24gb2YgdGhlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIHBhcmFtZXRlcl9pbmRpY2F0b3IgKyBcIn19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IHRoaXMuaGVscF90ZXh0ICsgXCIgXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7XCIgKyB0aGlzLmdldFZhcmlhYmxlTmFtZSgpICsgXCJ9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwVGV4dCgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZF9jbGFzcyA9IHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFZhcmlhYmxlO1xyXG4gICAgICAgIHJldHVybiBjaGlsZF9jbGFzcy5oZWxwX3RleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgdmFyaWFibGVzIHRoYXQgYXJlIGFsd2F5cyBhdmFpbGFibGUsIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF2YWlsYWJpbGl0eVRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHlwZSBuZWVkcyB0byBiZSAnYW55JyBzbyB0aGF0IGNoaWxkIGNsYXNzZXMgY2FuIHJldHVybiBhIGNoaWxkIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMoKTogYW55IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgVmFyaWFibGU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuLy8gQHRzLWlnbm9yZSBcImVsZWN0cm9uXCIgaXMgaW5zdGFsbGVkLlxyXG5pbXBvcnQge2NsaXBib2FyZH0gZnJvbSBcImVsZWN0cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfQ2xpcGJvYXJkIGV4dGVuZHMgVmFyaWFibGUge1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJjbGlwYm9hcmRcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY29udGVudCB5b3UgbGFzdCBjb3BpZWQgdG8geW91ciBjbGlwYm9hcmQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gY2xpcGJvYXJkLnJlYWRUZXh0KCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge2dldEVkaXRvcn0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzLCBWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfQ2FyZXRQb3NpdGlvbiBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiY2FyZXRfcG9zaXRpb25cIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgbGluZSBudW1iZXIgYW5kIGNvbHVtbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBhcyAnbGluZTpjb2x1bW4nLiBHZXQgb25seSB0aGUgbGluZSBudW1iZXIgdXNpbmcge3tjYXJldF9wb3NpdGlvbjpsaW5lfX0sIGFuZCBvbmx5IHRoZSBjb2x1bW4gd2l0aCB7e2NhcmV0X3Bvc2l0aW9uOmNvbHVtbn19LiBMaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBhcmUgMS1pbmRleGVkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJsaW5lXCIsIFwiY29sdW1uXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIG1vZGU6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgd2UgYXJlIGFibGUgdG8gZ2V0IGFuIGVkaXRvclxyXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcCk7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IGVkaXRvcikge1xyXG4gICAgICAgICAgICAvLyBOb3BlLlxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlISBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3IoJ3RvJyk7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IHBvc2l0aW9uLmxpbmUgKyAxOyAvLyBlZGl0b3IgcG9zaXRpb24gaXMgemVyby1pbmRleGVkLCBsaW5lIG51bWJlcnMgYXJlIDEtaW5kZXhlZFxyXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHBvc2l0aW9uLmNoICsgMTsgLy8gZWRpdG9yIHBvc2l0aW9uIGlzIHplcm8taW5kZXhlZCwgY29sdW1uIHBvc2l0aW9ucyBhcmUgMS1pbmRleGVkXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuYXJndW1lbnRzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hcmd1bWVudHMubW9kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGluZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lfWA7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2NvbHVtbn1gO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIlVucmVjb2duaXNlZCBhcmd1bWVudDogXCIrdGhpcy5hcmd1bWVudHMubW9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGNhc2Ugd2hlbiBubyBhcmdzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIHJldHVybiBgJHtsaW5lfToke2NvbHVtbn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIn19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGxpbmUgbnVtYmVyIGFuZCBjb2x1bW4gcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gYXMgJ2xpbmU6Y29sdW1uJy4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmxpbmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmNvbHVtbn19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGNvbHVtbiBudW1iZXIgb2YgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCJcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCJ9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBsaW5lIG51bWJlciBhbmQgY29sdW1uIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uIGFzICdsaW5lOmNvbHVtbicuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmxpbmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6Y29sdW1ufX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgY29sdW1uIG51bWJlciBvZiB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tjYXJldF9wb3NpdGlvbn19PC9zdHJvbmc+LCA8c3Ryb25nPnt7Y2FyZXRfcG9zaXRpb246bGluZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tjYXJldF9wb3NpdGlvbjpjb2x1bW59fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gd2hlbiBhIG5vdGUgcGFuZSBpcyBvcGVuLCBub3QgaW4gZ3JhcGggdmlldywgbm9yIHdoZW4gdmlld2luZyBub24tdGV4dCBmaWxlcy5cIjtcclxuICAgIH1cclxufSIsImltcG9ydCB7bW9tZW50fSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVycywgVmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRGF0ZSBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZGF0ZVwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBoZWxwX3RleHQgPSBcIkdpdmVzIGEgZGF0ZS90aW1lIHN0YW1wIGFzIHBlciB5b3VyIGxpa2luZy4gVGhlIFxcXCJmb3JtYXRcXFwiIHBhcnQgY2FuIGJlIGN1c3RvbWl6ZWQgYW5kIGlzIG1hbmRhdG9yeS4gRm9ybWF0dGluZyBvcHRpb25zOiBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZGlzcGxheWluZy9mb3JtYXQvXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBmb3JtYXQ6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgZm9ybWF0OiBzdHJpbmcsXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50KCkuZm9ybWF0KHRoaXMuYXJndW1lbnRzLmZvcm1hdCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge2dldFZhdWx0QWJzb2x1dGVQYXRoLCBub3JtYWxpemVQYXRoMiwgdW5pcXVlQXJyYXl9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtBcHAsIGdldEFsbFRhZ3MsIFRGaWxlLCBURm9sZGVyfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBDb25zaWRlciBjcmVhdGluZyBhIGRlY29yYXRvciBjbGFzcyBmb3IgVEZvbGRlciBhbmQgbW92aW5nIHRoaXMgZnVuY3Rpb24gdG8gYmUgYSBtZXRob2QgaW4gaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHBcclxuICogQHBhcmFtIGZvbGRlclxyXG4gKiBAcGFyYW0gbW9kZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbGRlclBhdGgoYXBwOiBBcHAsIGZvbGRlcjogVEZvbGRlciwgbW9kZTogXCJhYnNvbHV0ZVwiIHwgXCJyZWxhdGl2ZVwiKSB7XHJcbiAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgoYXBwKSArIFwiL1wiICsgZm9sZGVyLnBhdGgpO1xyXG4gICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICBpZiAoZm9sZGVyLmlzUm9vdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPYnNpZGlhbiBBUEkgZG9lcyBub3QgZ2l2ZSBhIGNvcnJlY3QgZm9sZGVyLnBhdGggdmFsdWUgZm9yIHRoZSB2YXVsdCdzIHJvb3QgZm9sZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU2VlIHRoaXMgZGlzY3Vzc2lvbiBhbmQgYXBwbHkgcG9zc2libGUgY2hhbmdlcyBpZiBzb21ldGhpbmcgd2lsbCBjb21lIHVwOiBodHRwczovL2ZvcnVtLm9ic2lkaWFuLm1kL3QvdmF1bHQtcm9vdC1mb2xkZXJzLXJlbGF0aXZlLXBhdGgtZ2l2ZXMvMjQ4NTdcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIi5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBub3JtYWwgc3ViZm9sZGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZm9sZGVyLnBhdGgpOyAvLyBOb3JtYWxpemUgdG8gZ2V0IGEgY29ycmVjdCBzbGFzaCBiZXR3ZWVuIGRpcmVjdG9yaWVzIGRlcGVuZGluZyBvbiBwbGF0Zm9ybS4gT24gV2luZG93cyBpdCBzaG91bGQgYmUgXFwgLlxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBDb25zaWRlciBjcmVhdGluZyBhIGRlY29yYXRvciBjbGFzcyBmb3IgVEZpbGUgYW5kIG1vdmluZyB0aGlzIGZ1bmN0aW9uIHRvIGJlIGEgbWV0aG9kIGluIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwXHJcbiAqIEBwYXJhbSBmaWxlXHJcbiAqIEBwYXJhbSBtb2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVBhdGgoYXBwOiBBcHAsIGZpbGU6IFRGaWxlLCBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCIpIHtcclxuICAgIHN3aXRjaCAobW9kZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSBcImFic29sdXRlXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVQYXRoMihnZXRWYXVsdEFic29sdXRlUGF0aChhcHApICsgXCIvXCIgKyBmaWxlLnBhdGgpO1xyXG4gICAgICAgIGNhc2UgXCJyZWxhdGl2ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZmlsZS5wYXRoKTsgLy8gTm9ybWFsaXplIHRvIGdldCBhIGNvcnJlY3Qgc2xhc2ggZGVwZW5kaW5nIG9uIHBsYXRmb3JtLiBPbiBXaW5kb3dzIGl0IHNob3VsZCBiZSBcXCAuXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVE9ETzogQ29uc2lkZXIgY3JlYXRpbmcgYSBkZWNvcmF0b3IgY2xhc3MgZm9yIFRGaWxlIGFuZCBtb3ZpbmcgdGhpcyBmdW5jdGlvbiB0byBiZSBhIG1ldGhvZCBpbiBpdC5cclxuICogQHBhcmFtIGZpbGVcclxuICogQHBhcmFtIHdpdGhfZG90XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbihmaWxlOiBURmlsZSwgd2l0aF9kb3Q6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IGZpbGVfZXh0ZW5zaW9uID0gZmlsZS5leHRlbnNpb247XHJcblxyXG4gICAgLy8gU2hvdWxkIHRoZSBleHRlbnNpb24gYmUgZ2l2ZW4gd2l0aCBvciB3aXRob3V0IGEgZG90P1xyXG4gICAgaWYgKHdpdGhfZG90KSB7XHJcbiAgICAgICAgLy8gQSBwcmVjZWRpbmcgZG90IG11c3QgYmUgaW5jbHVkZWQuXHJcbiAgICAgICAgaWYgKGZpbGVfZXh0ZW5zaW9uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQnV0IG9ubHkgaWYgdGhlIGV4dGVuc2lvbiBpcyBub3QgZW1wdHkuXHJcbiAgICAgICAgICAgIHJldHVybiBcIi5cIiArIGZpbGVfZXh0ZW5zaW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBkb3Qgc2hvdWxkIGJlIGluY2x1ZGVkLCBvciB0aGUgZXh0ZW5zaW9uIGlzIGVtcHR5XHJcbiAgICByZXR1cm4gZmlsZV9leHRlbnNpb247XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlVGFncyhhcHA6IEFwcCwgZmlsZTogVEZpbGUpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xyXG4gICAgY29uc3QgdGFnczogc3RyaW5nW10gPSB1bmlxdWVBcnJheShnZXRBbGxUYWdzKGNhY2hlKSk7IC8vIElmIGEgdGFnIGlzIGRlZmluZWQgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgZmlsZSwgZ2V0VGFncygpIHJldHVybnMgaXQgbXVsdGlwbGUgdGltZXMsIHNvIHVzZSB1bmlxdWVBcnJheSgpIHRvIGlyb24gb3V0IGR1cGxpY2F0ZXMuXHJcblxyXG4gICAgLy8gUmVtb3ZlIHByZWNlZGluZyBoYXNoIGNoYXJhY3RlcnMuIEUuZy4gI3RhZyBiZWNvbWVzIHRhZ1xyXG4gICAgdGFncy5mb3JFYWNoKCh0YWc6IHN0cmluZywgaW5kZXgpID0+IHtcclxuICAgICAgICB0YWdzW2luZGV4XSA9IHRhZy5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhZ3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gYXBwXHJcbiAqIEBwYXJhbSBmaWxlXHJcbiAqIEBwYXJhbSBwcm9wZXJ0eV9wYXRoXHJcbiAqIEByZXR1cm4gc3RyaW5nfHN0cmluZ1tdIEVpdGhlciBhIHJlc3VsdCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVZQU1MVmFsdWUoYXBwOiBBcHAsIGZpbGU6IFRGaWxlLCBwcm9wZXJ0eV9wYXRoOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGVycm9yX21lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3QgcHJvcGVydHlfcGFydHMgPSBwcm9wZXJ0eV9wYXRoLnNwbGl0KFwiLlwiKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBhbGwgcHJvcGVydHkgbmFtZXMgYWxvbmcgdGhlIHBhdGhcclxuICAgIHByb3BlcnR5X3BhcnRzLmZvckVhY2goKHByb3BlcnR5X25hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGlmICgwID09PSBwcm9wZXJ0eV9uYW1lLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFwiWUFNTCBwcm9wZXJ0eSAnXCIgKyB0aGlzLmFyZ3VtZW50cy5wcm9wZXJ0eV9uYW1lICsgXCInIGhhcyBhbiBlbXB0eSBwcm9wZXJ0eSBuYW1lLiBSZW1vdmUgcG9zc2libGUgZG91YmxlIGRvdHMgb3IgYSBwcmVjZWRpbmcvdHJhaWxpbmcgZG90LlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChlcnJvcl9tZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gRmFpbHVyZSBpbiBwcm9wZXJ0eSBuYW1lKHMpLlxyXG4gICAgICAgIHJldHVybiBlcnJvcl9tZXNzYWdlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmcm9udG1hdHRlciA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XHJcbiAgICAvLyBDaGVjayB0aGF0IGEgWUFNTCBzZWN0aW9uIGlzIGF2YWlsYWJsZSBpbiB0aGUgZmlsZVxyXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAvLyBObyBpdCBhaW4ndC5cclxuICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFwiTm8gWUFNTCBmcm9udG1hdHRlciBzZWN0aW9uIGlzIGRlZmluZWQgZm9yIHRoZSBjdXJyZW50IGZpbGUuXCIpO1xyXG4gICAgICAgIHJldHVybiBlcnJvcl9tZXNzYWdlcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQSBZQU1MIHNlY3Rpb24gaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgIC8vIFJlYWQgdGhlIHByb3BlcnR5J3MgdmFsdWUuXHJcbiAgICAgICAgcmV0dXJuIG5lc3RlZF9yZWFkKHByb3BlcnR5X3BhcnRzLCBwcm9wZXJ0eV9wYXRoLCBmcm9udG1hdHRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlfcGFydHMgUHJvcGVydHkgcGF0aCBzcGxpdCBpbnRvIHBhcnRzICg9IHByb3BlcnR5IG5hbWVzKS4gVGhlIGRlZXBlciB0aGUgbmVzdGluZyBnb2VzLCB0aGUgZmV3ZXIgdmFsdWVzIHdpbGwgYmUgbGVmdCBpbiB0aGlzIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5X3BhdGggVGhlIG9yaWdpbmFsLCB3aG9sZSBwcm9wZXJ0eSBwYXRoIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB5YW1sX29iamVjdFxyXG4gICAgICogQHJldHVybiBzdHJpbmd8c3RyaW5nW10gRWl0aGVyIGEgcmVzdWx0IHN0cmluZywgb3IgYW4gYXJyYXkgb2YgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5lc3RlZF9yZWFkKHByb3BlcnR5X3BhcnRzOiBzdHJpbmdbXSwgcHJvcGVydHlfcGF0aDogc3RyaW5nLCB5YW1sX29iamVjdDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBvYmplY3QgfSk6IHN0cmluZyB8IHN0cmluZ1tdIHtcclxuICAgICAgICBsZXQgcHJvcGVydHlfbmFtZTogc3RyaW5nID0gcHJvcGVydHlfcGFydHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb3BlcnR5IG5hbWUgaXMgYSBuZWdhdGl2ZSBudW1lcmljIGluZGV4LlxyXG4gICAgICAgIGlmIChwcm9wZXJ0eV9uYW1lLm1hdGNoKC9eLVxcZCskLykpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHByb3BlcnR5IG5hbWUgaXMgYSBuZWdhdGl2ZSBudW1iZXIuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgeWFtbF9vYmplY3QgY29udGFpbnMgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGNvbnN0IHlhbWxfb2JqZWN0X2tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh5YW1sX29iamVjdCkuZmlsdGVyKGtleSA9PiBrZXkgIT09IFwibGVuZ3RoXCIpOyAvLyBBbGwgX3JlYWxseSBjdXN0b21fIHlhbWwga2V5cywgbm90IC5sZW5ndGhcclxuICAgICAgICAgICAgaWYgKHlhbWxfb2JqZWN0X2tleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeWFtbF9vYmplY3QgaGFwcGVucyB0byBiZSBhbiBpbmRleGVkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICBsZXQgaXNfaW5kZXhlZF9saXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHlhbWxfb2JqZWN0X2tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IGxlYXN0IG9uZSBub24tbnVtZXJpYyBrZXkgd2FzIGZvdW5kLCBzbyBjb25zaWRlciB0aGUgb2JqZWN0IG5vdCB0byBiZSBhbiBpbmRleGVkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX2luZGV4ZWRfbGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzX2luZGV4ZWRfbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYW4gaW5kZXhlZCBsaXN0IGFuZCBwcm9wZXJ0eV9uYW1lIGlzIGEgbmVnYXRpdmUgaW5kZXggbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBwcm9wZXJ0eV9uYW1lIHRvIGEgcG9zaXRpdmUgaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5X25hbWUgPSBNYXRoLm1heCgwLCAvLyBJZiBhIGdyZWF0bHkgbmVnYXRpdmUgaW5kZXggaXMgdXNlZCAoZS5nLiAtOTk5KSwgZG9uJ3QgYWxsb3cgdGhlIG5ldyBpbmRleCB0byBiZSBuZWdhdGl2ZSBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeWFtbF9vYmplY3Rfa2V5cy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBwYXJzZUludChwcm9wZXJ0eV9uYW1lKSAvLyBBbHRob3VnaCArIGlzIHVzZWQsIHRoaXMgd2lsbCBiZSBhIHN1YnRyYWN0aW9uLCBiZWNhdXNlIHByb3BlcnR5X25hbWUgaXMgcHJlZml4ZWQgd2l0aCBhIG1pbnVzLlxyXG4gICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGEgdmFsdWVcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eV92YWx1ZSA9IHlhbWxfb2JqZWN0W3Byb3BlcnR5X25hbWVdO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgZWl0aGVyOiBub3QgZm91bmQsIG9iamVjdCwgb3IgbGl0ZXJhbC5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eV92YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSB3YXMgbm90IGZvdW5kLlxyXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlcy5wdXNoKFwiWUFNTCBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eV9uYW1lICsgXCInIGlzIG5vdCBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcl9tZXNzYWdlcztcclxuICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wZXJ0eV92YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHN0aWxsIGRvdCBub3RhdGlvbiBwYXJ0cyBsZWZ0IGluIHRoZSBwcm9wZXJ0eSBwYXRoLlxyXG4gICAgICAgICAgICBpZiAoMCA9PT0gcHJvcGVydHlfcGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBkb3Qgbm90YXRpb24gcGFydHMgYXJlIGxlZnQuXHJcbiAgICAgICAgICAgICAgICAvLyBGcmVhayBvdXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRfZWxlbWVudHNfa2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnR5X3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRfZWxlbWVudHNfa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbWVzc2FnZXMucHVzaChcIllBTUwgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlfbmFtZSArIFwiJyBjb250YWlucyBhIG5lc3RlZCBlbGVtZW50IHdpdGgga2V5czogXCIgKyBuZXN0ZWRfZWxlbWVudHNfa2V5cy5qb2luKFwiLCBcIikgKyBcIi4gVXNlIGUuZy4gJ1wiICsgcHJvcGVydHlfcGF0aCArIFwiLlwiICsgbmVzdGVkX2VsZW1lbnRzX2tleXNbMF0gKyBcIicgdG8gZ2V0IGl0cyB2YWx1ZS5cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goXCJZQU1MIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicgY29udGFpbnMgYSBuZXN0ZWQgZWxlbWVudC4gVXNlIGEgcHJvcGVydHkgbmFtZSB0aGF0IHBvaW50cyB0byBhIGxpdGVyYWwgdmFsdWUgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JfbWVzc2FnZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb3Qgbm90YXRpb24gcGF0aCBzdGlsbCBoYXMgYW5vdGhlciBwcm9wZXJ0eSBuYW1lIGxlZnQsIHNvIGNvbnRpbnVlIHRoZSBodW50LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZF9yZWFkKHByb3BlcnR5X3BhcnRzLCBwcm9wZXJ0eV9wYXRoLCBwcm9wZXJ0eV92YWx1ZSBhcyB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IG9iamVjdCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBsaXRlcmFsLCBpLmUuIGEgc3RyaW5nIG9yIG51bWJlci5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5X3BhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2VzLnB1c2goXCJZQU1MIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicgZ2l2ZXMgYWxyZWFkeSBhIGxpdGVyYWwgdmFsdWUgJ1wiICsgcHJvcGVydHlfdmFsdWUudG9TdHJpbmcoKSArIFwiJywgYnV0IHRoZSBhcmd1bWVudCAnXCIgKyBwcm9wZXJ0eV9wYXRoICsgXCInIGFzc3VtZXMgdGhlIHByb3BlcnR5IHdvdWxkIGNvbnRhaW4gYSBuZXN0ZWQgZWxlbWVudCB3aXRoIHRoZSBrZXkgJ1wiICsgcHJvcGVydHlfcGFydHNbMF0gKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yX21lc3NhZ2VzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5X3ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGaWxlVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldEZpbGUoKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudF9maWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoIWN1cnJlbnRfZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudF9maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gd2hlbiB0aGUgYWN0aXZlIHBhbmUgY29udGFpbnMgYSBmaWxlLCBub3QgaW4gZ3JhcGggdmlldyBvciBvdGhlciBub24tZmlsZSB2aWV3LlwiO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtJUGFyYW1ldGVyc30gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcbmltcG9ydCB7Z2V0RmlsZUV4dGVuc2lvbn0gZnJvbSBcIi4vVmFyaWFibGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9GaWxlRXh0ZW5zaW9uIGV4dGVuZHMgRmlsZVZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZmlsZV9leHRlbnNpb25cIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlIG5hbWUncyBlbmRpbmcuIFVzZSB7e2ZpbGVfZXh0ZW5zaW9uOndpdGgtZG90fX0gdG8gaW5jbHVkZSBhIHByZWNlZGluZyBkb3QuIElmIHRoZSBleHRlbnNpb24gaXMgZW1wdHksIG5vIGRvdCBpcyBhZGRlZC4ge3tmaWxlX2V4dGVuc2lvbjpuby1kb3R9fSBuZXZlciBpbmNsdWRlcyBhIGRvdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIFwiZG90XCI6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wid2l0aC1kb3RcIiwgXCJuby1kb3RcIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBcImRvdFwiOiBcIndpdGgtZG90XCIgfCBcIm5vLWRvdFwiLFxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnZXRGaWxlRXh0ZW5zaW9uKGZpbGUsIHRoaXMuYXJndW1lbnRzLmRvdCA9PT0gXCJ3aXRoLWRvdFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpuby1kb3R9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBjdXJyZW50IGZpbGUgbmFtZSdzIGVuZGluZyB3aXRob3V0IGEgcHJlY2VkaW5nIGRvdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjp3aXRoLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGggYSBwcmVjZWRpbmcgZG90LiBJZiB0aGUgZXh0ZW5zaW9uIGlzIGVtcHR5LCBubyBkb3QgaXMgaW5jbHVkZWQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOm5vLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGhvdXQgYSBwcmVjZWRpbmcgZG90LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjp3aXRoLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGggYSBwcmVjZWRpbmcgZG90LiBJZiB0aGUgZXh0ZW5zaW9uIGlzIGVtcHR5LCBubyBkb3QgaXMgaW5jbHVkZWQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7ZmlsZV9leHRlbnNpb246d2l0aC1kb3R9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7ZmlsZV9leHRlbnNpb246bm8tZG90fX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsImltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9GaWxlTmFtZSBleHRlbmRzIEZpbGVWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHZhcmlhYmxlX25hbWUgPSBcImZpbGVfbmFtZVwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSBjdXJyZW50IGZpbGUgbmFtZSB3aXRoIGEgZmlsZSBleHRlbnNpb24uIElmIHlvdSBuZWVkIGl0IHdpdGhvdXQgdGhlIGV4dGVuc2lvbiwgdXNlIHt7dGl0bGV9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZSgpO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbGUubmFtZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7SUF1dG9jb21wbGV0ZUl0ZW19IGZyb20gXCIuLi9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZVwiO1xyXG5pbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0RmlsZVBhdGh9IGZyb20gXCIuL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0ZpbGVQYXRoIGV4dGVuZHMgRmlsZVZhcmlhYmxle1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJmaWxlX3BhdGhcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBtb2RlOiB7XHJcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcImFic29sdXRlXCIsIFwicmVsYXRpdmVcIl0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBcImFic29sdXRlXCIgfCBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nfG51bGwge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZV9maWxlID0gdGhpcy5nZXRGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRGaWxlUGF0aCh0aGlzLmFwcCwgYWN0aXZlX2ZpbGUsIHRoaXMuYXJndW1lbnRzLm1vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlLCBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2ZpbGVfcGF0aDpyZWxhdGl2ZX19PC9zdHJvbmc+IG9yIDxzdHJvbmc+e3tmaWxlX3BhdGg6YWJzb2x1dGV9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtGaWxlVmFyaWFibGV9IGZyb20gXCIuL0ZpbGVWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZvbGRlclZhcmlhYmxlIGV4dGVuZHMgRmlsZVZhcmlhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0Rm9sZGVyKCkge1xyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyLlxyXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRfZm9sZGVyID0gZmlsZS5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50X2ZvbGRlcikge1xyXG4gICAgICAgICAgICAvLyBObyBwYXJlbnQgZm9sZGVyLlxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIlRoZSBjdXJyZW50IGZpbGUgZG9lcyBub3QgaGF2ZSBhIHBhcmVudCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbi5cIilcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50X2ZvbGRlcjtcclxuICAgIH1cclxufSIsImltcG9ydCB7Rm9sZGVyVmFyaWFibGV9IGZyb20gXCIuL0ZvbGRlclZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRm9sZGVyTmFtZSBleHRlbmRzIEZvbGRlclZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZm9sZGVyX25hbWVcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciBuYW1lLiBObyBhbmNlc3RvciBmb2xkZXJzIGFyZSBpbmNsdWRlZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyKCk7XHJcbiAgICAgICAgaWYgKCFmb2xkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb2xkZXIubmFtZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7SUF1dG9jb21wbGV0ZUl0ZW19IGZyb20gXCIuLi9zZXR0aW5ncy9zZXR0aW5nX2VsZW1lbnRzL0F1dG9jb21wbGV0ZVwiO1xyXG5pbXBvcnQge0ZvbGRlclZhcmlhYmxlfSBmcm9tIFwiLi9Gb2xkZXJWYXJpYWJsZVwiO1xyXG5pbXBvcnQge2dldEZvbGRlclBhdGh9IGZyb20gXCIuL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX0ZvbGRlclBhdGggZXh0ZW5kcyBGb2xkZXJWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHZhcmlhYmxlX25hbWUgPSBcImZvbGRlcl9wYXRoXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciwgZWl0aGVyIGFzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLCBvciBhcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIG1vZGU6IHtcclxuICAgICAgICAgICAgb3B0aW9uczogW1wiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgbW9kZTogXCJhYnNvbHV0ZVwiIHwgXCJyZWxhdGl2ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZ3xudWxsIHtcclxuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmdldEZvbGRlcigpO1xyXG4gICAgICAgIGlmIChmb2xkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZvbGRlclBhdGgodGhpcy5hcHAsIGZvbGRlciwgdGhpcy5hcmd1bWVudHMubW9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QXV0b2NvbXBsZXRlSXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyLCBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciwgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBVbmVzY2FwZWQgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOmFic29sdXRlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyLCBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbS4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSdzIHBhcmVudCBmb2xkZXIsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2ZvbGRlcl9wYXRoOnJlbGF0aXZlfX08L3N0cm9uZz4gb3IgPHN0cm9uZz57e2ZvbGRlcl9wYXRoOmFic29sdXRlfX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsImltcG9ydCB7Z2V0RWRpdG9yLCBnZXRWaWV3fSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1NlbGVjdGlvbiBleHRlbmRzIFZhcmlhYmxle1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJzZWxlY3Rpb25cIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgYWJsZSB0byBnZXQgYSB2aWV3XHJcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFZpZXcodGhpcy5hcHApO1xyXG4gICAgICAgIGlmIChudWxsID09PSB2aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIE5vcGUuXHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiQ291bGQgbm90IGdldCBhIHZpZXcgaW5zdGFuY2UhIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBpbiBHaXRIdWIuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgd2UgYXJlIGFibGUgdG8gZ2V0IGFuIGVkaXRvclxyXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcCk7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IGVkaXRvcikge1xyXG4gICAgICAgICAgICAvLyBOb3BlLlxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlISBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGUgdmlldyBtb2RlXHJcbiAgICAgICAgY29uc3Qgdmlld19tb2RlID0gdmlldy5nZXRNb2RlKCk7IC8vIFwicHJldmlld1wiIG9yIFwic291cmNlXCIgKGNhbiBhbHNvIGJlIFwibGl2ZVwiIGJ1dCBJIGRvbid0IGtub3cgd2hlbiB0aGF0IGhhcHBlbnMpXHJcbiAgICAgICAgc3dpdGNoICh2aWV3X21vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInByZXZpZXdcIjpcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBsZWFmIGlzIGluIHByZXZpZXcgbW9kZSwgd2hpY2ggbWFrZXMgdGhpbmdzIGRpZmZpY3VsdC5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHN0aWxsIHJldHVybiB2aWV3LmVkaXRvciwgYnV0IGl0IGRvZXMgbm90IHdvcmsgYXQgbGVhc3QgZm9yIGdldHRpbmcgc2VsZWN0ZWQgdGV4dCwgbWF5YmUgZm9yIG90aGVyIHRoaW5ncywgYnV0IGN1cnJlbnRseSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBmb3IgZ2V0dGluZyBzZWxlY3RlZCB0ZXh0LlxyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBtb21lbnQsIGp1c3QgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgdGhhdCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIG9mZmVyIGFuIGVkaXRvciBpbnN0YW5jZSB3aGljaCBjb3VsZCB3b3JrIHJlbGlhYmx5IG9uIHRleHQgc2VsZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBNYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSB0aGlzIGZlYXR1cmUgYWxzbyBpbiBwcmV2aWV3IG1vZGUuXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIlNoZWxsQ29tbWFuZFZhcmlhYmxlX1NlbGVjdGlvbjogJ3ZpZXcnIGlzIGluIHByZXZpZXcgbW9kZSwgYW5kIHRoZSBwb29yIGd1eSB3aG8gd3JvdGUgdGhpcyBjb2RlLCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXR1cm4gYW4gZWRpdG9yIGluc3RhbmNlIHRoYXQgY291bGQgYmUgdXNlZCBmb3IgZ2V0dGluZyB0ZXh0IHNlbGVjdGlvbi5cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIllvdSBuZWVkIHRvIHR1cm4gZWRpdGluZyBtb2RlIG9uLCBhcyBJJ20gbm90IGFibGUgdG8gZ2V0IHNlbGVjdGVkIHRleHQgd2hlbiBpbiBwcmV2aWV3IG1vZGUuIEJsYW1lIHRoZSBvbmUgd2hvIGRldmVsb3BlZCB0aGlzIHBsdWdpbiEgVGhpcyBzaG91bGQgYmUgZml4ZWQgaW4gdGhlIGZ1dHVyZS5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxyXG4gICAgICAgICAgICAgICAgLy8gR29vZCwgdGhlIGVkaXRvciBpcyBpbiBcInNvdXJjZVwiIG1vZGUsIHNvIGl0J3MgcG9zc2libGUgdG8gZ2V0IGEgc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgRXJyb3IoXCJTaGVsbENvbW1hbmRWYXJpYWJsZV9TZWxlY3Rpb246IFVucmVjb2duaXNlZCB2aWV3IG1vZGU6IFwiK3ZpZXdfbW9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz5Pbmx5IGF2YWlsYWJsZTwvc3Ryb25nPiBpbiA8ZW0+RWRpdGluZzwvZW0+LzxlbT5MaXZlIHByZXZpZXc8L2VtPiBtb2RlLCA8c3Ryb25nPm5vdDwvc3Ryb25nPiBpbiA8ZW0+UmVhZGluZzwvZW0+IG1vZGUuXCI7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0RmlsZVRhZ3N9IGZyb20gXCIuL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1RhZ3MgZXh0ZW5kcyBGaWxlVmFyaWFibGUge1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJ0YWdzXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgYWxsIHRhZ3MgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBub3RlLiBSZXBsYWNlIHRoZSBcXFwic2VwYXJhdG9yXFxcIiBwYXJ0IHdpdGggYSBjb21tYSwgc3BhY2Ugb3Igd2hhdGV2ZXIgY2hhcmFjdGVycyB5b3Ugd2FudCB0byB1c2UgYXMgYSBzZXBhcmF0b3IgYmV0d2VlbiB0YWdzLiBBIHNlcGFyYXRvciBpcyBhbHdheXMgbmVlZGVkIHRvIGJlIGRlZmluZWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBzZXBhcmF0b3I6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiBzdHJpbmcsXHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICBpZiAoYWN0aXZlX2ZpbGUpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG8gaGF2ZSBhbiBhY3RpdmUgZmlsZVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZVRhZ3ModGhpcy5hcHAsIGFjdGl2ZV9maWxlKS5qb2luKHRoaXMuYXJndW1lbnRzLnNlcGFyYXRvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gZmlsZSBpcyBhY3RpdmUgYXQgdGhlIG1vbWVudFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge0ZpbGVWYXJpYWJsZX0gZnJvbSBcIi4vRmlsZVZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfVGl0bGUgZXh0ZW5kcyBGaWxlVmFyaWFibGV7XHJcbiAgICBwdWJsaWMgc3RhdGljIHZhcmlhYmxlX25hbWUgPSBcInRpdGxlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lIHdpdGhvdXQgYSBmaWxlIGV4dGVuc2lvbi4gSWYgeW91IG5lZWQgaXQgd2l0aCB0aGUgZXh0ZW5zaW9uLCB1c2Uge3tmaWxlX25hbWV9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlX2ZpbGUgPSB0aGlzLmdldEZpbGUoKTtcclxuICAgICAgICBpZiAoYWN0aXZlX2ZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZV9maWxlLmJhc2VuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSIsImltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGh9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9WYXVsdFBhdGggZXh0ZW5kcyBWYXJpYWJsZXtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwidmF1bHRfcGF0aFwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBoZWxwX3RleHQgPSBcIkdpdmVzIHRoZSBPYnNpZGlhbiB2YXVsdCdzIGFic29sdXRlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZXN5c3RlbS4gVGhpcyBpcyB0aGUgc2FtZSB0aGF0IGlzIHVzZWQgYXMgYSBkZWZhdWx0IHdvcmtpbmcgZGlyZWN0b3J5IGlmIHlvdSBkbyBub3QgZGVmaW5lIG9uZSBtYW51YWxseS4gSWYgeW91IGRlZmluZSBhIHdvcmtpbmcgZGlyZWN0b3J5IG1hbnVhbGx5LCB0aGlzIHZhcmlhYmxlIHdvbid0IGdpdmUgeW91IHlvdXIgbWFudWFsbHkgZGVmaW5lZCBkaXJlY3RvcnksIGl0IGFsd2F5cyBnaXZlcyB0aGUgdmF1bHQncyByb290IGRpcmVjdG9yeS5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBnZXRWYXVsdEFic29sdXRlUGF0aCh0aGlzLmFwcCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZhcmlhYmxlX1dvcmtzcGFjZSBleHRlbmRzIFZhcmlhYmxle1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJ3b3Jrc3BhY2VcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgY3VycmVudCB3b3Jrc3BhY2UncyBuYW1lLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZW5lcmF0ZVZhbHVlKCk6IHN0cmluZyB7XHJcblxyXG4gICAgICAgIC8vIElkZWEgaG93IHRvIGFjY2VzcyB0aGUgd29ya3NwYWNlcyBwbHVnaW4gaXMgY29waWVkIDIwMjEtMDktMTUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vVmluemVudDAzL29ic2lkaWFuLWFkdmFuY2VkLXVyaS9ibG9iL2Y3ZWY4MGQ1MjUyNDgxMjQyZTY5NDk2MjA4ZTkyNTg3NDIwOWY0YWEvbWFpbi50cyNMMTY4LUwxNzlcclxuICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsUGx1Z2lucyBleGlzdHMgYWx0aG91Z2ggaXQncyBub3QgaW4gb2JzaWRpYW4uZC50cy5cclxuICAgICAgICBjb25zdCB3b3Jrc3BhY2VzX3BsdWdpbiA9IHRoaXMuYXBwLmludGVybmFsUGx1Z2lucz8ucGx1Z2lucz8ud29ya3NwYWNlcztcclxuICAgICAgICBpZiAoIXdvcmtzcGFjZXNfcGx1Z2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiV29ya3NwYWNlcyBjb3JlIHBsdWdpbiBpcyBub3QgZm91bmQgZm9yIHNvbWUgcmVhc29uLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXdvcmtzcGFjZXNfcGx1Z2luLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJXb3Jrc3BhY2VzIGNvcmUgcGx1Z2luIGlzIG5vdCBlbmFibGVkLlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHdvcmtzcGFjZV9uYW1lID0gd29ya3NwYWNlc19wbHVnaW4uaW5zdGFuY2U/LmFjdGl2ZVdvcmtzcGFjZTtcclxuICAgICAgICBpZiAoIXdvcmtzcGFjZV9uYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiQ291bGQgbm90IGZpZ3VyZSBvdXQgdGhlIGN1cnJlbnQgd29ya3NwYWNlJ3MgbmFtZS4gUHJvYmFibHkgeW91IGhhdmUgbm90IGxvYWRlZCBhIHdvcmtzcGFjZS4gWW91IGNhbiBkbyBpdCBlLmcuIHZpYSBcXFwiTWFuYWdlIHdvcmtzcGFjZXNcXFwiIGZyb20gdGhlIGxlZnQgc2lkZSBwYW5lbC5cIilcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGwgb2tcclxuICAgICAgICByZXR1cm4gd29ya3NwYWNlX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz5Pbmx5IGF2YWlsYWJsZTwvc3Ryb25nPiB3aGVuIHRoZSBXb3Jrc3BhY2VzIGNvcmUgcGx1Z2luIGlzIGVuYWJsZWQuXCI7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge0lQYXJhbWV0ZXJzLCBWYXJpYWJsZX0gZnJvbSBcIi4vVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9QYXNzdGhyb3VnaCBleHRlbmRzIFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwicGFzc3Rocm91Z2hcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgc2FtZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gVXNlZCBmb3IgdGVzdGluZyBzcGVjaWFsIGNoYXJhY3RlcnMnIGVzY2FwaW5nLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgdmFsdWU6IHN0cmluZyxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICAvLyBTaW1wbHkgcmV0dXJuIHRoZSBhcmd1bWVudCB0aGF0IHdhcyByZWNlaXZlZC5cclxuICAgICAgICByZXR1cm4gdGhpcy5hcmd1bWVudHMudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBdmFpbGFiaWxpdHlUZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gaW4gZGVidWcgbW9kZS5cIjtcclxuICAgIH1cclxufSIsImltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7RmlsZVZhcmlhYmxlfSBmcm9tIFwiLi9GaWxlVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGaWxlWUFNTFZhbHVlfSBmcm9tIFwiLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9ZQU1MVmFsdWUgZXh0ZW5kcyBGaWxlVmFyaWFibGUge1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJ5YW1sX3ZhbHVlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiUmVhZHMgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBmaWxlJ3MgZnJvbnRtYXR0ZXIuIFRha2VzIGEgcHJvcGVydHkgbmFtZSBhcyBhbiBhcmd1bWVudC4gWW91IGNhbiBhY2Nlc3MgbmVzdGVkIHByb3BlcnRpZXMgd2l0aCBkb3Qgbm90YXRpb246IHByb3BlcnR5MS5wcm9wZXJ0eTJcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IHBhcmFtZXRlcnM6IElQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgIHByb3BlcnR5X25hbWU6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIHByb3BlcnR5X25hbWU6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZV9maWxlID0gdGhpcy5nZXRGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvIGhhdmUgYW4gYWN0aXZlIGZpbGVcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0RmlsZVlBTUxWYWx1ZSh0aGlzLmFwcCwgYWN0aXZlX2ZpbGUsIHRoaXMuYXJndW1lbnRzLnByb3BlcnR5X25hbWUpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGNvbnRhaW5zIGVycm9yIG1lc3NhZ2UocykuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZXMocmVzdWx0IGFzIHN0cmluZ1tdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvaywgaXQncyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gZmlsZSBpcyBhY3RpdmUgYXQgdGhlIG1vbWVudFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4uL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEV2ZW50VmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHNjX2V2ZW50IGlzIG5vdCBzZXQsIHRoZW4gdGhlIHZhcmlhYmxlIGlzIHRyaWVkIHRvIGJlIHJlYWQgaW4gYSBzaXR1YXRpb24gd2hlcmUgbm8gZXZlbnQgaGFzIGhhcHBlbmVkIC0gd2hpY2ggc2hvdWxkIGJlIGRlbmllZC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNjX2V2ZW50PzogU0NfRXZlbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAYWJzdHJhY3QgU2hvdWxkIGJlIGFic3RyYWN0LCBidXQgY2Fubm90IG1hcmsgaXMgYXMgYWJzdHJhY3QgYmVjYXVzZSBpdCdzIGFsc28gc3RhdGljLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHN1cHBvcnRlZF9zY19ldmVudHM6IHR5cGVvZiBTQ19FdmVudFtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGw6IHN0cmluZywgc2NfZXZlbnQ6IFNDX0V2ZW50KSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luLCBzaGVsbCk7XHJcbiAgICAgICAgdGhpcy5zY19ldmVudCA9IHNjX2V2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZlcnkgc3ViY2xhc3Mgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgaW4gdGhlaXIgZ2VuZXJhdGVWYWx1ZSgpIGJlZm9yZSByZXR1cm5pbmcgYSB2YWx1ZS4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZSxcclxuICAgICAqIHRoZW4gYSB2YXJpYWJsZSBzaG91bGQgbm90IGdlbmVyYXRlIGEgdmFsdWUsIGFzIHRoZSBkZXBlbmRlbnQgU0NfRXZlbnQgaXMgdW5hdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETzogQ2hhbmdlIHRoZSBlcnJvciBzeXN0ZW0gdG8gdGhyb3cgZXhjZXB0aW9ucyBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gcmV0dXJuIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjaGVja1NDX0V2ZW50U3VwcG9ydCgpOiBib29sZWFue1xyXG4gICAgICAgIC8vIDEuIENoZWNrIGdlbmVyYWxseSB0aGF0IGFuIGV2ZW50IGlzIGhhcHBlbmluZy5cclxuICAgICAgICBpZiAoIXRoaXMuc2NfZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJUaGlzIHZhcmlhYmxlIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV2ZW50czogXCIgKyB0aGlzLnN0YXRpYygpLmdldFN1bW1hcnlPZlN1cHBvcnRlZEV2ZW50cygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4gQ2hlY2sgcGFydGljdWxhcmx5IHdoaWNoIGV2ZW50IGl0IGlzLlxyXG4gICAgICAgIGlmICghdGhpcy5zdGF0aWMoKS5zdXBwb3J0c1NDX0V2ZW50KHRoaXMuc2NfZXZlbnQuZ2V0Q2xhc3MoKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJUaGlzIHZhcmlhYmxlIGRvZXMgbm90IHN1cHBvcnQgZXZlbnQgJ1wiICsgdGhpcy5zY19ldmVudC5zdGF0aWMoKS5nZXRUaXRsZSgpICsgXCInLiBTdXBwb3J0ZWQgZXZlbnRzOiBcIiArIHRoaXMuc3RhdGljKCkuZ2V0U3VtbWFyeU9mU3VwcG9ydGVkRXZlbnRzKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc3VwcG9ydHNTQ19FdmVudChzY19ldmVudF9jbGFzczogdHlwZW9mIFNDX0V2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkX3NjX2V2ZW50cy5jb250YWlucyhzY19ldmVudF9jbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3VtbWFyeU9mU3VwcG9ydGVkRXZlbnRzKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgc2NfZXZlbnRfdGl0bGVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydGVkX3NjX2V2ZW50cy5mb3JFYWNoKChzY19ldmVudF9jbGFzczogdHlwZW9mIFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHNjX2V2ZW50X3RpdGxlcy5wdXNoKHNjX2V2ZW50X2NsYXNzLmdldFRpdGxlKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzY19ldmVudF90aXRsZXMuam9pbihcIiwgXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QXZhaWxhYmlsaXR5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+T25seSBhdmFpbGFibGU8L3N0cm9uZz4gaW4gZXZlbnRzOiBcIiArIHRoaXMuZ2V0U3VtbWFyeU9mU3VwcG9ydGVkRXZlbnRzKCkgKyBcIi5cIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljKCk6IGFueSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIEV2ZW50VmFyaWFibGU7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgY29uc3QgRG9jdW1lbnRhdGlvbk1haW5MaW5rID0gXCJodHRwczovL3B1Ymxpc2gub2JzaWRpYW4ubWQvc2hlbGxjb21tYW5kc1wiO1xyXG5leHBvcnQgY29uc3QgRG9jdW1lbnRhdGlvblZhcmlhYmxlc0xpbmsgPSBcImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC9zaGVsbGNvbW1hbmRzL1ZhcmlhYmxlcy9WYXJpYWJsZXMrLStnZW5lcmFsK3ByaW5jaXBsZXMjQWxsK3ZhcmlhYmxlc1wiO1xyXG5leHBvcnQgY29uc3QgRG9jdW1lbnRhdGlvbkF1dG9jb21wbGV0ZUxpbmsgPSBcImh0dHBzOi8vcHVibGlzaC5vYnNpZGlhbi5tZC9zaGVsbGNvbW1hbmRzL1ZhcmlhYmxlcy9BdXRvY29tcGxldGUvQXV0b2NvbXBsZXRlXCI7XHJcbmV4cG9ydCBjb25zdCBEb2N1bWVudGF0aW9uRXZlbnRzRm9sZGVyTGluayA9IFwiaHR0cHM6Ly9wdWJsaXNoLm9ic2lkaWFuLm1kL3NoZWxsY29tbWFuZHMvRXZlbnRzL1wiO1xyXG5leHBvcnQgY29uc3QgR2l0SHViTGluayA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvb2JzaWRpYW4tc2hlbGxjb21tYW5kc1wiO1xyXG5leHBvcnQgY29uc3QgQ2hhbmdlbG9nTGluayA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RhaXRhdmEvb2JzaWRpYW4tc2hlbGxjb21tYW5kcy9ibG9iL21haW4vQ0hBTkdFTE9HLm1kXCI7IiwiaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge0FwcCwgRXZlbnRSZWZ9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge1BhcnNpbmdSZXN1bHQsIFRTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9TQ19FdmVudENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHtjbG9uZU9iamVjdH0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi4vdmFyaWFibGVzL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0VmFyaWFibGVzfSBmcm9tIFwiLi4vdmFyaWFibGVzL1ZhcmlhYmxlTGlzdHNcIjtcclxuaW1wb3J0IHtFdmVudFZhcmlhYmxlfSBmcm9tIFwiLi4vdmFyaWFibGVzL2V2ZW50X3ZhcmlhYmxlcy9FdmVudFZhcmlhYmxlXCI7XHJcbmltcG9ydCB7RG9jdW1lbnRhdGlvbkV2ZW50c0ZvbGRlckxpbmt9IGZyb20gXCIuLi9Eb2N1bWVudGF0aW9uXCI7XHJcblxyXG4vKipcclxuICogTmFtZWQgU0NfRXZlbnQgaW5zdGVhZCBvZiBqdXN0IEV2ZW50LCBiZWNhdXNlIEV2ZW50IGlzIGEgY2xhc3MgaW4gSmF2YVNjcmlwdC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTQ19FdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGx1Z2luOiBTQ19QbHVnaW47XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYXBwOiBBcHA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAYWJzdHJhY3QgU2hvdWxkIGJlIGFic3RyYWN0LCBidXQgY2Fubm90IG1hcmsgaXMgYXMgYWJzdHJhY3QgYmVjYXVzZSBpdCdzIGFsc28gc3RhdGljLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBhYnN0cmFjdCBTaG91bGQgYmUgYWJzdHJhY3QsIGJ1dCBjYW5ub3QgbWFyayBpcyBhcyBhYnN0cmFjdCBiZWNhdXNlIGl0J3MgYWxzbyBzdGF0aWMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUsIGNoYW5naW5nIHRoZSBlbmFibGVkL2Rpc2FibGVkIHN0YXR1cyBvZiB0aGUgZXZlbnQgcGVybWl0cyByZWdpc3RlcmluZyB0aGUgZXZlbnQgaW1tZWRpYXRlbHksIHNvIGl0IGNhbiBhY3RpdmF0ZVxyXG4gICAgICogYW55dGltZS4gVXN1YWxseSB0cnVlLCBidXQgY2FuIGJlIHNldCB0byBmYWxzZSBpZiBpbW1lZGlhdGUgcmVnaXN0ZXJpbmcgdGVuZHMgdG8gdHJpZ2dlciB0aGUgZXZlbnQgdW5uZWNlc3NhcmlseS5cclxuICAgICAqXHJcbiAgICAgKiBFdmVudHMgYXJlIGFsd2F5cyByZWdpc3RlcmVkIHdoZW4gbG9hZGluZyB0aGUgcGx1Z2luLCByZWdhcmRsZXNzIG9mIHRoaXMgcHJvcGVydHkuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZWdpc3Rlcl9hZnRlcl9jaGFuZ2luZ19zZXR0aW5ncyA9IHRydWU7XHJcblxyXG4gICAgcHJpdmF0ZSBldmVudF9yZWdpc3RyYXRpb25zOiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogRXZlbnRSZWYsIC8vIGtleTogdF9zaGVsbF9jb21tYW5kIGlkXHJcbiAgICB9ID0ge307XHJcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdF9jb25maWd1cmF0aW9uOiBTQ19FdmVudENvbmZpZ3VyYXRpb24gPSB7XHJcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJjbGFzc19pbnN0YW5jZSA9IHRoaXM7IC8vIFN0b3JlcyBhIHN1YmNsYXNzIHJlZmVyZW5jZSwgbm90IGEgYmFzZSBjbGFzcyByZWZlcmVuY2UuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWlucyBhIHZlcnNpb24gb2YgJ3RoaXMnIHZhcmlhYmxlIHRoYXQgcmVmZXJzIHRvIHRoZSBhY3R1YWwgc3ViY2xhc3MsIG5vdCB0aGlzIGJhc2UgY2xhc3MuXHJcbiAgICAgKiBUT0RPOiBQZXJoYXBzIG1vdmUgdG8gYSBuZXcgY2xhc3MgdGhhdCB3aWxsIGJlY29tZSBhIHBhcmVudCBvZiB0aGlzIGNsYXNzP1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdWJjbGFzc19pbnN0YW5jZTogdGhpcztcclxuICAgIHB1YmxpYyBnZXRDbGFzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJjbGFzc19pbnN0YW5jZS5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU0NfRXZlbnRcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2FuUmVnaXN0ZXJBZnRlckNoYW5naW5nU2V0dGluZ3MoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50X3JlZmVyZW5jZSA9IHRoaXMuX3JlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgaWYgKGV2ZW50X3JlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KGV2ZW50X3JlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRfcmVnaXN0cmF0aW9uc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0gPSBldmVudF9yZWZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIEV2ZW50UmVmIGlzIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLmV2ZW50X3JlZ2lzdHJhdGlvbnNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBldmVudCB3YXMgcmVnaXN0ZXJlZCB3aXRob3V0IGFuIEV2ZW50UmVmIG9iamVjdC5cclxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIFRTaGVsbENvbW1hbmQgdG8gX3VucmVnaXN0ZXIoKSBzbyBpdCBjYW4gZG8gYSBjdXN0b20gdW5yZWdpc3RlcmluZy5cclxuICAgICAgICAgICAgdGhpcy5fdW5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBldmVudCByZWdpc3RyYXRpb24gaGFkIGNyZWF0ZWQgYW4gRXZlbnRSZWYgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBFdmVudFJlZiB0byBfdW5yZWdpc3RlcigpIGFuZCBmb3JnZXQgaXQgYWZ0ZXJ3YXJkcy5cclxuICAgICAgICAgICAgdGhpcy5fdW5yZWdpc3Rlcih0aGlzLmV2ZW50X3JlZ2lzdHJhdGlvbnNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRfcmVnaXN0cmF0aW9uc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBfcmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogZmFsc2UgfCBFdmVudFJlZjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3VucmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBfdW5yZWdpc3RlcihldmVudF9yZWZlcmVuY2U6IEV2ZW50UmVmKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIGEgc2hlbGwgY29tbWFuZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHRyaWdnZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLCBwYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHZhcmlhYmxlcyBhcmUgbm90IHlldCBwYXJzZWQuIChUaGV5IG1pZ2h0IGJlIHBhcnNlZCBhbHJlYWR5IGJ5IFNDX01lbnVFdmVudCkuXHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcGFyc2luZ19yZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8gTm8gcHJlcGFyc2VkIHNoZWxsIGNvbW1hbmQgZXhpc3RzLCBzbyBwYXJzZSBub3cuXHJcbiAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0ID0gdF9zaGVsbF9jb21tYW5kLnBhcnNlVmFyaWFibGVzKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHBhcnNpbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICBpZiAoIXBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRXJyb3JzIG9jY3VycmVkIHdoZW4gcGFyc2luZyB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcnMocGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBzaGVsbCBjb21tYW5kLlxyXG4gICAgICAgIHRoaXMucGx1Z2luLmNvbmZpcm1BbmRFeGVjdXRlU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZCwgcGFyc2luZ19yZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudF9jb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGl0bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRfdGl0bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gc2hlbGwgTmVlZGVkIGp1c3QgZm9yIGJlaW5nIGFibGUgdG8gaW5zdGFudGlhdGUgdmFyaWFibGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U3VtbWFyeU9mRXZlbnRWYXJpYWJsZXMoc2hlbGw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgdmFyaWFibGVfbmFtZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFZhcmlhYmxlcyhzaGVsbCkuZm9yRWFjaCgodmFyaWFibGU6IFZhcmlhYmxlKSA9PiB7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlX25hbWVzLnB1c2goXCJ7e1wiICsgdmFyaWFibGUuZ2V0VmFyaWFibGVOYW1lKCkgKyBcIn19XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2YXJpYWJsZV9uYW1lcy5qb2luKFwiLCBcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRFdmVudFZhcmlhYmxlcyhzaGVsbDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRfdmFyaWFibGVzOiBFdmVudFZhcmlhYmxlW10gPSBbXTtcclxuICAgICAgICBnZXRWYXJpYWJsZXModGhpcy5wbHVnaW4sIHNoZWxsKS5mb3JFYWNoKCh2YXJpYWJsZTogVmFyaWFibGUpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhcmlhYmxlIGlzIGFuIEV2ZW50VmFyaWFibGVcclxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgRXZlbnRWYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gWWVzIGl0IGlzLlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhcmlhYmxlIHN1cHBvcnRzIHRoaXMgcGFydGljdWxhciBldmVudC5cclxuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5zdGF0aWMoKS5zdXBwb3J0c1NDX0V2ZW50KHRoaXMuZ2V0Q2xhc3MoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBZZXMgaXQgc3VwcG9ydHMuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRfdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50X3ZhcmlhYmxlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBvdmVycmlkZGVuIGluIGNoaWxkIGNsYXNzZXMgdGhhdCBuZWVkIGN1c3RvbSBzZXR0aW5ncyBmaWVsZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVuYWJsZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERlZmF1bHRDb25maWd1cmF0aW9uKGVuYWJsZWQ6IGJvb2xlYW4pOiBTQ19FdmVudENvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjbG9uZU9iamVjdCh0aGlzLmRlZmF1bHRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgY29uZmlndXJhdGlvbi5lbmFibGVkID0gZW5hYmxlZDtcclxuICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvblxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiB0X3NoZWxsX2NvbW1hbmQuZ2V0RXZlbnRDb25maWd1cmF0aW9uKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIG92ZXJyaWRkZW4gaW4gY2hpbGQgY2xhc3NlcyB0byBwcm92aWRlIGN1c3RvbSBjb25maWd1cmF0aW9uIGZpZWxkcyBmb3IgU2hlbGxDb21tYW5kc0V4dHJhT3B0aW9uc01vZGFsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBleHRyYV9zZXR0aW5nc19jb250YWluZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZUV4dHJhU2V0dGluZ3NGaWVsZHMoZXh0cmFfc2V0dGluZ3NfY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKTogdm9pZCB7XHJcbiAgICAgICAgLy8gTW9zdCBjbGFzc2VzIGRvIG5vdCBkZWZpbmUgY3VzdG9tIHNldHRpbmdzLCBzbyBmb3IgdGhvc2UgY2xhc3NlcyB0aGlzIG1ldGhvZCBkb2VzIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIFRTaGVsbENvbW1hbmQgaW5zdGFuY2VzIHRoYXQgaGF2ZSBlbmFibGVkIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUU2hlbGxDb21tYW5kcygpOiBUU2hlbGxDb21tYW5kW10ge1xyXG4gICAgICAgIGNvbnN0IGVuYWJsZWRfdF9zaGVsbF9jb21tYW5kczogVFNoZWxsQ29tbWFuZFtdID0gW107XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpKS5mb3JFYWNoKCh0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBldmVudCBoYXMgYmVlbiBlbmFibGVkIGZvciB0aGUgc2hlbGwgY29tbWFuZC5cclxuICAgICAgICAgICAgaWYgKHRfc2hlbGxfY29tbWFuZC5pc1NDX0V2ZW50RW5hYmxlZCh0aGlzLnN0YXRpYygpLmV2ZW50X2NvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBZZXMsIGl0J3MgZW5hYmxlZC5cclxuICAgICAgICAgICAgICAgIGVuYWJsZWRfdF9zaGVsbF9jb21tYW5kcy5wdXNoKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFNDX0V2ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hpbGQgY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBob29rIGludG8gYSBzaXR1YXRpb24gd2hlcmUgYSB1c2VyIGhhcyBlbmFibGVkIGFuIGV2ZW50IGluIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmQgVGhlIFRTaGVsbENvbW1hbmQgaW5zdGFuY2UgZm9yIHdoaWNoIHRoaXMgU0NfRXZlbnQgd2FzIGVuYWJsZWQgZm9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25BZnRlckVuYWJsaW5nKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCk6IHZvaWQge1xyXG4gICAgICAgIC8vIElmIGFuIFNDX0V2ZW50IGRvZXMgbm90IG92ZXJyaWRlIHRoaXMgaG9vayBtZXRob2QsIGRvIG5vdGhpbmcuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXREb2N1bWVudGF0aW9uTGluaygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBEb2N1bWVudGF0aW9uRXZlbnRzRm9sZGVyTGluayArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmV2ZW50X3RpdGxlKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtFdmVudFJlZn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU0NfV29ya3NwYWNlRXZlbnQgZXh0ZW5kcyBTQ19FdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgd29ya3NwYWNlX2V2ZW50OlxyXG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSB3YXkgdG8gbWFrZSB0aGlzIGxpc3QgZHluYW1pYy5cclxuICAgICAgICAvLyBUaGlzIGxpc3QgcmVmbGVjdHMgT2JzaWRpYW4gQVBJIHZlcnNpb24gMC4xMi4xMS5cclxuICAgICAgICB8ICdxdWljay1wcmV2aWV3J1xyXG4gICAgICAgIHwgJ3Jlc2l6ZSdcclxuICAgICAgICB8ICdjbGljaydcclxuICAgICAgICB8ICdhY3RpdmUtbGVhZi1jaGFuZ2UnXHJcbiAgICAgICAgfCAnZmlsZS1vcGVuJ1xyXG4gICAgICAgIHwgJ2xheW91dC1jaGFuZ2UnXHJcbiAgICAgICAgfCAnY3NzLWNoYW5nZSdcclxuICAgICAgICB8ICdmaWxlLW1lbnUnXHJcbiAgICAgICAgfCAnZWRpdG9yLW1lbnUnXHJcbiAgICAgICAgfCAnY29kZW1pcnJvcidcclxuICAgICAgICB8ICdxdWl0J1xyXG4gICAgO1xyXG5cclxuICAgIHByb3RlY3RlZCBfcmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUT0RPOiBGaW5kIGEgd2F5IHRvIGdldCBhIGR5bmFtaWMgdHlwZSBmb3IgdGhpcy53b3Jrc3BhY2VfZXZlbnQgLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcC53b3Jrc3BhY2Uub24odGhpcy53b3Jrc3BhY2VfZXZlbnQsIHRoaXMuZ2V0VHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX3VucmVnaXN0ZXIoZXZlbnRfcmVmZXJlbmNlOiBFdmVudFJlZik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vZmZyZWYoZXZlbnRfcmVmZXJlbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0VHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICByZXR1cm4gKC4uLnBhcmFtZXRlcnM6IGFueVtdIC8qIE5lZWQgdG8gaGF2ZSB0aGlzIHVnbHkgcGFyYW1ldGVyIHRoaW5nIHNvIHRoYXQgc3ViY2xhc3NlcyBjYW4gZGVmaW5lIHRoZWlyIG93biBwYXJhbWV0ZXJzLiAqLykgPT4gdGhpcy50cmlnZ2VyKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge1NDX1dvcmtzcGFjZUV2ZW50fSBmcm9tIFwiLi9TQ19Xb3Jrc3BhY2VFdmVudFwiO1xyXG5pbXBvcnQge1BhcnNpbmdSZXN1bHQsIFRTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7TWVudX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU0NfTWVudUV2ZW50IGV4dGVuZHMgU0NfV29ya3NwYWNlRXZlbnQge1xyXG5cclxuICAgIHByb3RlY3RlZCBhZGRUU2hlbGxDb21tYW5kVG9NZW51KHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCwgbWVudTogTWVudSkge1xyXG4gICAgICAgIC8vIFBhcnNlIHNoZWxsIGNvbW1hbmQgdmFyaWFibGVzIHRvIGdldCBhIHRpdGxlXHJcbiAgICAgICAgbGV0IHRpdGxlID0gdF9zaGVsbF9jb21tYW5kLmdldEFsaWFzKCkgfHwgdF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpOyAvLyBNYXkgY29udGFpbiB1bnBhcnNlZCB2YXJpYWJsZXMuXHJcbiAgICAgICAgbGV0IHBhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0O1xyXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGUpIHtcclxuICAgICAgICAgICAgLy8gUGFyc2UgdmFyaWFibGVzIGluIHRoZSB0aXRsZS5cclxuICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQgPSB0X3NoZWxsX2NvbW1hbmQucGFyc2VWYXJpYWJsZXModGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRpdGxlIHdpdGggYSB2YWx1ZSB3aG9zZSB2YXJpYWJsZXMgYXJlIHBhcnNlZC5cclxuICAgICAgICAgICAgICAgIHRpdGxlID0gcGFyc2luZ19yZXN1bHQuYWxpYXMgfHwgcGFyc2luZ19yZXN1bHQuc2hlbGxfY29tbWFuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgbWVudSBpdGVtLlxyXG4gICAgICAgIG1lbnUuYWRkSXRlbShpdGVtID0+IGl0ZW1cclxuICAgICAgICAgICAgLnNldFRpdGxlKHRpdGxlKVxyXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgdF9zaGVsbF9jb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0LCAvLyBDYW4gYmUgdW5kZWZpbmVkLCBpZiBubyBwcmVwYXJzaW5nIGlzIGRvbmUuXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi4vVFNoZWxsQ29tbWFuZFwiO1xyXG5pbXBvcnQge01lbnUsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBXb3Jrc3BhY2VMZWFmfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtTQ19NZW51RXZlbnR9IGZyb20gXCIuL1NDX01lbnVFdmVudFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNDX0Fic3RyYWN0RmlsZU1lbnVFdmVudCBleHRlbmRzIFNDX01lbnVFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiIHwgXCJmb2xkZXJcIjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB3b3Jrc3BhY2VfZXZlbnQgPSBcImZpbGUtbWVudVwiO1xyXG4gICAgcHJvdGVjdGVkIGZpbGU6IFRGaWxlO1xyXG4gICAgcHJvdGVjdGVkIGZvbGRlcjogVEZvbGRlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0VHJpZ2dlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICByZXR1cm4gKG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUsIHNvdXJjZTogc3RyaW5nLCBsZWFmPzogV29ya3NwYWNlTGVhZikgPT4ge1xyXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IGl0J3MgdGhlIGNvcnJlY3QgbWVudTogaWYgdGhlIFNDX0V2ZW50IHJlcXVpcmVzIGEgZm9sZGVyIG1lbnUsICdmaWxlJyBuZWVkcyB0byBiZSBhIFRGaWxlLCBvdGhlcndpc2UgaXQgbmVlZHMgdG8gYmUgYSBURm9sZGVyLlxyXG4gICAgICAgICAgICBpZiAoKHRoaXMuZmlsZV9vcl9mb2xkZXIgPT09IFwiZm9sZGVyXCIgJiYgZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHx8ICh0aGlzLmZpbGVfb3JfZm9sZGVyID09PSBcImZpbGVcIiAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWVudSBpcyBjb3JyZWN0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbGUvZm9sZGVyIGZvciBkZWNsYXJlRXh0cmFWYXJpYWJsZXMoKVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmZpbGVfb3JfZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZSBhcyBURmlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbGRlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlciA9IGZpbGUgYXMgVEZvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRTaGVsbENvbW1hbmRUb01lbnUodF9zaGVsbF9jb21tYW5kLCBtZW51KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtTQ19BYnN0cmFjdEZpbGVNZW51RXZlbnR9IGZyb20gXCIuL1NDX0Fic3RyYWN0RmlsZU1lbnVFdmVudFwiO1xyXG5pbXBvcnQge1RGaWxlLCBURm9sZGVyfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9GaWxlTWVudSBleHRlbmRzIFNDX0Fic3RyYWN0RmlsZU1lbnVFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImZpbGUtbWVudVwiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiRmlsZSBtZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZmlsZVwiID0gXCJmaWxlXCI7XHJcblxyXG4gICAgcHVibGljIGdldEZpbGUoKTogVEZpbGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZvbGRlcigpOiBURm9sZGVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlLnBhcmVudDtcclxuICAgIH1cclxufSIsImltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNZW51fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVNZW51XCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGaWxlTmFtZSBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJldmVudF9maWxlX25hbWVcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyB0aGUgc2VsZWN0ZWQgZmlsZSBuYW1lIHdpdGggYSBmaWxlIGV4dGVuc2lvbi4gSWYgeW91IG5lZWQgaXQgd2l0aG91dCB0aGUgZXh0ZW5zaW9uLCB1c2Uge3tldmVudF90aXRsZX19IGluc3RlYWQuXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAodGhpcy5zY19ldmVudCBhcyBTQ19FdmVudF9GaWxlTWVudSkuZ2V0RmlsZSgpLm5hbWU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge2dldEZpbGVQYXRofSBmcm9tIFwiLi4vVmFyaWFibGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7VEZpbGV9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGaWxlUGF0aCBleHRlbmRzIEV2ZW50VmFyaWFibGUge1xyXG4gICAgcHVibGljIHN0YXRpYyB2YXJpYWJsZV9uYW1lID0gXCJldmVudF9maWxlX3BhdGhcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJHaXZlcyBwYXRoIHRvIHRoZSBzZWxlY3RlZCBmaWxlLCBlaXRoZXIgYXMgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0sIG9yIGFzIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgbW9kZTogXCJhYnNvbHV0ZVwiIHwgXCJyZWxhdGl2ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmaWxlOiBURmlsZSA9ICh0aGlzLnNjX2V2ZW50IGFzIFNDX0V2ZW50X0ZpbGVNZW51KS5nZXRGaWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldEZpbGVQYXRoKHRoaXMuYXBwLCBmaWxlLCB0aGlzLmFyZ3VtZW50cy5tb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZmlsZSwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6cmVsYXRpdmV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHBhdGggdG8gdGhlIHNlbGVjdGVkIGZpbGUsIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVW5lc2NhcGVkIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjphYnNvbHV0ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZmlsZSwgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0uIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7eyFcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyBwYXRoIHRvIHRoZSBzZWxlY3RlZCBmaWxlLCByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmVzY2FwZWQtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZWxwTmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIjxzdHJvbmc+e3tldmVudF9maWxlX3BhdGg6cmVsYXRpdmV9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7ZXZlbnRfZmlsZV9wYXRoOmFic29sdXRlfX08L3N0cm9uZz5cIjtcclxuICAgIH1cclxufSIsImltcG9ydCB7U0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50fSBmcm9tIFwiLi9TQ19BYnN0cmFjdEZpbGVNZW51RXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9Gb2xkZXJNZW51IGV4dGVuZHMgU0NfQWJzdHJhY3RGaWxlTWVudUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZm9sZGVyLW1lbnVcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkZvbGRlciBtZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgZmlsZV9vcl9mb2xkZXI6IFwiZm9sZGVyXCIgPSBcImZvbGRlclwiO1xyXG5cclxuICAgIHB1YmxpYyBnZXRGb2xkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVyO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlck1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRm9sZGVyTWVudVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudEZvbGRlck5hbWUgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZm9sZGVyX25hbWVcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJGaWxlIG1lbnU6IEdpdmVzIHRoZSBzZWxlY3RlZCBmaWxlJ3MgcGFyZW50IGZvbGRlciBuYW1lLiBGb2xkZXIgbWVudTogR2l2ZXMgdGhlIHNlbGVjdGVkIGZvbGRlcidzIG5hbWUuIE5vIGFuY2VzdG9yIGZvbGRlcnMgYXJlIGluY2x1ZGVkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJNZW51LFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9ICh0aGlzLnNjX2V2ZW50IGFzIFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRm9sZGVyTWVudSkuZ2V0Rm9sZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGZvbGRlci5uYW1lO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlck1lbnV9IGZyb20gXCIuLi8uLi9ldmVudHMvU0NfRXZlbnRfRm9sZGVyTWVudVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRGb2xkZXJQYXRofSBmcm9tIFwiLi4vVmFyaWFibGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7SVBhcmFtZXRlcnN9IGZyb20gXCIuLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge0lBdXRvY29tcGxldGVJdGVtfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudEZvbGRlclBhdGggZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfZm9sZGVyX3BhdGhcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgaGVscF90ZXh0ID0gXCJGaWxlIG1lbnU6IEdpdmVzIHBhdGggdG8gdGhlIHNlbGVjdGVkIGZpbGUncyBwYXJlbnQgZm9sZGVyLiBGb2xkZXIgbWVudTogR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZm9sZGVyLiBUaGUgcGF0aCBpcyBlaXRoZXIgYWJzb2x1dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgZmlsZSBzeXN0ZW0sIG9yIHJlbGF0aXZlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIE9ic2lkaWFuIHZhdWx0LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgbW9kZTogXCJhYnNvbHV0ZVwiIHwgXCJyZWxhdGl2ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgICAgICBTQ19FdmVudF9Gb2xkZXJNZW51LFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9ICh0aGlzLnNjX2V2ZW50IGFzIFNDX0V2ZW50X0ZpbGVNZW51IHwgU0NfRXZlbnRfRm9sZGVyTWVudSkuZ2V0Rm9sZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldEZvbGRlclBhdGgodGhpcy5hcHAsIGZvbGRlciwgdGhpcy5hcmd1bWVudHMubW9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkZpbGUgbWVudTogR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZmlsZSdzIHBhcmVudCBmb2xkZXIuIEZvbGRlciBtZW51OiBHaXZlcyBwYXRoIHRvIHRoZSBzZWxlY3RlZCBmb2xkZXIuIFRoZSBwYXRoIGlzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3tcIiArIHRoaXMudmFyaWFibGVfbmFtZSArIFwiOnJlbGF0aXZlfX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJGaWxlIG1lbnU6IEdpdmVzIHBhdGggdG8gdGhlIHNlbGVjdGVkIGZpbGUncyBwYXJlbnQgZm9sZGVyLiBGb2xkZXIgbWVudTogR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZm9sZGVyLiBUaGUgcGF0aCBpcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6YWJzb2x1dGV9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkZpbGUgbWVudTogR2l2ZXMgcGF0aCB0byB0aGUgc2VsZWN0ZWQgZmlsZSdzIHBhcmVudCBmb2xkZXIuIEZvbGRlciBtZW51OiBHaXZlcyBwYXRoIHRvIHRoZSBzZWxlY3RlZCBmb2xkZXIuIFRoZSBwYXRoIGlzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpyZWxhdGl2ZX19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiRmlsZSBtZW51OiBHaXZlcyBwYXRoIHRvIHRoZSBzZWxlY3RlZCBmaWxlJ3MgcGFyZW50IGZvbGRlci4gRm9sZGVyIG1lbnU6IEdpdmVzIHBhdGggdG8gdGhlIHNlbGVjdGVkIGZvbGRlci4gVGhlIHBhdGggaXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SGVscE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPnt7ZXZlbnRfZm9sZGVyX3BhdGg6cmVsYXRpdmV9fTwvc3Ryb25nPiBvciA8c3Ryb25nPnt7ZXZlbnRfZm9sZGVyX3BhdGg6YWJzb2x1dGV9fTwvc3Ryb25nPlwiO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudFRpdGxlIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X3RpdGxlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lIHdpdGhvdXQgYSBmaWxlIGV4dGVuc2lvbi4gSWYgeW91IG5lZWQgaXQgd2l0aCB0aGUgZXh0ZW5zaW9uLCB1c2Uge3tldmVudF9maWxlX25hbWV9fSBpbnN0ZWFkLlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKHRoaXMuc2NfZXZlbnQgYXMgU0NfRXZlbnRfRmlsZU1lbnUpLmdldEZpbGUoKS5iYXNlbmFtZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNZW51fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVNZW51XCI7XHJcbmltcG9ydCB7Z2V0RmlsZUV4dGVuc2lvbn0gZnJvbSBcIi4uL1ZhcmlhYmxlSGVscGVyc1wiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzfSBmcm9tIFwiLi4vVmFyaWFibGVcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uLy4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9uIGV4dGVuZHMgRXZlbnRWYXJpYWJsZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHZhcmlhYmxlX25hbWUgPSBcImV2ZW50X2ZpbGVfZXh0ZW5zaW9uXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIGhlbHBfdGV4dCA9IFwiR2l2ZXMgdGhlIHNlbGVjdGVkIGZpbGUgbmFtZSdzIGVuZGluZy4gVXNlIHt7ZXZlbnRfZmlsZV9leHRlbnNpb246d2l0aC1kb3R9fSB0byBpbmNsdWRlIGEgcHJlY2VkaW5nIGRvdC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBlbXB0eSwgbm8gZG90IGlzIGFkZGVkLiB7e2V2ZW50X2ZpbGVfZXh0ZW5zaW9uOm5vLWRvdH19IG5ldmVyIGluY2x1ZGVzIGEgZG90LlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgXCJkb3RcIjoge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJ3aXRoLWRvdFwiLCBcIm5vLWRvdFwiXSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIFwiZG90XCI6IFwid2l0aC1kb3RcIiB8IFwibm8tZG90XCIsXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBzdXBwb3J0ZWRfc2NfZXZlbnRzID0gW1xyXG4gICAgICAgIFNDX0V2ZW50X0ZpbGVNZW51LFxyXG4gICAgXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTQ19FdmVudFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGUgPSAodGhpcy5zY19ldmVudCBhcyBTQ19FdmVudF9GaWxlTWVudSkuZ2V0RmlsZSgpO1xyXG4gICAgICAgIHJldHVybiBnZXRGaWxlRXh0ZW5zaW9uKGZpbGUsIHRoaXMuYXJndW1lbnRzLmRvdCA9PT0gXCJ3aXRoLWRvdFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEF1dG9jb21wbGV0ZUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7XCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjpuby1kb3R9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBzZWxlY3RlZCBmaWxlIG5hbWUncyBlbmRpbmcgd2l0aG91dCBhIHByZWNlZGluZyBkb3QuIFwiICsgdGhpcy5nZXRBdmFpbGFiaWxpdHlUZXh0KCksXHJcbiAgICAgICAgICAgICAgICBncm91cDogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDxJQXV0b2NvbXBsZXRlSXRlbT57XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ7e1wiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6d2l0aC1kb3R9fVwiLFxyXG4gICAgICAgICAgICAgICAgaGVscF90ZXh0OiBcIkdpdmVzIHRoZSBzZWxlY3RlZCBmaWxlIG5hbWUncyBlbmRpbmcgd2l0aCBhIHByZWNlZGluZyBkb3QuIElmIHRoZSBleHRlbnNpb24gaXMgZW1wdHksIG5vIGRvdCBpcyBpbmNsdWRlZC4gXCIgKyB0aGlzLmdldEF2YWlsYWJpbGl0eVRleHQoKSxcclxuICAgICAgICAgICAgICAgIGdyb3VwOiBcIlZhcmlhYmxlc1wiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWwtdmFyaWFibGVcIixcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVuZXNjYXBlZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgPElBdXRvY29tcGxldGVJdGVtPntcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcInt7IVwiICsgdGhpcy52YXJpYWJsZV9uYW1lICsgXCI6bm8tZG90fX1cIixcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogXCJHaXZlcyB0aGUgc2VsZWN0ZWQgZmlsZSBuYW1lJ3MgZW5kaW5nIHdpdGhvdXQgYSBwcmVjZWRpbmcgZG90LiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA8SUF1dG9jb21wbGV0ZUl0ZW0+e1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwie3shXCIgKyB0aGlzLnZhcmlhYmxlX25hbWUgKyBcIjp3aXRoLWRvdH19XCIsXHJcbiAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IFwiR2l2ZXMgdGhlIHNlbGVjdGVkIGZpbGUgbmFtZSdzIGVuZGluZyB3aXRoIGEgcHJlY2VkaW5nIGRvdC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBlbXB0eSwgbm8gZG90IGlzIGluY2x1ZGVkLiBcIiArIHRoaXMuZ2V0QXZhaWxhYmlsaXR5VGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IFwiVmFyaWFibGVzXCIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuZXNjYXBlZC12YXJpYWJsZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhlbHBOYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiPHN0cm9uZz57e2V2ZW50X2ZpbGVfZXh0ZW5zaW9uOndpdGgtZG90fX08L3N0cm9uZz4gb3IgPHN0cm9uZz57e2V2ZW50X2ZpbGVfZXh0ZW5zaW9uOm5vLWRvdH19PC9zdHJvbmc+XCI7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtTQ19FdmVudF9GaWxlTWVudX0gZnJvbSBcIi4uLy4uL2V2ZW50cy9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL0V2ZW50VmFyaWFibGVcIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVyc30gZnJvbSBcIi4uL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7Z2V0RmlsZVRhZ3N9IGZyb20gXCIuLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWYXJpYWJsZV9FdmVudFRhZ3MgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfdGFnc1wiO1xyXG4gICAgcHVibGljIHN0YXRpYyBoZWxwX3RleHQgPSBcIkdpdmVzIGFsbCB0YWdzIGRlZmluZWQgaW4gdGhlIHNlbGVjdGVkIG5vdGUuIFJlcGxhY2UgdGhlIFxcXCJzZXBhcmF0b3JcXFwiIHBhcnQgd2l0aCBhIGNvbW1hLCBzcGFjZSBvciB3aGF0ZXZlciBjaGFyYWN0ZXJzIHlvdSB3YW50IHRvIHVzZSBhcyBhIHNlcGFyYXRvciBiZXR3ZWVuIHRhZ3MuIEEgc2VwYXJhdG9yIGlzIGFsd2F5cyBuZWVkZWQgdG8gYmUgZGVmaW5lZC5cIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHN1cHBvcnRlZF9zY19ldmVudHMgPSBbXHJcbiAgICAgICAgU0NfRXZlbnRfRmlsZU1lbnUsXHJcbiAgICBdO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIHNlcGFyYXRvcjogc3RyaW5nLFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2VuZXJhdGVWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGVja1NDX0V2ZW50U3VwcG9ydCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZmlsZSA9ICh0aGlzLnNjX2V2ZW50IGFzIFNDX0V2ZW50X0ZpbGVNZW51KS5nZXRGaWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldEZpbGVUYWdzKHRoaXMuYXBwLCBmaWxlKS5qb2luKHRoaXMuYXJndW1lbnRzLnNlcGFyYXRvcik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge1NDX0V2ZW50X0ZpbGVNZW51fSBmcm9tIFwiLi4vLi4vZXZlbnRzL1NDX0V2ZW50X0ZpbGVNZW51XCI7XHJcbmltcG9ydCB7RXZlbnRWYXJpYWJsZX0gZnJvbSBcIi4vRXZlbnRWYXJpYWJsZVwiO1xyXG5pbXBvcnQge2dldEZpbGVZQU1MVmFsdWV9IGZyb20gXCIuLi9WYXJpYWJsZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVyc30gZnJvbSBcIi4uL1ZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGVfRXZlbnRZQU1MVmFsdWUgZXh0ZW5kcyBFdmVudFZhcmlhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmFyaWFibGVfbmFtZSA9IFwiZXZlbnRfeWFtbF92YWx1ZVwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBoZWxwX3RleHQgPSBcIlJlYWRzIGEgc2luZ2xlIHZhbHVlIGZyb20gdGhlIHNlbGVjdGVkIGZpbGUncyBmcm9udG1hdHRlci4gVGFrZXMgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LiBZb3UgY2FuIGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcyB3aXRoIGRvdCBub3RhdGlvbjogcHJvcGVydHkxLnByb3BlcnR5MlwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZToge1xyXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgcHJvcGVydHlfbmFtZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc3VwcG9ydGVkX3NjX2V2ZW50cyA9IFtcclxuICAgICAgICBTQ19FdmVudF9GaWxlTWVudSxcclxuICAgIF07XHJcblxyXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlVmFsdWUoKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU0NfRXZlbnRTdXBwb3J0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmaWxlID0gKHRoaXMuc2NfZXZlbnQgYXMgU0NfRXZlbnRfRmlsZU1lbnUpLmdldEZpbGUoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRGaWxlWUFNTFZhbHVlKHRoaXMuYXBwLCBmaWxlLCB0aGlzLmFyZ3VtZW50cy5wcm9wZXJ0eV9uYW1lKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgY29udGFpbnMgZXJyb3IgbWVzc2FnZShzKS5cclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2VzKHJlc3VsdCBhcyBzdHJpbmdbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb2ssIGl0J3MgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgYXMgc3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCB7VmFyaWFibGV9IGZyb20gXCIuL1ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfQ2xpcGJvYXJkfSBmcm9tIFwiLi9WYXJpYWJsZV9DbGlwYm9hcmRcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9DYXJldFBvc2l0aW9ufSBmcm9tIFwiLi9WYXJpYWJsZV9DYXJldFBvc2l0aW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRGF0ZX0gZnJvbSBcIi4vVmFyaWFibGVfRGF0ZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0ZpbGVFeHRlbnNpb259IGZyb20gXCIuL1ZhcmlhYmxlX0ZpbGVFeHRlbnNpb25cIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9GaWxlTmFtZX0gZnJvbSBcIi4vVmFyaWFibGVfRmlsZU5hbWVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9GaWxlUGF0aH0gZnJvbSBcIi4vVmFyaWFibGVfRmlsZVBhdGhcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9Gb2xkZXJOYW1lfSBmcm9tIFwiLi9WYXJpYWJsZV9Gb2xkZXJOYW1lXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRm9sZGVyUGF0aH0gZnJvbSBcIi4vVmFyaWFibGVfRm9sZGVyUGF0aFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1NlbGVjdGlvbn0gZnJvbSBcIi4vVmFyaWFibGVfU2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfVGFnc30gZnJvbSBcIi4vVmFyaWFibGVfVGFnc1wiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1RpdGxlfSBmcm9tIFwiLi9WYXJpYWJsZV9UaXRsZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX1ZhdWx0UGF0aH0gZnJvbSBcIi4vVmFyaWFibGVfVmF1bHRQYXRoXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfV29ya3NwYWNlfSBmcm9tIFwiLi9WYXJpYWJsZV9Xb3Jrc3BhY2VcIjtcclxuaW1wb3J0IHtERUJVR19PTn0gZnJvbSBcIi4uL0RlYnVnXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfUGFzc3Rocm91Z2h9IGZyb20gXCIuL1ZhcmlhYmxlX1Bhc3N0aHJvdWdoXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9ZQU1MVmFsdWV9IGZyb20gXCIuL1ZhcmlhYmxlX1lBTUxWYWx1ZVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRGaWxlTmFtZX0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50RmlsZU5hbWVcIjtcclxuaW1wb3J0IHtWYXJpYWJsZV9FdmVudEZpbGVQYXRofSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGaWxlUGF0aFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50Rm9sZGVyTmFtZX0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50Rm9sZGVyTmFtZVwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50Rm9sZGVyUGF0aH0gZnJvbSBcIi4vZXZlbnRfdmFyaWFibGVzL1ZhcmlhYmxlX0V2ZW50Rm9sZGVyUGF0aFwiO1xyXG5pbXBvcnQge1ZhcmlhYmxlX0V2ZW50VGl0bGV9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudFRpdGxlXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9ufSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9uXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRUYWdzfSBmcm9tIFwiLi9ldmVudF92YXJpYWJsZXMvVmFyaWFibGVfRXZlbnRUYWdzXCI7XHJcbmltcG9ydCB7VmFyaWFibGVfRXZlbnRZQU1MVmFsdWV9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9WYXJpYWJsZV9FdmVudFlBTUxWYWx1ZVwiO1xyXG5pbXBvcnQge0V2ZW50VmFyaWFibGV9IGZyb20gXCIuL2V2ZW50X3ZhcmlhYmxlcy9FdmVudFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyaWFibGVzKHBsdWdpbjogU0NfUGx1Z2luLCBzaGVsbDogc3RyaW5nLCBzY19ldmVudD86IFNDX0V2ZW50KSB7XHJcbiAgICBjb25zdCBzaGVsbF9jb21tYW5kX3ZhcmlhYmxlczogVmFyaWFibGVbXSA9IFtcclxuICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGVzXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0NhcmV0UG9zaXRpb24ocGx1Z2luLCBzaGVsbCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0NsaXBib2FyZChwbHVnaW4sIHNoZWxsKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRGF0ZShwbHVnaW4sIHNoZWxsKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRmlsZUV4dGVuc2lvbihwbHVnaW4sIHNoZWxsKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRmlsZU5hbWUocGx1Z2luLCBzaGVsbCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0ZpbGVQYXRoKHBsdWdpbiwgc2hlbGwpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9Gb2xkZXJOYW1lKHBsdWdpbiwgc2hlbGwpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9Gb2xkZXJQYXRoKHBsdWdpbiwgc2hlbGwpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9TZWxlY3Rpb24ocGx1Z2luLCBzaGVsbCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1RhZ3MocGx1Z2luLCBzaGVsbCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1RpdGxlKHBsdWdpbiwgc2hlbGwpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9WYXVsdFBhdGgocGx1Z2luLCBzaGVsbCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX1dvcmtzcGFjZShwbHVnaW4sIHNoZWxsKSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfWUFNTFZhbHVlKHBsdWdpbiwgc2hlbGwpLFxyXG5cclxuICAgICAgICAvLyBFdmVudCB2YXJpYWJsZXNcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnRGaWxlRXh0ZW5zaW9uKHBsdWdpbiwgc2hlbGwsIHNjX2V2ZW50KSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnRGaWxlTmFtZShwbHVnaW4sIHNoZWxsLCBzY19ldmVudCksXHJcbiAgICAgICAgbmV3IFZhcmlhYmxlX0V2ZW50RmlsZVBhdGgocGx1Z2luLCBzaGVsbCwgc2NfZXZlbnQpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudEZvbGRlck5hbWUocGx1Z2luLCBzaGVsbCwgc2NfZXZlbnQpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudEZvbGRlclBhdGgocGx1Z2luLCBzaGVsbCwgc2NfZXZlbnQpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudFRhZ3MocGx1Z2luLCBzaGVsbCwgc2NfZXZlbnQpLFxyXG4gICAgICAgIG5ldyBWYXJpYWJsZV9FdmVudFRpdGxlKHBsdWdpbiwgc2hlbGwsIHNjX2V2ZW50KSxcclxuICAgICAgICBuZXcgVmFyaWFibGVfRXZlbnRZQU1MVmFsdWUocGx1Z2luLCBzaGVsbCwgc2NfZXZlbnQpLFxyXG4gICAgXTtcclxuICAgIGlmIChERUJVR19PTikge1xyXG4gICAgICAgIC8vIFZhcmlhYmxlcyB0aGF0IGFyZSBvbmx5IGRlc2lnbmVkIGZvciAnU2hlbGwgY29tbWFuZHMgdGVzdCBzdWl0ZScuXHJcbiAgICAgICAgc2hlbGxfY29tbWFuZF92YXJpYWJsZXMucHVzaChcclxuICAgICAgICAgICAgbmV3IFZhcmlhYmxlX1Bhc3N0aHJvdWdoKHBsdWdpbiwgc2hlbGwpLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hlbGxfY29tbWFuZF92YXJpYWJsZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZUNsYXNzZXMoKSB7XHJcbiAgICBjb25zdCBzaGVsbF9jb21tYW5kX3ZhcmlhYmxlczogKHR5cGVvZiBWYXJpYWJsZSB8IHR5cGVvZiBFdmVudFZhcmlhYmxlKVtdICA9IFsgLy8gdHlwZW9mIEV2ZW50VmFyaWFibGUgbmVlZHMgdG8gYmUgZXhwbGljaXRseSBtZW50aW9uZWQsIGJlY2F1c2UgaXRzIGNvbnN0cnVjdG9yKCkgc2lnbmF0dXJlIGNvbnRhaW5zIG1vcmUgcGFyYW1ldGVycyB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgb2YgVmFyaWFibGUuXHJcbiAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlc1xyXG4gICAgICAgIFZhcmlhYmxlX0NhcmV0UG9zaXRpb24sXHJcbiAgICAgICAgVmFyaWFibGVfQ2xpcGJvYXJkLFxyXG4gICAgICAgIFZhcmlhYmxlX0RhdGUsXHJcbiAgICAgICAgVmFyaWFibGVfRmlsZUV4dGVuc2lvbixcclxuICAgICAgICBWYXJpYWJsZV9GaWxlTmFtZSxcclxuICAgICAgICBWYXJpYWJsZV9GaWxlUGF0aCxcclxuICAgICAgICBWYXJpYWJsZV9Gb2xkZXJOYW1lLFxyXG4gICAgICAgIFZhcmlhYmxlX0ZvbGRlclBhdGgsXHJcbiAgICAgICAgVmFyaWFibGVfU2VsZWN0aW9uLFxyXG4gICAgICAgIFZhcmlhYmxlX1RhZ3MsXHJcbiAgICAgICAgVmFyaWFibGVfVGl0bGUsXHJcbiAgICAgICAgVmFyaWFibGVfVmF1bHRQYXRoLFxyXG4gICAgICAgIFZhcmlhYmxlX1dvcmtzcGFjZSxcclxuICAgICAgICBWYXJpYWJsZV9ZQU1MVmFsdWUsXHJcblxyXG4gICAgICAgIC8vIEV2ZW50IHZhcmlhYmxlc1xyXG4gICAgICAgIFZhcmlhYmxlX0V2ZW50RmlsZUV4dGVuc2lvbixcclxuICAgICAgICBWYXJpYWJsZV9FdmVudEZpbGVOYW1lLFxyXG4gICAgICAgIFZhcmlhYmxlX0V2ZW50RmlsZVBhdGgsXHJcbiAgICAgICAgVmFyaWFibGVfRXZlbnRGb2xkZXJOYW1lLFxyXG4gICAgICAgIFZhcmlhYmxlX0V2ZW50Rm9sZGVyUGF0aCxcclxuICAgICAgICBWYXJpYWJsZV9FdmVudFRhZ3MsXHJcbiAgICAgICAgVmFyaWFibGVfRXZlbnRUaXRsZSxcclxuICAgICAgICBWYXJpYWJsZV9FdmVudFlBTUxWYWx1ZSxcclxuICAgIF07XHJcbiAgICBpZiAoREVCVUdfT04pIHtcclxuICAgICAgICAvLyBWYXJpYWJsZXMgdGhhdCBhcmUgb25seSBkZXNpZ25lZCBmb3IgJ1NoZWxsIGNvbW1hbmRzIHRlc3Qgc3VpdGUnLlxyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfdmFyaWFibGVzLnB1c2goXHJcbiAgICAgICAgICAgIFZhcmlhYmxlX1Bhc3N0aHJvdWdoLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hlbGxfY29tbWFuZF92YXJpYWJsZXM7XHJcbn0iLCJpbXBvcnQge1ZhcmlhYmxlfSBmcm9tIFwiLi9WYXJpYWJsZVwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge2dldFZhcmlhYmxlc30gZnJvbSBcIi4vVmFyaWFibGVMaXN0c1wiO1xyXG5pbXBvcnQge1NDX0V2ZW50fSBmcm9tIFwiLi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAcGFyYW0gY29tbWFuZFxyXG4gKiBAcGFyYW0gc2hlbGxcclxuICogQHBhcmFtIHNjX2V2ZW50IFVzZSB1bmRlZmluZWQsIGlmIHBhcnNpbmcgaXMgbm90IGhhcHBlbmluZyBkdXJpbmcgYW4gZXZlbnQuXHJcbiAqIEByZXR1cm4gc3RyaW5nfHN0cmluZ1tdIElmIHBhcnNpbmcgZmFpbHMsIGFuIGFycmF5IG9mIHN0cmluZyBlcnJvciBtZXNzYWdlcyBpcyByZXR1cm5lZC4gSWYgdGhlIHBhcnNpbmcgc3VjY2VlZHMsIHRoZSBwYXJzZWQgc2hlbGwgY29tbWFuZCB3aWxsIGJlIHJldHVybmVkIGp1c3QgYXMgYSBzdHJpbmcsIG5vdCBpbiBhbiBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcyhwbHVnaW46IFNDX1BsdWdpbiwgY29tbWFuZDogc3RyaW5nLCBzaGVsbDogc3RyaW5nLCBzY19ldmVudD86IFNDX0V2ZW50KTogc3RyaW5nIHwgc3RyaW5nW10ge1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gZ2V0VmFyaWFibGVzKHBsdWdpbiwgc2hlbGwsIHNjX2V2ZW50KTtcclxuICAgIGxldCBwYXJzZWRfY29tbWFuZCA9IGNvbW1hbmQ7IC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHZhcmlhYmxlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhbHRlciB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgJ2NvbW1hbmQnIGR1cmluZyBpdGVyYXRpbmcgaXRzIHJlZ2V4IG1hdGNoZXMuXHJcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlX2luZGV4IGluIHZhcmlhYmxlcylcclxuICAgIHtcclxuICAgICAgICBjb25zdCB2YXJpYWJsZTogVmFyaWFibGUgPSB2YXJpYWJsZXNbdmFyaWFibGVfaW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHZhcmlhYmxlLmdldFBhdHRlcm4oKSwgXCJpZ1wiKTsgLy8gaTogY2FzZS1pbnNlbnNpdGl2ZTsgZzogbWF0Y2ggYWxsIG9jY3VycmVuY2VzIGluc3RlYWQgb2YganVzdCB0aGUgZmlyc3Qgb25lLlxyXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcl9uYW1lcyA9IHZhcmlhYmxlLmdldFBhcmFtZXRlck5hbWVzKCk7XHJcbiAgICAgICAgbGV0IGFyZ3VtZW50X21hdGNoZXM6IFJlZ0V4cEV4ZWNBcnJheTsgLy8gTmVlZCB0byBwcmVmaXggd2l0aCBfIGJlY2F1c2UgSmF2YVNjcmlwdCByZXNlcnZlcyB0aGUgdmFyaWFibGUgbmFtZSAnYXJndW1lbnRzJy5cclxuICAgICAgICB3aGlsZSAoKGFyZ3VtZW50X21hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoY29tbWFuZCkpICE9PSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgc3R1ZmYgdGhhdCBzaG91bGQgbm90IGJlIGl0ZXJhdGVkIGluIGEgbGF0ZXIgbG9vcC5cclxuICAgICAgICAgICAgY29uc3QgX2FyZ3VtZW50cyA9IGFyZ3VtZW50X21hdGNoZXMuZmlsdGVyKCh2YWx1ZTogYW55LyogV29uJ3QgYmUgdXNlZCAqLywga2V5OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09PSB0eXBlb2Yga2V5O1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBsZWF2ZXMgb3V0IGZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgbm9uLW51bWVyaWMga2V5cyAoYW5kIHRoZWlyIHZhbHVlcyk6XHJcbiAgICAgICAgICAgICAgICAvLyAtIFwiZ3JvdXBzXCJcclxuICAgICAgICAgICAgICAgIC8vIC0gXCJpbmRleFwiXHJcbiAgICAgICAgICAgICAgICAvLyAtIFwiaW5wdXRcIlxyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhlcmUgY2FuIGFsc28gY29tZSBtb3JlIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSBza2lwcGVkLiBFLmcuIFwiaW5kaWNlc1wiLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub3RoaW5naXNsb3N0L29ic2lkaWFuLWR5bmFtaWMtaGlnaGxpZ2h0cy9pc3N1ZXMvMjUjaXNzdWVjb21tZW50LTEwMzg1NjM5OTAgKHJlZmVyZW5jZWQgMjAyMi0wMi0yMikuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB7e3ZhcmlhYmxlfX0gc3RyaW5nIHRoYXQgd2lsbCBiZSBzdWJzdGl0dXRlZCAoPSByZXBsYWNlZCB3aXRoIHRoZSBhY3R1YWwgdmFsdWUgb2YgdGhlIHZhcmlhYmxlKS5cclxuICAgICAgICAgICAgY29uc3Qgc3Vic3RpdHV0ZSA9IF9hcmd1bWVudHMuc2hpZnQoKTsgLy8gJ19hcmd1bWVudHNbMF0nIGNvbnRhaW5zIHRoZSB3aG9sZSBtYXRjaCwgbm90IGp1c3QgYW4gYXJndW1lbnQuIEdldCBpdCBhbmQgcmVtb3ZlIGl0IGZyb20gJ19hcmd1bWVudHMnLlxyXG5cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBhbGwgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBfYXJndW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBhcmd1bWVudCBpcyBub3Qgb21pdHRlZC4gSXQgY2FuIGJlIG9taXR0ZWQgKD0gdW5kZWZpbmVkKSwgaWYgdGhlIHBhcmFtZXRlciBpcyBvcHRpb25hbC5cclxuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IF9hcmd1bWVudHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnQgaXMgcHJlc2VudC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudCA9IF9hcmd1bWVudHNbaV0uc2xpY2UoMSk7IC8vIC5zbGljZSgxKTogUmVtb3ZlIGEgcHJlY2VkaW5nIDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJfbmFtZSA9IHBhcmFtZXRlcl9uYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRBcmd1bWVudChwYXJhbWV0ZXJfbmFtZSwgYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaG91bGQgdGhlIHZhcmlhYmxlJ3MgdmFsdWUgYmUgZXNjYXBlZD8gKFVzdWFsbHkgeWVzKS5cclxuICAgICAgICAgICAgbGV0IGVzY2FwZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChcInt7IVwiID09PSBzdWJzdGl0dXRlLnNsaWNlKDAsIDMpKSB7IC8vIC5zbGljZSgwLCAzKSA9IGdldCBjaGFyYWN0ZXJzIDAuLi4yLCBzbyBzdG9wIGJlZm9yZSAzLiBUaGUgJ2VuZCcgcGFyYW1ldGVyIGlzIGNvbmZ1c2luZy5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSB2YXJpYWJsZSB1c2FnZSBiZWdpbnMgd2l0aCB7eyEgaW5zdGVhZCBvZiB7e1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgdmFyaWFibGUncyB2YWx1ZSBzaG91bGQgTk9UIGJlIGVzY2FwZWQuXHJcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZV92YWx1ZSA9IHZhcmlhYmxlLmdldFZhbHVlKGVzY2FwZSk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5nZXRFcnJvck1lc3NhZ2VzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBoYXMgYmVlbiBhIHByb2JsZW0gYW5kIGV4ZWN1dGluZyB0aGUgY29tbWFuZCBzaG91bGQgYmUgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJQYXJzaW5nIGNvbW1hbmQgXCIgKyBjb21tYW5kICsgXCIgZmFpbGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZS5nZXRFcnJvck1lc3NhZ2VzKCk7IC8vIFJldHVybmluZyBub3cgcHJldmVudHMgcGFyc2luZyByZXN0IG9mIHRoZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWRfY29tbWFuZCA9IHBhcnNlZF9jb21tYW5kLnJlcGxhY2Uoc3Vic3RpdHV0ZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIHRoZSByZXBsYWNpbmcgaW4gYSBmdW5jdGlvbiBpbiBvcmRlciB0byBhdm9pZCBhIHBvc3NpYmxlICQgY2hhcmFjdGVyIHRvIGJlIGludGVycHJldGVkIGJ5IEphdmFTY3JpcHQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgcmVnZXguXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGxhY2Ujc3BlY2lmeWluZ19hX3N0cmluZ19hc19hX3BhcmFtZXRlciAocmVmZXJlbmNlZCAyMDIxLTExLTAyLilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRfY29tbWFuZDtcclxufVxyXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5hdXRvY29tcGxldGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLypcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20va3JhYWRlbi9hdXRvY29tcGxldGVcclxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGVueXMgS3Jhc25vc2hjaG9rXHJcbiAgICogTUlUIExpY2Vuc2VcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdXRvY29tcGxldGUoc2V0dGluZ3MpIHtcclxuICAgICAgLy8ganVzdCBhbiBhbGlhcyB0byBtaW5pbWl6ZSBKUyBmaWxlIHNpemVcclxuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50O1xyXG4gICAgICB2YXIgY29udGFpbmVyID0gc2V0dGluZ3MuY29udGFpbmVyIHx8IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgICB2YXIgbW9iaWxlRmlyZWZveCA9IH51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgJiYgfnVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpO1xyXG4gICAgICB2YXIgZGVib3VuY2VXYWl0TXMgPSBzZXR0aW5ncy5kZWJvdW5jZVdhaXRNcyB8fCAwO1xyXG4gICAgICB2YXIgcHJldmVudFN1Ym1pdCA9IHNldHRpbmdzLnByZXZlbnRTdWJtaXQgfHwgZmFsc2U7XHJcbiAgICAgIHZhciBkaXNhYmxlQXV0b1NlbGVjdCA9IHNldHRpbmdzLmRpc2FibGVBdXRvU2VsZWN0IHx8IGZhbHNlO1xyXG4gICAgICAvLyAna2V5dXAnIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIG9uIE1vYmlsZSBGaXJlZm94LCBzbyB3ZSBoYXZlIHRvIHVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWRcclxuICAgICAgdmFyIGtleVVwRXZlbnROYW1lID0gbW9iaWxlRmlyZWZveCA/IFwiaW5wdXRcIiA6IFwia2V5dXBcIjtcclxuICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgIHZhciBpbnB1dFZhbHVlID0gXCJcIjtcclxuICAgICAgdmFyIG1pbkxlbiA9IDI7XHJcbiAgICAgIHZhciBzaG93T25Gb2N1cyA9IHNldHRpbmdzLnNob3dPbkZvY3VzO1xyXG4gICAgICB2YXIgc2VsZWN0ZWQ7XHJcbiAgICAgIHZhciBrZXlwcmVzc0NvdW50ZXIgPSAwO1xyXG4gICAgICB2YXIgZGVib3VuY2VUaW1lcjtcclxuICAgICAgaWYgKHNldHRpbmdzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBtaW5MZW4gPSBzZXR0aW5ncy5taW5MZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdW5kZWZpbmVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbnB1dCA9IHNldHRpbmdzLmlucHV0O1xyXG4gICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJhdXRvY29tcGxldGUgXCIgKyAoc2V0dGluZ3MuY2xhc3NOYW1lIHx8IFwiXCIpO1xyXG4gICAgICAvLyBJT1MgaW1wbGVtZW50YXRpb24gZm9yIGZpeGVkIHBvc2l0aW9uaW5nIGhhcyBtYW55IGJ1Z3MsIHNvIHdlIHdpbGwgdXNlIGFic29sdXRlIHBvc2l0aW9uaW5nXHJcbiAgICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAvKipcclxuICAgICAgICogRGV0YWNoIHRoZSBjb250YWluZXIgZnJvbSBET01cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcclxuICAgICAgICAgIHZhciBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTtcclxuICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gY2xlYXJEZWJvdW5jZVRpbWVyKCkge1xyXG4gICAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcclxuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGF0dGFjaCgpIHtcclxuICAgICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGNvbnRhaW5lckRpc3BsYXllZCgpIHtcclxuICAgICAgICAgIHJldHVybiAhIWNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDbGVhciBhdXRvY29tcGxldGUgc3RhdGUgYW5kIGhpZGUgY29udGFpbmVyXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBjbGVhcigpIHtcclxuICAgICAgICAgIC8vIHByZXZlbnQgdGhlIHVwZGF0ZSBjYWxsIGlmIHRoZXJlIGFyZSBwZW5kaW5nIEFKQVggcmVxdWVzdHNcclxuICAgICAgICAgIGtleXByZXNzQ291bnRlcisrO1xyXG4gICAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBkZXRhY2goKTtcclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogVXBkYXRlIGF1dG9jb21wbGV0ZSBwb3NpdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XHJcbiAgICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoICsgXCJweFwiO1xyXG4gICAgICAgICAgdmFyIG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgICB2YXIgaW5wdXRSZWN0O1xyXG4gICAgICAgICAgZnVuY3Rpb24gY2FsYygpIHtcclxuICAgICAgICAgICAgICB2YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgIHZhciBjbGllbnRUb3AgPSBkb2NFbC5jbGllbnRUb3AgfHwgZG9jLmJvZHkuY2xpZW50VG9wIHx8IDA7XHJcbiAgICAgICAgICAgICAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGRvYy5ib2R5LmNsaWVudExlZnQgfHwgMDtcclxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgIGlucHV0UmVjdCA9IGlucHV0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgIHZhciB0b3AgPSBpbnB1dFJlY3QudG9wICsgaW5wdXQub2Zmc2V0SGVpZ2h0ICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xyXG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0gaW5wdXRSZWN0LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcclxuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gKGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS5ib3R0b20gPSBcIlwiO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHRoZSBjYWxjIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB0d2ljZSwgb3RoZXJ3aXNlIHRoZSBjYWxjdWxhdGlvbiBtYXkgYmUgd3Jvbmcgb24gcmVzaXplIGV2ZW50IChjaHJvbWUgYnJvd3NlcilcclxuICAgICAgICAgIGNhbGMoKTtcclxuICAgICAgICAgIGNhbGMoKTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUgJiYgaW5wdXRSZWN0KSB7XHJcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9taXplKGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKipcclxuICAgICAgICogUmVkcmF3IHRoZSBhdXRvY29tcGxldGUgZGl2IGVsZW1lbnQgd2l0aCBzdWdnZXN0aW9uc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXHJcbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcclxuICAgICAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiAoaXRlbSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcclxuICAgICAgICAgICAgICByZW5kZXIgPSBzZXR0aW5ncy5yZW5kZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBmdW5jdGlvbiB0byByZW5kZXIgYXV0b2NvbXBsZXRlIGdyb3Vwc1xyXG4gICAgICAgICAgdmFyIHJlbmRlckdyb3VwID0gZnVuY3Rpb24gKGdyb3VwTmFtZSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGdyb3VwRGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cE5hbWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGl2O1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJHcm91cCkge1xyXG4gICAgICAgICAgICAgIHJlbmRlckdyb3VwID0gc2V0dGluZ3MucmVuZGVyR3JvdXA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgdmFyIHByZXZHcm91cCA9IFwiIzk/JFwiO1xyXG4gICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgIGlmIChpdGVtLmdyb3VwICYmIGl0ZW0uZ3JvdXAgIT09IHByZXZHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICBwcmV2R3JvdXAgPSBpdGVtLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBEaXYgPSByZW5kZXJHcm91cChpdGVtLmdyb3VwLCBpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwRGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGdyb3VwRGl2KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmIChkaXYpIHtcclxuICAgICAgICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGl0ZW0sIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgc2VsZWN0ZWRcIjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5TXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBlbXB0eSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICBlbXB0eS5jbGFzc05hbWUgPSBcImVtcHR5XCI7XHJcbiAgICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXR0YWNoKCk7XHJcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKSB7XHJcbiAgICAgICAgICBpZiAoY29udGFpbmVyRGlzcGxheWVkKCkpIHtcclxuICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKSB7XHJcbiAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbEV2ZW50SGFuZGxlcihlKSB7XHJcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24ga2V5dXBFdmVudEhhbmRsZXIoZXYpIHtcclxuICAgICAgICAgIHZhciBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG4gICAgICAgICAgdmFyIGlnbm9yZSA9IHNldHRpbmdzLmtleXNUb0lnbm9yZSB8fCBbMzggLyogVXAgKi8sIDEzIC8qIEVudGVyICovLCAyNyAvKiBFc2MgKi8sIDM5IC8qIFJpZ2h0ICovLCAzNyAvKiBMZWZ0ICovLCAxNiAvKiBTaGlmdCAqLywgMTcgLyogQ3RybCAqLywgMTggLyogQWx0ICovLCAyMCAvKiBDYXBzTG9jayAqLywgOTEgLyogV2luZG93c0tleSAqLywgOSAvKiBUYWIgKi9dO1xyXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpZ25vcmVfMSA9IGlnbm9yZTsgX2kgPCBpZ25vcmVfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICB2YXIga2V5ID0gaWdub3JlXzFbX2ldO1xyXG4gICAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChrZXlDb2RlID49IDExMiAvKiBGMSAqLyAmJiBrZXlDb2RlIDw9IDEyMyAvKiBGMTIgKi8gJiYgIXNldHRpbmdzLmtleXNUb0lnbm9yZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHRoZSBkb3duIGtleSBpcyB1c2VkIHRvIG9wZW4gYXV0b2NvbXBsZXRlXHJcbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gNDAgLyogRG93biAqLyAmJiBjb250YWluZXJEaXNwbGF5ZWQoKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXJ0RmV0Y2goMCAvKiBLZXlib2FyZCAqLyk7XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcclxuICAgICAgICAgIHZhciBlbGVtZW50cyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XHJcbiAgICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFRvcCA8IGNvbnRhaW5lci5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJvdHRvbSA9IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdEJvdHRvbSA+IGNvbnRhaW5lckJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBzZWxlY3RCb3R0b20gLSBjb250YWluZXJCb3R0b207XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gc2VsZWN0UHJldigpIHtcclxuICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdCB0aGUgbmV4dCBpdGVtIGluIHN1Z2dlc3Rpb25zXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBzZWxlY3ROZXh0KCkge1xyXG4gICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPT09IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGtleWRvd25FdmVudEhhbmRsZXIoZXYpIHtcclxuICAgICAgICAgIHZhciBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IDM4IC8qIFVwICovIHx8IGtleUNvZGUgPT09IDQwIC8qIERvd24gKi8gfHwga2V5Q29kZSA9PT0gMjcgLyogRXNjICovKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lcklzRGlzcGxheWVkID0gY29udGFpbmVyRGlzcGxheWVkKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDI3IC8qIEVzYyAqLykge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJJc0Rpc3BsYXllZCB8fCBpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAga2V5Q29kZSA9PT0gMzggLyogVXAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0UHJldigpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklzRGlzcGxheWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMTMgLyogRW50ZXIgKi8pIHtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHByZXZlbnRTdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZm9jdXNFdmVudEhhbmRsZXIoKSB7XHJcbiAgICAgICAgICBpZiAoc2hvd09uRm9jdXMpIHtcclxuICAgICAgICAgICAgICBzdGFydEZldGNoKDEgLyogRm9jdXMgKi8pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0RmV0Y2godHJpZ2dlcikge1xyXG4gICAgICAgICAgLy8gSWYgbXVsdGlwbGUga2V5cyB3ZXJlIHByZXNzZWQsIGJlZm9yZSB3ZSBnZXQgYW4gdXBkYXRlIGZyb20gc2VydmVyLFxyXG4gICAgICAgICAgLy8gdGhpcyBtYXkgY2F1c2UgcmVkcmF3aW5nIGF1dG9jb21wbGV0ZSBtdWx0aXBsZSB0aW1lcyBhZnRlciB0aGUgbGFzdCBrZXkgd2FzIHByZXNzZWQuXHJcbiAgICAgICAgICAvLyBUbyBhdm9pZCB0aGlzLCB0aGUgbnVtYmVyIG9mIHRpbWVzIGtleWJvYXJkIHdhcyBwcmVzc2VkIHdpbGwgYmUgc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdy5cclxuICAgICAgICAgIHZhciBzYXZlZEtleXByZXNzQ291bnRlciA9ICsra2V5cHJlc3NDb3VudGVyO1xyXG4gICAgICAgICAgdmFyIGlucHV0VGV4dCA9IGlucHV0LnZhbHVlO1xyXG4gICAgICAgICAgdmFyIGN1cnNvclBvcyA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XHJcbiAgICAgICAgICBpZiAoaW5wdXRUZXh0Lmxlbmd0aCA+PSBtaW5MZW4gfHwgdHJpZ2dlciA9PT0gMSAvKiBGb2N1cyAqLykge1xyXG4gICAgICAgICAgICAgIGNsZWFyRGVib3VuY2VUaW1lcigpO1xyXG4gICAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZldGNoKGlucHV0VGV4dCwgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IChpdGVtcy5sZW5ndGggPCAxIHx8IGRpc2FibGVBdXRvU2VsZWN0KSA/IHVuZGVmaW5lZCA6IGl0ZW1zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LCB0cmlnZ2VyLCBjdXJzb3JQb3MpO1xyXG4gICAgICAgICAgICAgIH0sIHRyaWdnZXIgPT09IDAgLyogS2V5Ym9hcmQgKi8gPyBkZWJvdW5jZVdhaXRNcyA6IDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBibHVyRXZlbnRIYW5kbGVyKCkge1xyXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBjbGVhciwgYmVjYXVzZSB3aGVuIHdlIGNsaWNrIG9uIGFuIGl0ZW0sIGJsdXIgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGNsaWNrIGFuZCByZW1vdmUgaXRlbXMgZnJvbSBET01cclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBGaXhlcyAjMjY6IG9uIGxvbmcgY2xpY2tzIGZvY3VzIHdpbGwgYmUgbG9zdCBhbmQgb25TZWxlY3QgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxyXG4gICAgICAgKi9cclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvKipcclxuICAgICAgICogRml4ZXMgIzMwOiBhdXRvY29tcGxldGUgY2xvc2VzIHdoZW4gc2Nyb2xsYmFyIGlzIGNsaWNrZWQgaW4gSUVcclxuICAgICAgICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTIxMDI2Ny8xMzE3MjM0OVxyXG4gICAgICAgKi9cclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5mb2N1cygpOyB9KTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgRE9NIGVsZW1lbnRzIGFuZCBjbGVhciBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcclxuICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gc2V0dXAgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyKTtcclxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95XHJcbiAgICAgIH07XHJcbiAgfVxuXG4gIHJldHVybiBhdXRvY29tcGxldGU7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvY29tcGxldGUuanMubWFwXG4iLCJpbXBvcnQgYXV0b2NvbXBsZXRlIGZyb20gXCJhdXRvY29tcGxldGVyXCI7XHJcbmltcG9ydCB7cGFyc2VZYW1sfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRfZWxlbWVudFxyXG4gKiBAcGFyYW0gYXV0b2NvbXBsZXRlX2l0ZW1zXHJcbiAqIEBwYXJhbSBjYWxsX29uX2NvbXBsZXRpb24gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGhhcyBzZWxlY3RlZCBhIHN1Z2dlc3Rpb24gYW5kIHBlcmZvcm1lZCB0aGUgYXV0b2NvbXBsZXRlIGFjdGlvbi4gb25DaGFuZ2UgZXZlbnQgd2lsbCBub3QgYmUgY2FsbGVkLCBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb3BlbmluZyB0aGUgYXV0b2NvbXBsZXRlIG1lbnUgYWdhaW4sIHNvIHRoYXQncyB3aHkgYSBzZXBhcmF0ZSBjYWxsYmFjayBpcyB1c2VkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF1dG9jb21wbGV0ZShpbnB1dF9lbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50LCBhdXRvY29tcGxldGVfaXRlbXM6IElBdXRvY29tcGxldGVJdGVtW10sIGNhbGxfb25fY29tcGxldGlvbjogKGZpZWxkX3ZhbHVlOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgIGF1dG9jb21wbGV0ZV9pdGVtcyA9IG1lcmdlX2FuZF9zb3J0X2F1dG9jb21wbGV0ZV9pdGVtcyhhdXRvY29tcGxldGVfaXRlbXMsIEN1c3RvbUF1dG9jb21wbGV0ZUl0ZW1zKTtcclxuXHJcbiAgICBhdXRvY29tcGxldGU8SUF1dG9jb21wbGV0ZUl0ZW0+KHtcclxuICAgICAgICBpbnB1dDogaW5wdXRfZWxlbWVudCxcclxuICAgICAgICBmZXRjaDogKGlucHV0X3ZhbHVlX2J1dF9ub3RfdXNlZDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSkgPT4gdm9pZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXhfc3VnZ2VzdGlvbnMgPSAzMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc28gZmFyIHR5cGVkIHRleHQgLSBleGNsdWRlIGV2ZXJ5dGhpbmcgdGhhdCBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0X3Bvc2l0aW9uID0gaW5wdXRfZWxlbWVudC5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICAgICAgY29uc3QgdHlwZWRfdGV4dCA9IGlucHV0X2VsZW1lbnQudmFsdWUuc2xpY2UoMCwgY2FyZXRfcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfcXVlcnkgPSBnZXRfc2VhcmNoX3F1ZXJ5KHR5cGVkX3RleHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKFwiXCIgPT09IHNlYXJjaF9xdWVyeS5zZWFyY2hfdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gc3VnZ2VzdGlvbnMgZm9yIGVtcHR5IHdvcmQuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoW10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHdvcmQgaXMgbm90IGVtcHR5LCBzbyBjYW4gc3VnZ2VzdCBzb21ldGhpbmcuXHJcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZF9pdGVtcyA9IGF1dG9jb21wbGV0ZV9pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtX21hdGNoKGl0ZW0sIHNlYXJjaF9xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZF9pdGVtcyA9IG1hdGNoZWRfaXRlbXMuc2xpY2UoMCwgbWF4X3N1Z2dlc3Rpb25zKTsgLy8gTGltaXQgdG8gYSByZWFzb25hYmxlIGFtb3VudCBvZiBzdWdnZXN0aW9ucy5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZShtYXRjaGVkX2l0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TZWxlY3Q6IChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEEgdXNlciBoYXMgc2VsZWN0ZWQgYW4gaXRlbSB0byBiZSBhdXRvY29tcGxldGVkXHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGl0ZW0gdGV4dCBhbmQgYWxyZWFkeSB0eXBlZCB0ZXh0XHJcbiAgICAgICAgICAgIGxldCBzdXBwbGVtZW50ID0gaXRlbS52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IGNhcmV0X3Bvc2l0aW9uID0gaW5wdXRfZWxlbWVudC5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICAgICAgY29uc3QgdHlwZWRfdGV4dCA9IGlucHV0X2VsZW1lbnQudmFsdWUuc2xpY2UoMCwgY2FyZXRfcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfcXVlcnkgPSBnZXRfc2VhcmNoX3F1ZXJ5KHR5cGVkX3RleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hfdGV4dCA9IHNlYXJjaF9xdWVyeS5zZWFyY2hfdGV4dDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogQ2hlY2sgaWYgfX0gaGFwcGVucyB0byBhcHBlYXIgYWZ0ZXIgdGhlIGNhcmV0XHJcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyX2NhcmV0ID0gaW5wdXRfZWxlbWVudC52YWx1ZS5zbGljZShjYXJldF9wb3NpdGlvbiwgY2FyZXRfcG9zaXRpb24gKyAyKTtcclxuICAgICAgICAgICAgaWYgKFwifX1cIiA9PT0gYWZ0ZXJfY2FyZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXBsYWNpbmcgd2lsbCBoYXBwZW4gaW4gYSB7e3ZhcmlhYmxlfX0uXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWNjaWRlbnRhbGx5IGluc2VydCBhbm90aGVyIH19IHBhaXIuXHJcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50ID0gc3VwcGxlbWVudC5yZXBsYWNlKC99fSQvLCBcIlwiKTsgLy8gT25seSByZW1vdmVzIGEgdHJhaWxpbmcgfX0gaWYgdGhlcmUgaXMgb25lLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gc2F2ZSBwYXJ0IG9mIHRoZSBiZWdpbm5pbmcsIGluIGNhc2UgaXQgc2VlbXMgbGlrZSBub3QgYmVpbmcgcGFydCBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxyXG4gICAgICAgICAgICBsZXQgcmVwbGFjZV9zdGFydCA9IGZpbmRfc3RhcnRpbmdfcG9zaXRpb24oc2VhcmNoX3RleHQsIHN1cHBsZW1lbnQpOyAvLyBUaGUgbGVuZ3RoIGRpZmZlcmVuY2Ugb2YgdHlwZWRfdGV4dCBhbmQgc2VhcmNoX3RleHQgd2lsbCBiZSBhZGRlZCBoZXJlIGJlbG93LlxyXG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09IHJlcGxhY2Vfc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIGRvIG5vdCByZXBsYWNlIGFueXRoaW5nLCBqdXN0IGluc2VydC5cclxuICAgICAgICAgICAgICAgIHJlcGxhY2Vfc3RhcnQgPSBjYXJldF9wb3NpdGlvbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHJlcGxhY2Vfc3RhcnQgKz0gdHlwZWRfdGV4dC5sZW5ndGggLSBzZWFyY2hfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENob29zZSBhIG1ldGhvZCBmb3IgZG9pbmcgdGhlIGluc2VydGluZ1xyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBkb2N1bWVudC5leGVjQ29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhlY0NvbW1hbmQoKSBpcyBkZXByZWNhdGVkLCBidXQgYXZhaWxhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIGl0IHRvIGRvIHRoZSBpbnNlcnRpb24sIGJlY2F1c2UgdGhpcyB3YXkgYW4gdW5kbyBoaXN0b3J5IGNhbiBiZSBwcmVzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAgICBpbnB1dF9lbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHJlcGxhY2Vfc3RhcnQsIGNhcmV0X3Bvc2l0aW9uKTsgLy8gRmlyc3Qgc2VsZWN0IHRoZSBwYXJ0IHRoYXQgd2lsbCBiZSByZXBsYWNlZCwgYmVjYXVzZSBleGVjQ29tbWFuZCgpIGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgcG9zaXRpb25zLiBUaGlzIGFkZHMgYSBjdW1iZXJzb21lIHNlbGVjdGlvbiBzdGVwIHRvIHRoZSB1bmRvIGhpc3RvcnksIGJ1dCBhdCBsZWFzdCB1bmRvaW5nIHdvcmtzLlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbnNlcnRUZXh0XCIsIGZhbHNlLCBzdXBwbGVtZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGV4ZWNDb21tYW5kKCkgaXMgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHNldFJhbmdlVGV4dCgpIHRvIGRvIHRoZSBpbnNlcnRpb24uIEl0IHdpbGwgY2xlYXIgdW5kbyBoaXN0b3J5LCBidXQgYXQgbGVhc3QgdGhlIGluc2VydGlvbiB3b3Jrcy5cclxuICAgICAgICAgICAgICAgIGlucHV0X2VsZW1lbnQuc2V0UmFuZ2VUZXh0KHN1cHBsZW1lbnQsIHJlcGxhY2Vfc3RhcnQsIGNhcmV0X3Bvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgY2FyZXQgdG8gYSBsb2dpY2FsIGNvbnRpbnVhdGlvbiBwb2ludFxyXG4gICAgICAgICAgICBjYXJldF9wb3NpdGlvbiA9IHJlcGxhY2Vfc3RhcnQgKyBzdXBwbGVtZW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHN1cHBsZW1lbnQubWF0Y2goLzp9fSQvKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGxhY2UgdGhlIGNhcmV0IGFmdGVyIHRoZSBjb2xvbiwgaW5zdGVhZCBvZiBhZnRlciB9fS5cclxuICAgICAgICAgICAgICAgIGNhcmV0X3Bvc2l0aW9uIC09IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5wdXRfZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShjYXJldF9wb3NpdGlvbiwgY2FyZXRfcG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBhIGhvb2tcclxuICAgICAgICAgICAgY2FsbF9vbl9jb21wbGV0aW9uKGlucHV0X2VsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVuZGVyOiAoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkaXZfZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGRpdl9lbGVtZW50LmNyZWF0ZVNwYW4oe3RleHQ6IGl0ZW0udmFsdWUsIGF0dHI6IHtjbGFzczogXCJTQy1hdXRvY29tcGxldGUtdmFsdWVcIn19KTtcclxuICAgICAgICAgICAgZGl2X2VsZW1lbnQuY3JlYXRlU3Bhbih7dGV4dDogXCI6IFwiLCBhdHRyOiB7Y2xhc3M6IFwiU0MtYXV0b2NvbXBsZXRlLXNlcGFyYXRvclwifX0pO1xyXG4gICAgICAgICAgICBkaXZfZWxlbWVudC5jcmVhdGVTcGFuKHthdHRyOiB7Y2xhc3M6IFwiU0MtYXV0b2NvbXBsZXRlLWhlbHAtdGV4dFwifX0pLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBpdGVtLmhlbHBfdGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZfZWxlbWVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1pbkxlbmd0aDogMiwgLy8gTWluaW11bSBsZW5ndGggd2hlbiBhdXRvY29tcGxldGUgbWVudSBzaG91bGQgcG9wIHVwLlxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJTQy1hdXRvY29tcGxldGVcIiwgLy8gVGhlIGNvbXBvbmVudCBhbHdheXMgaGFzIGEgY2xhc3MgJ2F1dG9jb21wbGV0ZScsIGJ1dCBhZGQgJ1NDLWF1dG9jb21wbGV0ZScgc28gdGhhdCBTQydzIENTUyBjYW4gdGFyZ2V0ICdTQy1hdXRvY29tcGxldGUnLCBzbyBpdCB3aWxsIG5vdCBtZXNzIHVwIHN0dWZmIGlmIE9ic2lkaWFuIGhhcHBlbnMgdG8gaGF2ZSBhbiBlbGVtZW50IHdpdGggY2xhc3MgJ2F1dG9jb21wbGV0ZScuXHJcbiAgICAgICAga2V5c1RvSWdub3JlOiBbIDM4IC8qIFVwICovLCAxMyAvKiBFbnRlciAqLywgMjcgLyogRXNjICovLCAxNiAvKiBTaGlmdCAqLywgMTcgLyogQ3RybCAqLywgMTggLyogQWx0ICovLCAyMCAvKiBDYXBzTG9jayAqLywgOTEgLyogV2luZG93c0tleSAqLywgOSAvKiBUYWIgKi8gXSAvLyBEZWZpbmVkIGp1c3QgdG8gcHJldmVudCBpZ25vcmluZyBsZWZ0IGFuZCByaWdodCBrZXlzLlxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUF1dG9jb21wbGV0ZUl0ZW0ge1xyXG4gICAgaGVscF90ZXh0OiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogc3RyaW5nO1xyXG4gICAgZ3JvdXA6IHN0cmluZztcclxuICAgIHR5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXRlbV9tYXRjaChpdGVtOiBJQXV0b2NvbXBsZXRlSXRlbSwgc2VhcmNoX3F1ZXJ5OiBJQXV0b2NvbXBsZXRlU2VhcmNoUXVlcnkpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGl0ZW1fdmFsdWUgPSBpdGVtLnZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBzZWFyY2hfdGV4dCA9IHNlYXJjaF9xdWVyeS5zZWFyY2hfdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIE1hdGNoIHF1ZXJ5IHR5cGVcclxuICAgIGlmIChpdGVtLnR5cGUgIT09IHNlYXJjaF9xdWVyeS5zZWFyY2hfdHlwZSkge1xyXG4gICAgICAgIC8vIElmIHRoZSBxdWVyeSB0eXBlIGlzIGRpZmZlcmVudCwgZG8gbm90IGluY2x1ZGUgdGhpcyBpdGVtLlxyXG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBlLmcuIGlmIHt7IGlzIHR5cGVkLCBhbmQgdGhlIGl0ZW0gaXMgbm90IGEgdmFyaWFibGUsIG9yIHt7ISBpcyB0eXBlZCwgYW5kIHRoZSBpdGVtIGlzIG5vdCBhbiB1bmVzY2FwZWQgdmFyaWFibGUuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1hdGNoIHRleHRcclxuICAgIGxldCBzZWFyY2hfY2hhcmFjdGVyOiBzdHJpbmc7XHJcbiAgICBsZXQgc2VhcmNoX3Bvc2l0aW9uID0gMDtcclxuICAgIGZvciAobGV0IHNlYXJjaF9jaGFyYWN0ZXJfaW5kZXggPSAwOyBzZWFyY2hfY2hhcmFjdGVyX2luZGV4IDwgc2VhcmNoX3RleHQubGVuZ3RoOyBzZWFyY2hfY2hhcmFjdGVyX2luZGV4KyspIHtcclxuICAgICAgICBzZWFyY2hfY2hhcmFjdGVyID0gc2VhcmNoX3RleHRbc2VhcmNoX2NoYXJhY3Rlcl9pbmRleF07XHJcbiAgICAgICAgaWYgKGl0ZW1fdmFsdWUuaW5jbHVkZXMoc2VhcmNoX2NoYXJhY3Rlciwgc2VhcmNoX3Bvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gaXRlbV92YWx1ZS5cclxuICAgICAgICAgICAgc2VhcmNoX3Bvc2l0aW9uID0gaXRlbV92YWx1ZS5pbmRleE9mKHNlYXJjaF9jaGFyYWN0ZXIsIHNlYXJjaF9wb3NpdGlvbikgKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2hhcmFjdGVyIHdhcyBub3QgZm91bmQuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZF9zdGFydGluZ19wb3NpdGlvbih0eXBlZF90ZXh0OiBzdHJpbmcsIHN1cHBsZW1lbnQ6IHN0cmluZykge1xyXG4gICAgdHlwZWRfdGV4dCA9IHR5cGVkX3RleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgIHN1cHBsZW1lbnQgPSBzdXBwbGVtZW50LnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBmb3IgKGxldCBzdXBwbGVtZW50X2luZGV4ID0gc3VwcGxlbWVudC5sZW5ndGg7IHN1cHBsZW1lbnRfaW5kZXggPj0gMDsgc3VwcGxlbWVudF9pbmRleC0tKSB7XHJcbiAgICAgICAgY29uc3QgcGFydGlhbF9zdXBwbGVtZW50ID0gc3VwcGxlbWVudC5zbGljZSgwLCBzdXBwbGVtZW50X2luZGV4KTtcclxuICAgICAgICBpZiAodHlwZWRfdGV4dC5jb250YWlucyhwYXJ0aWFsX3N1cHBsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlZF90ZXh0LmluZGV4T2YocGFydGlhbF9zdXBwbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcblxyXG5jb25zdCBDdXN0b21BdXRvY29tcGxldGVJdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSA9IFtdO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZEN1c3RvbUF1dG9jb21wbGV0ZUl0ZW1zKGN1c3RvbV9hdXRvY29tcGxldGVfeWFtbDogc3RyaW5nKSB7XHJcblxyXG4gICAgLy8gRW5zdXJlIHRoZSBjb250ZW50IGlzIG5vdCBlbXB0eVxyXG4gICAgaWYgKDAgPT09IGN1c3RvbV9hdXRvY29tcGxldGVfeWFtbC50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGhlIGNvbnRlbnQgaXMgZW1wdHkuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHRvIHBhcnNlIFlBTUwgc3ludGF4XHJcbiAgICBsZXQgeWFtbDogYW55O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB5YW1sID0gcGFyc2VZYW1sKGN1c3RvbV9hdXRvY29tcGxldGVfeWFtbCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIEEgc3ludGF4IGVycm9yIGhhcyBhcHBlYXJlZC5cclxuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcclxuICAgIH1cclxuICAgIGlmIChudWxsID09PSB5YW1sIHx8IHR5cGVvZiB5YW1sICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIHBhcnNlIHRoZSBjb250ZW50IGR1ZSB0byB1bmtub3duIHJlYXNvbi5cIlxyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGUgYXV0b2NvbXBsZXRlIGl0ZW0gZ3JvdXBzXHJcbiAgICBjb25zdCBncm91cF9uYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHlhbWwpO1xyXG4gICAgZ3JvdXBfbmFtZXMuZm9yRWFjaCgoZ3JvdXBfbmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXBfaXRlbXMgPSB5YW1sW2dyb3VwX25hbWVdO1xyXG4gICAgICAgIGNvbnN0IGdyb3VwX2l0ZW1fdmFsdWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ3JvdXBfaXRlbXMpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIGFsbCBhdXRvY29tcGxldGUgaXRlbXMgaW4gdGhlIGdyb3VwXHJcbiAgICAgICAgZ3JvdXBfaXRlbV92YWx1ZXMuZm9yRWFjaCgoYXV0b2NvbXBsZXRlX2l0ZW1fdmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdXRvY29tcGxldGVfaXRlbV9sYWJlbCA9IGdyb3VwX2l0ZW1zW2F1dG9jb21wbGV0ZV9pdGVtX3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRvY29tcGxldGVfaXRlbV9sYWJlbCAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQXV0b2NvbXBsZXRlIGl0ZW0gJ1wiICsgYXV0b2NvbXBsZXRlX2l0ZW1fdmFsdWUgKyBcIicgaGFzIGFuIGluY29ycmVjdCBoZWxwIHRleHQgdHlwZTogXCIgKyB0eXBlb2YgYXV0b2NvbXBsZXRlX2l0ZW1fbGFiZWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBhIGNvcnJlY3QgdHlwZSBmb3IgdGhlIGl0ZW1cclxuICAgICAgICAgICAgbGV0IHR5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZSA9IFwib3RoZXJcIjtcclxuICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZV9pdGVtX3ZhbHVlLnN0YXJ0c1dpdGgoXCJ7e1wiKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJub3JtYWwtdmFyaWFibGVcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGl0ZW0gaXMgb2ssIGFkZCBpdCB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICBDdXN0b21BdXRvY29tcGxldGVJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBhdXRvY29tcGxldGVfaXRlbV92YWx1ZSxcclxuICAgICAgICAgICAgICAgIGhlbHBfdGV4dDogYXV0b2NvbXBsZXRlX2l0ZW1fbGFiZWwsXHJcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBfbmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibm9ybWFsLXZhcmlhYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbiB1bmVzY2FwZWQgdmVyc2lvbiBvZiB0aGUgdmFyaWFibGUsIHRvb1xyXG4gICAgICAgICAgICAgICAgQ3VzdG9tQXV0b2NvbXBsZXRlSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF1dG9jb21wbGV0ZV9pdGVtX3ZhbHVlLnJlcGxhY2UoL157ey8sIFwie3shXCIpLCAvLyBBZGQgYW4gZXhjbGFtYXRpb24gbWFyayB0byB0aGUgdmFyaWFibGUgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICBoZWxwX3RleHQ6IGF1dG9jb21wbGV0ZV9pdGVtX2xhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cF9uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidW5lc2NhcGVkLXZhcmlhYmxlXCIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWxsIG9rXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VfYW5kX3NvcnRfYXV0b2NvbXBsZXRlX2l0ZW1zKC4uLmF1dG9jb21wbGV0ZV9pdGVtX3NldHM6IElBdXRvY29tcGxldGVJdGVtW11bXSkge1xyXG4gICAgY29uc3QgbWVyZ2VkX2F1dG9jb21wbGV0ZV9pdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSA9IFtdLmNvbmNhdCguLi5hdXRvY29tcGxldGVfaXRlbV9zZXRzKTtcclxuICAgIHJldHVybiBtZXJnZWRfYXV0b2NvbXBsZXRlX2l0ZW1zLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAvLyBGaXJzdCBjb21wYXJlIGdyb3Vwc1xyXG4gICAgICAgIGlmIChhLmdyb3VwIDwgYi5ncm91cCkge1xyXG4gICAgICAgICAgICAvLyBhJ3MgZ3JvdXAgc2hvdWxkIGNvbWUgYmVmb3JlIGIncyBncm91cC5cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYS5ncm91cCA+IGIuZ3JvdXApIHtcclxuICAgICAgICAgICAgLy8gYSdzIGdyb3VwIHNob3VsZCBjb21lIGFmdGVyIGIncyBncm91cC5cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGdyb3VwcyBhcmUgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgdmFsdWVzLlxyXG4gICAgICAgICAgICBpZiAoYS52YWx1ZSA8IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgc2hvdWxkIGNvbWUgYmVmb3JlIGIuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS52YWx1ZSA+IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgc2hvdWxkIGNvbWUgYWZ0ZXIgYi5cclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlcyBhcmUgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZSBBdXRvY29tcGxldGVTZWFyY2hRdWVyeVR5cGUgPSBcIm90aGVyXCIgfCBcIm5vcm1hbC12YXJpYWJsZVwiIHwgXCJ1bmVzY2FwZWQtdmFyaWFibGVcIjtcclxuaW50ZXJmYWNlIElBdXRvY29tcGxldGVTZWFyY2hRdWVyeSB7XHJcbiAgICBzZWFyY2hfdGV4dDogc3RyaW5nO1xyXG4gICAgc2VhcmNoX3R5cGU6IEF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5VHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZHVjZXMgYW4gaW5wdXQgc3RyaW5nIHRvIHRoZSBuZWFyZXN0IGxvZ2ljYWwgd29yZC5cclxuICogQHBhcmFtIHR5cGVkX3RleHRcclxuICovXHJcbmZ1bmN0aW9uIGdldF9zZWFyY2hfcXVlcnkodHlwZWRfdGV4dDogc3RyaW5nKTogSUF1dG9jb21wbGV0ZVNlYXJjaFF1ZXJ5IHtcclxuICAgIGxldCBzZWFyY2hfdGV4dCA9IHR5cGVkX3RleHQubWF0Y2goL1xcUyo/JC8pWzBdOyAvLyBSZWR1Y2UgdGhlIHRleHQgLSBsaW1pdCB0byBhIHNpbmdsZSB3b3JkICg9IGV4Y2x1ZGUgc3BhY2VzIGFuZCBldmVyeXRoaW5nIGJlZm9yZSB0aGVtKS5cclxuICAgIGxldCBzZWFyY2hfdHlwZTogQXV0b2NvbXBsZXRlU2VhcmNoUXVlcnlUeXBlID0gXCJvdGhlclwiOyAvLyBNYXkgYmUgb3ZlcndyaXR0ZW4uXHJcblxyXG4gICAgaWYgKHNlYXJjaF90ZXh0LmNvbnRhaW5zKFwifX1cIikpIHtcclxuICAgICAgICAvLyBUaGUgcXVlcnkgaGFwcGVucyByaWdodCBhZnRlciBhIHt7dmFyaWFibGV9fS5cclxuICAgICAgICAvLyBNYWtlIHRoZSBxdWVyeSBzdHJpbmcgdG8gc3RhcnQgYWZ0ZXIgdGhlIH19IHBhaXIsIGkuZS4gcmVtb3ZlIH19IGFuZCBldmVyeXRoaW5nIGJlZm9yZSBpdC4gVGhpcyBpbXByb3ZlcyB0aGUgc2VhcmNoLlxyXG4gICAgICAgIHNlYXJjaF90ZXh0ID0gc2VhcmNoX3RleHQucmVwbGFjZSgvLit9fS8sIFwiXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlYXJjaF90ZXh0LmNvbnRhaW5zKFwie3tcIikpIHtcclxuICAgICAgICAvLyBBIHt7dmFyaWFibGV9fSBpcyBiZWluZyBxdWVyaWVkLlxyXG4gICAgICAgIC8vIE1ha2UgdGhlIHF1ZXJ5IHN0cmluZyB0byBzdGFydCBmcm9tIHRoZSB7eyBwYWlyLCBpLmUuIHJlbW92ZSBldmVyeXRoaW5nIGJlZm9yZSB7eyAuIFRoaXMgaW1wcm92ZXMgdGhlIHNlYXJjaC5cclxuICAgICAgICBzZWFyY2hfdGV4dCA9IHNlYXJjaF90ZXh0LnJlcGxhY2UoLy4re3svLCBcInt7XCIpO1xyXG4gICAgICAgIGlmIChzZWFyY2hfdGV4dC5jb250YWlucyhcInt7IVwiKSkge1xyXG4gICAgICAgICAgICAvLyBBbiBfdW5lc2NhcGVkXyB2YXJpYWJsZSBpcyBzZWFyY2hlZCBmb3IuXHJcbiAgICAgICAgICAgIHNlYXJjaF90eXBlID0gXCJ1bmVzY2FwZWQtdmFyaWFibGVcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBIG5vcm1hbCB2YXJpYWJsZSBpcyBzZWFyY2hlZCBmb3IuXHJcbiAgICAgICAgICAgIHNlYXJjaF90eXBlID0gXCJub3JtYWwtdmFyaWFibGVcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlYXJjaF90ZXh0OiBzZWFyY2hfdGV4dCxcclxuICAgICAgICBzZWFyY2hfdHlwZTogc2VhcmNoX3R5cGUsXHJcbiAgICB9O1xyXG59IiwiaW1wb3J0IHtnZXRWYXJpYWJsZUNsYXNzZXN9IGZyb20gXCIuL1ZhcmlhYmxlTGlzdHNcIjtcclxuaW1wb3J0IHtJQXV0b2NvbXBsZXRlSXRlbX0gZnJvbSBcIi4uL3NldHRpbmdzL3NldHRpbmdfZWxlbWVudHMvQXV0b2NvbXBsZXRlXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtcygpIHtcclxuICAgIGNvbnN0IGF1dG9jb21wbGV0ZV9pdGVtczogSUF1dG9jb21wbGV0ZUl0ZW1bXSA9IFtdO1xyXG4gICAgZ2V0VmFyaWFibGVDbGFzc2VzKCkuZm9yRWFjaCgodmFyaWFibGVfY2xhc3MpID0+IHtcclxuICAgICAgICBhdXRvY29tcGxldGVfaXRlbXMucHVzaCguLi52YXJpYWJsZV9jbGFzcy5nZXRBdXRvY29tcGxldGVJdGVtcygpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGF1dG9jb21wbGV0ZV9pdGVtcztcclxufSIsImltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcclxuaW1wb3J0IHtTZXR0aW5nRmllbGRHcm91cH0gZnJvbSBcIi4uL1NDX01haW5TZXR0aW5nc1RhYlwiO1xyXG5pbXBvcnQge1NldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge3BhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzfSBmcm9tIFwiLi4vLi4vdmFyaWFibGVzL3BhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7Y3JlYXRlQXV0b2NvbXBsZXRlfSBmcm9tIFwiLi9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtnZXRWYXJpYWJsZUF1dG9jb21wbGV0ZUl0ZW1zfSBmcm9tIFwiLi4vLi4vdmFyaWFibGVzL2dldFZhcmlhYmxlQXV0b2NvbXBsZXRlSXRlbXNcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVTaGVsbENvbW1hbmRGaWVsZENvcmUoXHJcbiAgICBwbHVnaW46IFNDX1BsdWdpbixcclxuICAgIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCxcclxuICAgIHNldHRpbmdfbmFtZTogc3RyaW5nLFxyXG4gICAgc2hlbGxfY29tbWFuZDogc3RyaW5nLFxyXG4gICAgc2hlbGw6IHN0cmluZyxcclxuICAgIHNob3dfYXV0b2NvbXBsZXRlX21lbnU6IGJvb2xlYW4sXHJcbiAgICBleHRyYV9vbl9jaGFuZ2U6IChzaGVsbF9jb21tYW5kOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgICBzaGVsbF9jb21tYW5kX3BsYWNlaG9sZGVyOiBzdHJpbmcgPSBcIkVudGVyIHlvdXIgY29tbWFuZFwiXHJcbiAgICApIHtcclxuXHJcbiAgICBsZXQgc2V0dGluZ19ncm91cDogU2V0dGluZ0ZpZWxkR3JvdXA7XHJcblxyXG4gICAgZnVuY3Rpb24gb25fY2hhbmdlKHNoZWxsX2NvbW1hbmQ6IHN0cmluZykge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBwcmV2aWV3XHJcbiAgICAgICAgc2V0dGluZ19ncm91cC5wcmV2aWV3X3NldHRpbmcuc2V0RGVzYyhnZXRTaGVsbENvbW1hbmRQcmV2aWV3KHBsdWdpbiwgc2hlbGxfY29tbWFuZCwgc2hlbGwpKTtcclxuXHJcbiAgICAgICAgLy8gTGV0IHRoZSBjYWxsZXIgZXh0ZW5kIHRoaXMgb25DaGFuZ2UsIHRvIHByZWZvcm0gc2F2aW5nIHRoZSBzZXR0aW5nczpcclxuICAgICAgICBleHRyYV9vbl9jaGFuZ2Uoc2hlbGxfY29tbWFuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dGluZ19ncm91cCA9IHtcclxuICAgICAgICBuYW1lX3NldHRpbmc6XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoc2V0dGluZ19uYW1lKVxyXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKFwiU0MtbmFtZS1zZXR0aW5nXCIpXHJcbiAgICAgICAgLFxyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfc2V0dGluZzpcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoc2hlbGxfY29tbWFuZF9wbGFjZWhvbGRlcilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoc2hlbGxfY29tbWFuZClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2Uob25fY2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKFwiU0Mtc2hlbGwtY29tbWFuZC1zZXR0aW5nXCIpXHJcbiAgICAgICAgLFxyXG4gICAgICAgIHByZXZpZXdfc2V0dGluZzpcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhnZXRTaGVsbENvbW1hbmRQcmV2aWV3KHBsdWdpbixzaGVsbF9jb21tYW5kLCBzaGVsbCkpXHJcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3MoXCJTQy1wcmV2aWV3LXNldHRpbmdcIilcclxuICAgICAgICAsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEF1dG9jb21wbGV0ZSBtZW51XHJcbiAgICBpZiAoc2hvd19hdXRvY29tcGxldGVfbWVudSkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjb25zdCBpbnB1dF9lbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50ID0gc2V0dGluZ19ncm91cC5zaGVsbF9jb21tYW5kX3NldHRpbmcuc2V0dGluZ0VsLmZpbmQoXCJpbnB1dFwiKTtcclxuICAgICAgICBjcmVhdGVBdXRvY29tcGxldGUoaW5wdXRfZWxlbWVudCwgZ2V0VmFyaWFibGVBdXRvY29tcGxldGVJdGVtcygpLCBvbl9jaGFuZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzZXR0aW5nX2dyb3VwO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAcGFyYW0gc2hlbGxfY29tbWFuZFxyXG4gKiBAcHVibGljIEV4cG9ydGVkIGJlY2F1c2UgY3JlYXRlU2hlbGxDb21tYW5kRmllbGQgdXNlcyB0aGlzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoZWxsQ29tbWFuZFByZXZpZXcocGx1Z2luOiBTQ19QbHVnaW4sIHNoZWxsX2NvbW1hbmQ6IHN0cmluZywgc2hlbGw6IHN0cmluZykge1xyXG4gICAgY29uc3QgcGFyc2VkX3NoZWxsX2NvbW1hbmQgPSBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcyhwbHVnaW4sIHNoZWxsX2NvbW1hbmQsIHNoZWxsKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZF9zaGVsbF9jb21tYW5kKSkge1xyXG4gICAgICAgIC8vIFZhcmlhYmxlIHBhcnNpbmcgZmFpbGVkLlxyXG4gICAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlLCBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBlcnJvcnMsIGJlY2F1c2UgdGhlIHByZXZpZXcgc3BhY2UgaXMgbGltaXRlZC5cclxuICAgICAgICByZXR1cm4gcGFyc2VkX3NoZWxsX2NvbW1hbmRbMF07XHJcbiAgICB9XHJcbiAgICAvLyBWYXJpYWJsZSBwYXJzaW5nIHN1Y2NlZWRlZFxyXG4gICAgcmV0dXJuIHBhcnNlZF9zaGVsbF9jb21tYW5kO1xyXG59IiwiaW1wb3J0IHtDcmVhdGVTaGVsbENvbW1hbmRGaWVsZENvcmV9IGZyb20gXCIuL0NyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZVwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uLy4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtQbGF0Zm9ybUlkLCBQbGF0Zm9ybU5hbWVzfSBmcm9tIFwiLi4vU0NfTWFpblNldHRpbmdzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkKHBsdWdpbjogU0NfUGx1Z2luLCBjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCwgcGxhdGZvcm1faWQ6IFBsYXRmb3JtSWQsIHNob3dfYXV0b2NvbXBsZXRlX21lbnU6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IHBsYXRmb3JtX25hbWUgPSBQbGF0Zm9ybU5hbWVzW3BsYXRmb3JtX2lkXTtcclxuICAgIGNvbnN0IHNldHRpbmdfZ3JvdXAgPSBDcmVhdGVTaGVsbENvbW1hbmRGaWVsZENvcmUoXHJcbiAgICAgICAgcGx1Z2luLFxyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LFxyXG4gICAgICAgIFwiU2hlbGwgY29tbWFuZCBvbiBcIiArIHBsYXRmb3JtX25hbWUsXHJcbiAgICAgICAgdF9zaGVsbF9jb21tYW5kLmdldFBsYXRmb3JtU3BlY2lmaWNTaGVsbENvbW1hbmRzKClbcGxhdGZvcm1faWRdID8/IFwiXCIsXHJcbiAgICAgICAgdF9zaGVsbF9jb21tYW5kLmdldFNoZWxsKCksXHJcbiAgICAgICAgc2hvd19hdXRvY29tcGxldGVfbWVudSxcclxuICAgICAgICBhc3luYyAoc2hlbGxfY29tbWFuZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaGVsbF9jb21tYW5kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hlbGxfY29tbWFuZCBpcyBub3QgZW1wdHksIHNvIGl0J3MgYSBub3JtYWwgY29tbWFuZC5cclxuICAgICAgICAgICAgICAgIHRfc2hlbGxfY29tbWFuZC5nZXRQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kcygpW3BsYXRmb3JtX2lkXSA9IHNoZWxsX2NvbW1hbmQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaGVsbF9jb21tYW5kIGlzIGVtcHR5LCBzbyB0aGUgZGVmYXVsdCBjb21tYW5kIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRfc2hlbGxfY29tbWFuZC5nZXRQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kcygpW3BsYXRmb3JtX2lkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQuZ2V0RGVmYXVsdFNoZWxsQ29tbWFuZCgpLFxyXG4gICAgKTtcclxuICAgIHNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nLnNldERlc2MoXCJJZiBlbXB0eSwgdGhlIGRlZmF1bHQgc2hlbGwgY29tbWFuZCB3aWxsIGJlIHVzZWQgb24gXCIgKyBwbGF0Zm9ybV9uYW1lICsgXCIuXCIpO1xyXG4gICAgcmV0dXJuIHNldHRpbmdfZ3JvdXA7XHJcbn0iLCJpbXBvcnQge3NldEljb259IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWIge1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIGljb246IHN0cmluZztcclxuICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYlN0cnVjdHVyZSB7XHJcbiAgICBoZWFkZXI6IEhUTUxFbGVtZW50LFxyXG4gICAgYnV0dG9uczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IEhUTUxFbGVtZW50LFxyXG4gICAgfVxyXG4gICAgY29udGVudENvbnRhaW5lcnM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCxcclxuICAgIH0sXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFicyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBUYWI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUYWJDb250ZW50Q29udGFpbmVycyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCxcclxufVxyXG5cclxuaW50ZXJmYWNlIFRhYkJ1dHRvbnMge1xyXG4gICAgW2tleTogc3RyaW5nXTogSFRNTEVsZW1lbnQsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJzKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdGFiczogVGFicyk6IFRhYlN0cnVjdHVyZSB7XHJcbiAgICBjb25zdCB0YWJfaGVhZGVyID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJTQy10YWItaGVhZGVyXCJ9fSk7XHJcbiAgICBjb25zdCB0YWJfY29udGVudF9jb250YWluZXJzOiBUYWJDb250ZW50Q29udGFpbmVycyA9IHt9O1xyXG4gICAgY29uc3QgdGFiX2J1dHRvbnM6IFRhYkJ1dHRvbnMgPSB7fTtcclxuICAgIGxldCBmaXJzdF9idXR0b246IEhUTUxFbGVtZW50O1xyXG4gICAgZm9yIChjb25zdCB0YWJfaWQgaW4gdGFicykge1xyXG4gICAgICAgIGNvbnN0IHRhYiA9IHRhYnNbdGFiX2lkXTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRhYl9oZWFkZXIuY3JlYXRlRWwoXCJidXR0b25cIiwge1xyXG4gICAgICAgICAgICBhdHRyOiB7XHJcbiAgICAgICAgICAgICAgICBjbGFzczogXCJTQy10YWItaGVhZGVyLWJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZhdGVUYWI6IFwiU0MtdGFiLVwiICsgdGFiX2lkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJ1dHRvbi5vbmNsaWNrID0gdGFiX2J1dHRvbl9jbGlja2VkO1xyXG4gICAgICAgIHNldEljb24oYnV0dG9uLCB0YWIuaWNvbik7XHJcbiAgICAgICAgYnV0dG9uLmluc2VydEFkamFjZW50VGV4dChcImJlZm9yZWVuZFwiLCBcIiBcIiArIHRhYi50aXRsZSk7XHJcbiAgICAgICAgdGFiX2J1dHRvbnNbdGFiX2lkXSA9IGJ1dHRvbjtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRlbnQgY29udGFpbmVyXHJcbiAgICAgICAgdGFiX2NvbnRlbnRfY29udGFpbmVyc1t0YWJfaWRdID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJTQy10YWItY29udGVudFwiLCBpZDogXCJTQy10YWItXCIgKyB0YWJfaWR9fSk7XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIGNvbnRlbnRcclxuICAgICAgICB0YWIuY29udGVudF9nZW5lcmF0b3IodGFiX2NvbnRlbnRfY29udGFpbmVyc1t0YWJfaWRdKTtcclxuXHJcbiAgICAgICAgLy8gTWVtb3JpemUgdGhlIGZpcnN0IHRhYidzIGJ1dHRvblxyXG4gICAgICAgIGlmICghZmlyc3RfYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGZpcnN0X2J1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0aXZhdGUgdGhlIGZpcnN0IHRhYlxyXG4gICAgaWYgKGZpcnN0X2J1dHRvbikge1xyXG4gICAgICAgIGZpcnN0X2J1dHRvbi5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybiBhIFRhYlN0cnVjdHVyZVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXI6IHRhYl9oZWFkZXIsXHJcbiAgICAgICAgYnV0dG9uczogdGFiX2J1dHRvbnMsXHJcbiAgICAgICAgY29udGVudENvbnRhaW5lcnM6IHRhYl9jb250ZW50X2NvbnRhaW5lcnMsXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0YWJfYnV0dG9uX2NsaWNrZWQoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgIGNvbnN0IHRhYl9idXR0b24gPSB0aGlzIGFzIEhUTUxFbGVtZW50OyAvLyBVc2UgJ3RoaXMnIGluc3RlYWQgb2YgZXZlbnQudGFyZ2V0IGJlY2F1c2UgdGhpcyB3YXkgd2UnbGwgYWx3YXlzIGdldCBhIGJ1dHRvbiBlbGVtZW50LCBub3QgYW4gZWxlbWVudCBpbnNpZGUgdGhlICBidXR0b24gKGkuZS4gYW4gaWNvbikuXHJcblxyXG4gICAgLy8gSGlkZSBhbGwgdGFiIGNvbnRlbnRzIGFuZCBnZXQgdGhlIG1heCBkaW1lbnNpb25zXHJcbiAgICBsZXQgbWF4X3dpZHRoID0gMDtcclxuICAgIGxldCBtYXhfaGVpZ2h0ID0gMDtcclxuICAgIGNvbnN0IHRhYl9oZWFkZXIgPSB0YWJfYnV0dG9uLnBhcmVudEVsZW1lbnQ7XHJcbiAgICBjb25zdCBjb250YWluZXJfZWxlbWVudCA9IHRhYl9oZWFkZXIucGFyZW50RWxlbWVudDtcclxuICAgIGNvbnN0IHRhYl9jb250ZW50cyA9IGNvbnRhaW5lcl9lbGVtZW50LmZpbmRBbGwoXCJkaXYuU0MtdGFiLWNvbnRlbnRcIik7IC8vIERvIG5vdCBnZXQgYWxsIHRhYiBjb250ZW50cyB0aGF0IGV4aXN0LCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIHRhYiBzeXN0ZW1zIG9wZW4gYXQgdGhlIHNhbWUgdGltZS5cclxuICAgIGNvbnN0IGlzX21haW5fc2V0dGluZ3NfbW9kYWwgPSBjb250YWluZXJfZWxlbWVudC5oYXNDbGFzcyhcInZlcnRpY2FsLXRhYi1jb250ZW50XCIpO1xyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gdGFiX2NvbnRlbnRzKSB7XHJcbiAgICAgICAgbGV0IHRhYl9jb250ZW50ID0gdGFiX2NvbnRlbnRzW2luZGV4XTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIHRhYiBkaW1lbnNpb25zIHNvIHRoYXQgYWxsIHRhYnMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy5cclxuICAgICAgICAvLyBCdXQgZG9uJ3QgZG8gaXQgaWYgdGhpcyBpcyB0aGUgbWFpbiBzZXR0aW5ncyBtb2RhbFxyXG4gICAgICAgIGlmICghaXNfbWFpbl9zZXR0aW5nc19tb2RhbCkge1xyXG4gICAgICAgICAgICB0YWJfY29udGVudC5hZGRDbGFzcyhcIlNDLXRhYi1hY3RpdmVcIik7IC8vIE5lZWQgdG8gbWFrZSB0aGUgdGFiIHZpc2libGUgdGVtcG9yYXJpbHkgaW4gb3JkZXIgdG8gZ2V0IHRoZSBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICBpZiAodGFiX2NvbnRlbnQub2Zmc2V0SGVpZ2h0ID4gbWF4X2hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgbWF4X2hlaWdodCA9IHRhYl9jb250ZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFiX2NvbnRlbnQub2Zmc2V0V2lkdGggPiBtYXhfd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIG1heF93aWR0aCA9IHRhYl9jb250ZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5hbGx5IGhpZGUgdGhlIHRhYlxyXG4gICAgICAgIHRhYl9jb250ZW50LnJlbW92ZUNsYXNzKFwiU0MtdGFiLWFjdGl2ZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgYWN0aXZlIHN0YXR1cyBmcm9tIGFsbCBidXR0b25zXHJcbiAgICBjb25zdCBhZGphY2VudF90YWJfYnV0dG9ucyA9IHRhYl9oZWFkZXIuZmluZEFsbChcIi5TQy10YWItaGVhZGVyLWJ1dHRvblwiKTsgLy8gRG8gbm90IGdldCBhbGwgdGFiIGJ1dHRvbnMgdGhhdCBleGlzdCwgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0YWIgc3lzdGVtcyBvcGVuIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIGFkamFjZW50X3RhYl9idXR0b25zKSB7XHJcbiAgICAgICAgbGV0IHRhYl9idXR0b24gPSBhZGphY2VudF90YWJfYnV0dG9uc1tpbmRleF07XHJcbiAgICAgICAgdGFiX2J1dHRvbi5yZW1vdmVDbGFzcyhcIlNDLXRhYi1hY3RpdmVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWN0aXZhdGUgdGhlIGNsaWNrZWQgdGFiXHJcbiAgICB0YWJfYnV0dG9uLmFkZENsYXNzKFwiU0MtdGFiLWFjdGl2ZVwiKTtcclxuICAgIGNvbnN0IGFjdGl2YXRlX3RhYl9pZCA9IHRhYl9idXR0b24uYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oXCJhY3RpdmF0ZVRhYlwiKS52YWx1ZTtcclxuICAgIGNvbnN0IHRhYl9jb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYWN0aXZhdGVfdGFiX2lkKTtcclxuICAgIHRhYl9jb250ZW50LmFkZENsYXNzKFwiU0MtdGFiLWFjdGl2ZVwiKTtcclxuXHJcbiAgICAvLyBGb2N1cyBhbiBlbGVtZW50IChpZiBhIGZvY3VzYWJsZSBlbGVtZW50IGlzIHByZXNlbnQpXHJcbiAgICB0YWJfY29udGVudC5maW5kKFwiLlNDLWZvY3VzLWVsZW1lbnQtb24tdGFiLW9wZW5pbmdcIik/LmZvY3VzKCkgLy8gPyA9IElmIG5vdCBmb3VuZCwgZG8gbm90aGluZy5cclxuXHJcbiAgICAvLyBBcHBseSB0aGUgbWF4IGRpbWVuc2lvbnMgdG8gdGhpcyB0YWJcclxuICAgIC8vIEJ1dCBkb24ndCBkbyBpdCBpZiB0aGlzIGlzIHRoZSBtYWluIHNldHRpbmdzIG1vZGFsXHJcbiAgICBpZiAoIWlzX21haW5fc2V0dGluZ3NfbW9kYWwpIHtcclxuICAgICAgICB0YWJfY29udGVudC5zdHlsZS53aWR0aCA9IG1heF93aWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGFiX2NvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gbWF4X2hlaWdodCtcInB4XCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gbm90aGluZyBlbHNlIChJIGRvbid0IGtub3cgaWYgdGhpcyBpcyBuZWVkZWQgb3Igbm90KVxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufSIsImltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9vbkxheW91dFJlYWR5IGV4dGVuZHMgU0NfRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJvbi1sYXlvdXQtcmVhZHlcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkFmdGVyIE9ic2lkaWFuIHN0YXJ0c1wiO1xyXG4gICAgcHJvdGVjdGVkIHJlZ2lzdGVyX2FmdGVyX2NoYW5naW5nX3NldHRpbmdzID0gZmFsc2U7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB0aGlzLnRyaWdnZXIodF9zaGVsbF9jb21tYW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUaGUgYmFzZSBjbGFzcyBkb2VzIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIGFueXRoaW5nLlxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdW5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkIHtcclxuICAgICAgICAvLyBObyBuZWVkIHRvIHVucmVnaXN0ZXIsIGJlY2F1c2UgdGhpcyBldmVudCBoYXBwZW5zIG9ubHkgb25jZSB3aGVuIE9ic2lkaWFuIHN0YXJ0cy4gSWYgdGhlIGV2ZW50IGlzIG5vdCBlbmFibGVkIGZvciBhIHNoZWxsIGNvbW1hbmQsIG5leHQgdGltZSBPYnNpZGlhbiBzdGFydHMsIHRoaXMgZXZlbnQgd29uJ3QgZ2V0IHJlZ2lzdGVyZWQuXHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtTQ19Xb3Jrc3BhY2VFdmVudH0gZnJvbSBcIi4vU0NfV29ya3NwYWNlRXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9vblF1aXQgZXh0ZW5kcyBTQ19Xb3Jrc3BhY2VFdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcIm9uLXF1aXRcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkJlZm9yZSBPYnNpZGlhbiBxdWl0c1wiO1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtzcGFjZV9ldmVudCA9IFwicXVpdFwiO1xyXG59IiwiaW1wb3J0IHtTQ19Xb3Jrc3BhY2VFdmVudH0gZnJvbSBcIi4vU0NfV29ya3NwYWNlRXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkIGV4dGVuZHMgU0NfV29ya3NwYWNlRXZlbnQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF9jb2RlID0gXCJvbi1hY3RpdmUtbGVhZi1jaGFuZ2VkXCI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X3RpdGxlID0gXCJBZnRlciBzd2l0Y2hpbmcgdGhlIGFjdGl2ZSBwYW5lXCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgd29ya3NwYWNlX2V2ZW50ID0gXCJhY3RpdmUtbGVhZi1jaGFuZ2VcIjtcclxufSIsImltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtTQ19FdmVudENvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NDX0V2ZW50Q29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQge05vdGljZSwgU2V0dGluZ30gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNDX0V2ZW50X0V2ZXJ5TlNlY29uZHMgZXh0ZW5kcyBTQ19FdmVudCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IGV2ZW50X2NvZGUgPSBcImV2ZXJ5LW4tc2Vjb25kc1wiO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBldmVudF90aXRsZSA9IFwiRXZlcnkgbiBzZWNvbmRzXCI7XHJcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdF9jb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uID0ge1xyXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIHNlY29uZHM6IDYwLFxyXG4gICAgfTtcclxuICAgIHByaXZhdGUgaW50ZXJ2YWxzX2lkczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IG51bWJlcjsgLy8ga2V5OiBUU2hlbGxDb21tYW5kIGlkLCB2YWx1ZTogc2V0SW50ZXJ2YWwoKSBpZC5cclxuICAgIH0gPSB7fTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3JlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kczogbnVtYmVyID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZCkuc2Vjb25kcyAqIDEwMDA7XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxfaWQ6IG51bWJlciA9IHdpbmRvdy5zZXRJbnRlcnZhbChcclxuICAgICAgICAgICAgKCkgPT4gdGhpcy50cmlnZ2VyKHRfc2hlbGxfY29tbWFuZCksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVySW50ZXJ2YWwoaW50ZXJ2YWxfaWQpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzX2lkc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0gPSBpbnRlcnZhbF9pZDtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBiYXNlIGNsYXNzIGRvZXMgbm90IG5lZWQgdG8gcmVnaXN0ZXIgYW55dGhpbmcuXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF91bnJlZ2lzdGVyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCk6IHZvaWQge1xyXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxzX2lkc1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBvbmx5IHRvIGNoYW5nZSB0aGUgcmV0dXJuIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gdF9zaGVsbF9jb21tYW5kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBnZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCk6IENvbmZpZ3VyYXRpb24ge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5nZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZCkgYXMgQ29uZmlndXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlRXh0cmFTZXR0aW5nc0ZpZWxkcyhleHRyYV9zZXR0aW5nc19jb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgbGV0IGFwcGx5X3NlY29uZHM6IG51bWJlcjtcclxuICAgICAgICBuZXcgU2V0dGluZyhleHRyYV9zZXR0aW5nc19jb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiU2Vjb25kc1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIk5lZWRzIHRvIGJlIGF0IGxlYXN0IDEuIEN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IGludGVnZXJzLlwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjb25maWd1cmF0aW9uLnNlY29uZHMudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgocmF3X3ZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBseV9zZWNvbmRzID0gcGFyc2VJbnQocmF3X3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzYXZlIGhlcmUsIGJlY2F1c2UgdGhlIHVzZXIgbWlnaHQgc3RpbGwgYmUgZWRpdGluZyB0aGUgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIkFwcGx5XCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PSBhcHBseV9zZWNvbmRzIHx8IGFwcGx5X3NlY29uZHMgPT09IHRoaXMuZ2V0Q29uZmlndXJhdGlvbih0X3NoZWxsX2NvbW1hbmQpLnNlY29uZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIllvdSBkaWRuJ3QgY2hhbmdlIHRoZSBzZWNvbmRzIVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oYXBwbHlfc2Vjb25kcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlRoZSBzZWNvbmRzIG5lZWQgdG8gYmUgYW4gaW50ZWdlciFcIilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGx5X3NlY29uZHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiVGhlIHNlY29uZHMgbmVlZCB0byBiZSBhdCBsZWFzdCAxIVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBvaywgc2F2ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZCkuc2Vjb25kcyA9IGFwcGx5X3NlY29uZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtcmVnaXN0ZXIgdG8gYXBwbHkgdGhlIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIodF9zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGljZUFib3V0RW5hYmxpbmcodF9zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQWZ0ZXJFbmFibGluZyh0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm5vdGljZUFib3V0RW5hYmxpbmcodF9zaGVsbF9jb21tYW5kKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG5vdGljZUFib3V0RW5hYmxpbmcodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kKSB7XHJcbiAgICAgICAgbmV3IE5vdGljZShcIlRoZSBzaGVsbCBjb21tYW5kIHdpbGwgcnVuIGV2ZXJ5IFwiICsgdGhpcy5nZXRDb25maWd1cmF0aW9uKHRfc2hlbGxfY29tbWFuZCkuc2Vjb25kcyArIFwiIHNlY29uZHNcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb25maWd1cmF0aW9uIGV4dGVuZHMgU0NfRXZlbnRDb25maWd1cmF0aW9uIHtcclxuICAgIHNlY29uZHM6IG51bWJlcixcclxufSIsImltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtFZGl0b3IsIE1hcmtkb3duVmlldywgTWVudX0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7U0NfTWVudUV2ZW50fSBmcm9tIFwiLi9TQ19NZW51RXZlbnRcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTQ19FdmVudF9FZGl0b3JNZW51IGV4dGVuZHMgU0NfTWVudUV2ZW50IHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfY29kZSA9IFwiZWRpdG9yLW1lbnVcIjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgZXZlbnRfdGl0bGUgPSBcIkVkaXRvciBtZW51XCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgd29ya3NwYWNlX2V2ZW50ID0gXCJlZGl0b3ItbWVudVwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZXRUcmlnZ2VyKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiAobWVudTogTWVudSwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFRTaGVsbENvbW1hbmRUb01lbnUodF9zaGVsbF9jb21tYW5kLCBtZW51KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtTQ19FdmVudF9vbkxheW91dFJlYWR5fSBmcm9tIFwiLi9TQ19FdmVudF9vbkxheW91dFJlYWR5XCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfb25RdWl0fSBmcm9tIFwiLi9TQ19FdmVudF9vblF1aXRcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkfSBmcm9tIFwiLi9TQ19FdmVudF9vbkFjdGl2ZUxlYWZDaGFuZ2VkXCI7XHJcbmltcG9ydCB7U0NfRXZlbnRfRXZlcnlOU2Vjb25kc30gZnJvbSBcIi4vU0NfRXZlbnRfRXZlcnlOU2Vjb25kc1wiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZpbGVNZW51fSBmcm9tIFwiLi9TQ19FdmVudF9GaWxlTWVudVwiO1xyXG5pbXBvcnQge1NDX0V2ZW50X0ZvbGRlck1lbnV9IGZyb20gXCIuL1NDX0V2ZW50X0ZvbGRlck1lbnVcIjtcclxuaW1wb3J0IHtTQ19FdmVudF9FZGl0b3JNZW51fSBmcm9tIFwiLi9TQ19FdmVudF9FZGl0b3JNZW51XCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuL1NDX0V2ZW50XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U0NfRXZlbnRzKHBsdWdpbjogU0NfUGx1Z2luKSB7XHJcbiAgICBpZiAodW5kZWZpbmVkID09PSBnZXRTQ19FdmVudHMuZXZlbnRzKSB7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGxpc3Qgb2YgU0NfRXZlbnQgb2JqZWN0c1xyXG4gICAgICAgIGdldFNDX0V2ZW50cy5ldmVudHMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9vbkxheW91dFJlYWR5KHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9vblF1aXQocGx1Z2luKSxcclxuICAgICAgICAgICAgbmV3IFNDX0V2ZW50X29uQWN0aXZlTGVhZkNoYW5nZWQocGx1Z2luKSxcclxuICAgICAgICAgICAgbmV3IFNDX0V2ZW50X0V2ZXJ5TlNlY29uZHMocGx1Z2luKSxcclxuICAgICAgICAgICAgbmV3IFNDX0V2ZW50X0ZpbGVNZW51KHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9Gb2xkZXJNZW51KHBsdWdpbiksXHJcbiAgICAgICAgICAgIG5ldyBTQ19FdmVudF9FZGl0b3JNZW51KHBsdWdpbiksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRTQ19FdmVudHMuZXZlbnRzO1xyXG59XHJcbmdldFNDX0V2ZW50cy5ldmVudHMgPSB1bmRlZmluZWQ7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U0NfRXZlbnQocGx1Z2luOiBTQ19QbHVnaW4sIHNjX2V2ZW50X2NsYXNzOiB0eXBlb2YgU0NfRXZlbnQpIHtcclxuICAgIGxldCBmb3VuZF9zY19ldmVudDogU0NfRXZlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICBnZXRTQ19FdmVudHMocGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoc2NfZXZlbnQgaW5zdGFuY2VvZiBzY19ldmVudF9jbGFzcykge1xyXG4gICAgICAgICAgICBmb3VuZF9zY19ldmVudCA9IHNjX2V2ZW50O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZvdW5kX3NjX2V2ZW50O1xyXG59IiwiaW1wb3J0IHtBcHAsIE1vZGFsLCBzZXRJY29uLCBTZXR0aW5nfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNDX1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NldHRpbmdGaWVsZEdyb3VwLCBTQ19NYWluU2V0dGluZ3NUYWJ9IGZyb20gXCIuL1NDX01haW5TZXR0aW5nc1RhYlwiO1xyXG5pbXBvcnQge2dldE91dHB1dENoYW5uZWxEcml2ZXJzT3B0aW9uTGlzdH0gZnJvbSBcIi4uL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbCwgT3V0cHV0Q2hhbm5lbE9yZGVyLCBPdXRwdXRTdHJlYW19IGZyb20gXCIuLi9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbFwiO1xyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7Q29tbWFuZFBhbGV0dGVPcHRpb25zLCBJQ29tbWFuZFBhbGV0dGVPcHRpb25zLCBQbGF0Zm9ybUlkLCBQbGF0Zm9ybU5hbWVzfSBmcm9tIFwiLi9TQ19NYWluU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtjcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkfSBmcm9tIFwiLi9zZXR0aW5nX2VsZW1lbnRzL0NyZWF0ZVNoZWxsU2VsZWN0aW9uRmllbGRcIjtcclxuaW1wb3J0IHtcclxuICAgIGdlbmVyYXRlSWdub3JlZEVycm9yQ29kZXNJY29uVGl0bGUsXHJcbiAgICBnZW5lcmF0ZVNoZWxsQ29tbWFuZEZpZWxkTmFtZVxyXG59IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlU2hlbGxDb21tYW5kRmllbGRcIjtcclxuaW1wb3J0IHtjcmVhdGVQbGF0Zm9ybVNwZWNpZmljU2hlbGxDb21tYW5kRmllbGR9IGZyb20gXCIuL3NldHRpbmdfZWxlbWVudHMvQ3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkXCI7XHJcbmltcG9ydCB7Y3JlYXRlVGFicywgVGFiU3RydWN0dXJlfSBmcm9tIFwiLi9zZXR0aW5nX2VsZW1lbnRzL1RhYnNcIjtcclxuaW1wb3J0IHtnZXRTQ19FdmVudHN9IGZyb20gXCIuLi9ldmVudHMvU0NfRXZlbnRMaXN0XCI7XHJcbmltcG9ydCB7U0NfRXZlbnR9IGZyb20gXCIuLi9ldmVudHMvU0NfRXZlbnRcIjtcclxuaW1wb3J0IHtnb3RvVVJMfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRXh0cmFPcHRpb25zTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIEdFTkVSQUxfT1BUSU9OU19TVU1NQVJZID0gXCJBbGlhcywgQ29uZmlybWF0aW9uXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIE9VVFBVVF9PUFRJT05TX1NVTU1BUlkgPSBcIlN0ZG91dC9zdGRlcnIgaGFuZGxpbmcsIElnbm9yZSBlcnJvcnNcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgT1BFUkFUSU5HX1NZU1RFTVNfQU5EX1NIRUxMU19PUFRJT05TX1NVTU1BUlkgPSBcIlNoZWxsIHNlbGVjdGlvbiwgT3BlcmF0aW5nIHN5c3RlbSBzcGVjaWZpYyBzaGVsbCBjb21tYW5kc1wiO1xyXG4gICAgcHVibGljIHN0YXRpYyBFVkVOVFNfU1VNTUFSWSA9IFwiRXZlbnRzXCI7XHJcblxyXG4gICAgcHJpdmF0ZSBwbHVnaW46IFNDX1BsdWdpbjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQ7XHJcbiAgICBwcml2YXRlIG5hbWVfc2V0dGluZzogU2V0dGluZztcclxuICAgIHByaXZhdGUgc2V0dGluZ190YWI6IFNDX01haW5TZXR0aW5nc1RhYjtcclxuICAgIHByaXZhdGUgdGFiX3N0cnVjdHVyZTogVGFiU3RydWN0dXJlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nLCBzZXR0aW5nX2dyb3VwOiBTZXR0aW5nRmllbGRHcm91cCwgc2V0dGluZ190YWI6IFNDX01haW5TZXR0aW5nc1RhYikge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2lkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG4gICAgICAgIHRoaXMubmFtZV9zZXR0aW5nID0gc2V0dGluZ19ncm91cC5uYW1lX3NldHRpbmc7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5nX3RhYiA9IHNldHRpbmdfdGFiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiaDJcIiwge3RleHQ6IHRoaXMudF9zaGVsbF9jb21tYW5kLmdldERlZmF1bHRTaGVsbENvbW1hbmQoKX0pO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHRoZSBtb2RhbCBzY3JvbGxhYmxlIGlmIGl0IGhhcyBtb3JlIGNvbnRlbnQgdGhhbiB3aGF0IGZpdHMgaW4gdGhlIHNjcmVlbi5cclxuICAgICAgICB0aGlzLm1vZGFsRWwuYWRkQ2xhc3MoXCJTQy1zY3JvbGxhYmxlXCIpO1xyXG5cclxuICAgICAgICAvLyBUYWJzXHJcbiAgICAgICAgdGhpcy50YWJfc3RydWN0dXJlID0gY3JlYXRlVGFicyh0aGlzLm1vZGFsRWwsIHtcclxuICAgICAgICAgICAgXCJleHRyYS1vcHRpb25zLWdlbmVyYWxcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiR2VuZXJhbFwiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJnZWFyXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiR2VuZXJhbChjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImV4dHJhLW9wdGlvbnMtb3V0cHV0XCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk91dHB1dFwiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJsaW5lcy1vZi10ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiT3V0cHV0KGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZXh0cmEtb3B0aW9ucy1vcGVyYXRpbmctc3lzdGVtcy1hbmQtc2hlbGxzXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk9wZXJhdGluZyBzeXN0ZW1zICYgc2hlbGxzXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcInN0YWNrZWQtbGV2ZWxzXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiT3BlcmF0aW5nU3lzdGVtc0FuZFNoZWxscyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImV4dHJhLW9wdGlvbnMtZXZlbnRzXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkV2ZW50c1wiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJkaWNlXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiRXZlbnRzKGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJHZW5lcmFsKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIC8vIEFsaWFzIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQWxpYXNcIilcclxuICAgICAgICAgICAgLnNldENsYXNzKFwiU0MtbmFtZS1zZXR0aW5nXCIpXHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNvbnN0IGFsaWFzX3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIGFjdHVhbCBhbGlhcyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5hbGlhcyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgT2JzaWRpYW4gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQucmVuYW1lT2JzaWRpYW5Db21tYW5kKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpLCB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlU2hlbGwgY29tbWFuZHMgc2V0dGluZ3MgcGFuZWxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVfc2V0dGluZy5zZXROYW1lKGdlbmVyYXRlU2hlbGxDb21tYW5kRmllbGROYW1lKHRoaXMuc2hlbGxfY29tbWFuZF9pZCwgdGhpcy50X3NoZWxsX2NvbW1hbmQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuc2V0Q2xhc3MoXCJTQy1zaGVsbC1jb21tYW5kLXNldHRpbmdcIilcclxuICAgICAgICA7XHJcbiAgICAgICAgYWxpYXNfc2V0dGluZy5jb250cm9sRWwuZmluZChcImlucHV0XCIpLmFkZENsYXNzKFwiU0MtZm9jdXMtZWxlbWVudC1vbi10YWItb3BlbmluZ1wiKTsgLy8gRm9jdXMgd2l0aG91dCBhIG5lZWQgdG8gY2xpY2sgdGhlIGZpZWxkLlxyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJJZiBub3QgZW1wdHksIHRoZSBhbGlhcyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgY29tbWFuZCBwYWxldHRlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21tYW5kLiBBbiBhbGlhcyBpcyBuZXZlciBleGVjdXRlZCBhcyBhIGNvbW1hbmQuXCJ9KTtcclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiWW91IGNhbiBhbHNvIHVzZSB0aGUgc2FtZSB7e319IHN0eWxlIHZhcmlhYmxlcyBpbiBhbGlhc2VzIHRoYXQgYXJlIHVzZWQgaW4gc2hlbGwgY29tbWFuZHMuIFdoZW4gdmFyaWFibGVzIGFyZSB1c2VkIGluIGFsaWFzZXMsIHRoZXkgZG8gbm90IGFmZmVjdCB0aGUgY29tbWFuZCBleGVjdXRpb24gaW4gYW55IHdheSwgYnV0IGl0J3MgYSBuaWNlIHdheSB0byByZXZlYWwgd2hhdCB2YWx1ZXMgeW91ciBjb21tYW5kIHdpbGwgdXNlLCBldmVuIHdoZW4gYW4gYWxpYXMgaGlkZXMgbW9zdCBvZiB0aGUgb3RoZXIgdGVjaG5pY2FsIGRldGFpbHMuIFN0YXJ0aW5nIGEgdmFyaWFibGUgd2l0aCB7eyEgd2lsbCBwcmV2ZW50IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBjb21tYW5kIHBhbGV0dGUuXCJ9KTtcclxuXHJcbiAgICAgICAgLy8gQ29uZmlybSBleGVjdXRpb24gZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJBc2sgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb25cIilcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlybUV4ZWN1dGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5jb25maXJtX2V4ZWN1dGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb25fY29udGFpbmVyID0gdGhpcy5uYW1lX3NldHRpbmcubmFtZUVsLmZpbmQoXCJzcGFuLnNoZWxsLWNvbW1hbmRzLWNvbmZpcm0tZXhlY3V0aW9uLWljb24tY29udGFpbmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRDb25maXJtRXhlY3V0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25fY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIuYWRkQ2xhc3MoXCJTQy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJPdXRwdXQoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgLy8gT3V0cHV0IGNoYW5uZWxpbmdcclxuICAgICAgICBjb25zdCBzdGRvdXRfY2hhbm5lbF9zZXR0aW5nID0gdGhpcy5uZXdPdXRwdXRDaGFubmVsU2V0dGluZyhjb250YWluZXJfZWxlbWVudCwgXCJPdXRwdXQgY2hhbm5lbCBmb3Igc3Rkb3V0XCIsIFwic3Rkb3V0XCIpO1xyXG4gICAgICAgIHRoaXMubmV3T3V0cHV0Q2hhbm5lbFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQsIFwiT3V0cHV0IGNoYW5uZWwgZm9yIHN0ZGVyclwiLCBcInN0ZGVyclwiLCBcIklmIGJvdGggc3Rkb3V0IGFuZCBzdGRlcnIgdXNlIHRoZSBzYW1lIGNoYW5uZWwsIHN0ZGVyciB3aWxsIGJlIGNvbWJpbmVkIHRvIHNhbWUgbWVzc2FnZSB3aXRoIHN0ZG91dC5cIik7XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT3JkZXIgb2Ygc3Rkb3V0L3N0ZGVyciBvdXRwdXRcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJXaGVuIG91dHB1dCBjb250YWlucyBib3RoIGVycm9ycyBhbmQgbm9ybWFsIG91dHB1dCwgd2hpY2ggb25lIHNob3VsZCBiZSBwcmVzZW50ZWQgZmlyc3Q/XCIpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgIFwic3Rkb3V0LWZpcnN0XCI6IFwiU3Rkb3V0IGZpcnN0LCB0aGVuIHN0ZGVyci5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInN0ZGVyci1maXJzdFwiOiBcIlN0ZGVyciBmaXJzdCwgdGhlbiBzdGRvdXQuXCIsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldE91dHB1dENoYW5uZWxPcmRlcigpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogT3V0cHV0Q2hhbm5lbE9yZGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLm91dHB1dF9jaGFubmVsX29yZGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBvbiB0aGUgc3Rkb3V0IGNoYW5uZWwgZHJvcGRvd24gZmllbGRcclxuICAgICAgICBzdGRvdXRfY2hhbm5lbF9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwic2VsZWN0XCIpLmFkZENsYXNzKFwiU0MtZm9jdXMtZWxlbWVudC1vbi10YWItb3BlbmluZ1wiKTtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGVycm9ycyBmaWVsZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIklnbm9yZSBlcnJvciBjb2Rlc1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbnVtYmVycy4gSWYgZXhlY3V0aW5nIGEgc2hlbGwgY29tbWFuZCBmYWlscyB3aXRoIG9uZSBvZiB0aGVzZSBleGl0IGNvZGVzLCBubyBlcnJvciBtZXNzYWdlIHdpbGwgYmUgZGlzcGxheWVkLCBhbmQgdGhlIGFib3ZlIHN0ZGVyciBjaGFubmVsIHdpbGwgYmUgaWdub3JlZC4gU3Rkb3V0IGNoYW5uZWwgd2lsbCBzdGlsbCBiZSB1c2VkIGZvciBzdGRvdXQuIEVycm9yIGNvZGVzIG11c3QgYmUgaW50ZWdlcnMgYW5kIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLiBBbnl0aGluZyBlbHNlIHdpbGwgYmUgcmVtb3ZlZC5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0SWdub3JlRXJyb3JDb2RlcygpLmpvaW4oXCIsXCIpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVfZXJyb3JfY29kZXM6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3X2Vycm9yX2NvZGVzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiByYXdfZXJyb3JfY29kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3X2Vycm9yX2NvZGUgPSByYXdfZXJyb3JfY29kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yX2NvZGVfY2FuZGlkYXRlID0gcGFyc2VJbnQocmF3X2Vycm9yX2NvZGUudHJpbSgpKTsgLy8gRS5nLiBhbiBlbXB0eSBzdHJpbmcgY29udmVydHMgdG8gTmFOICg9IE5vdCBhIE51bWJlcikuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBlcnJvciBjb2RlIGlzIG5vdCBOYU4sIDAgb3IgYSBuZWdhdGl2ZSBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oZXJyb3JfY29kZV9jYW5kaWRhdGUpICYmIGVycm9yX2NvZGVfY2FuZGlkYXRlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjYW5kaWRhdGUgaXMgbGVnaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVfZXJyb3JfY29kZXMucHVzaChlcnJvcl9jb2RlX2NhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHZhbGlkYXRlZCBlcnJvciBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmlnbm9yZV9lcnJvcl9jb2RlcyA9IGlnbm9yZV9lcnJvcl9jb2RlcztcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGljb25cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uX2NvbnRhaW5lciA9IHRoaXMubmFtZV9zZXR0aW5nLm5hbWVFbC5maW5kKFwic3Bhbi5zaGVsbC1jb21tYW5kcy1pZ25vcmVkLWVycm9yLWNvZGVzLWljb24tY29udGFpbmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX2NvbnRhaW5lci5zZXRBdHRyKFwiYXJpYS1sYWJlbFwiLCBnZW5lcmF0ZUlnbm9yZWRFcnJvckNvZGVzSWNvblRpdGxlKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldElnbm9yZUVycm9yQ29kZXMoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX2NvbnRhaW5lci5yZW1vdmVDbGFzcyhcIlNDLWhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25fY29udGFpbmVyLmFkZENsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiT3BlcmF0aW5nU3lzdGVtc0FuZFNoZWxscyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBQbGF0Zm9ybSBzcGVjaWZpYyBzaGVsbCBjb21tYW5kc1xyXG4gICAgICAgIGxldCBwbGF0Zm9ybV9pZDogUGxhdGZvcm1JZDtcclxuICAgICAgICBsZXQgaXNfZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgIGZvciAocGxhdGZvcm1faWQgaW4gUGxhdGZvcm1OYW1lcykge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nX2dyb3VwID0gY3JlYXRlUGxhdGZvcm1TcGVjaWZpY1NoZWxsQ29tbWFuZEZpZWxkKHRoaXMucGx1Z2luLCBjb250YWluZXJfZWxlbWVudCwgdGhpcy50X3NoZWxsX2NvbW1hbmQsIHBsYXRmb3JtX2lkLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KTtcclxuICAgICAgICAgICAgaWYgKGlzX2ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgZmlyc3QgT1Mgc3BlY2lmaWMgc2hlbGwgY29tbWFuZCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ19ncm91cC5zaGVsbF9jb21tYW5kX3NldHRpbmcuY29udHJvbEVsLmZpbmQoXCJpbnB1dFwiKS5hZGRDbGFzcyhcIlNDLWZvY3VzLWVsZW1lbnQtb24tdGFiLW9wZW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICBpc19maXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQbGF0Zm9ybSBzcGVjaWZpYyBzaGVsbCBzZWxlY3Rpb25cclxuICAgICAgICBjcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkKHRoaXMucGx1Z2luLCBjb250YWluZXJfZWxlbWVudCwgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxzKCksIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYkV2ZW50cyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBDb21tYW5kIHBhbGV0dGVcclxuICAgICAgICBjb25zdCBjb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5X3NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJBdmFpbGFiaWxpdHkgaW4gT2JzaWRpYW4ncyBjb21tYW5kIHBhbGV0dGVcIilcclxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9ucyhDb21tYW5kUGFsZXR0ZU9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBrZXlvZiBJQ29tbWFuZFBhbGV0dGVPcHRpb25zKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLmNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbW1hbmQgcGFsZXR0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRfc2hlbGxfY29tbWFuZC5jYW5BZGRUb0NvbW1hbmRQYWxldHRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdG8gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLnJlZ2lzdGVyVG9Db21tYW5kUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgZnJvbSBjb21tYW5kIHBhbGV0dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQudW5yZWdpc3RlckZyb21Db21tYW5kUGFsZXR0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIEZvY3VzIG9uIHRoZSBjb21tYW5kIHBhbGV0dGUgYXZhaWxhYmlsaXR5IGZpZWxkXHJcbiAgICAgICAgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eV9zZXR0aW5nLmNvbnRyb2xFbC5maW5kKFwic2VsZWN0XCIpLmFkZENsYXNzKFwiU0MtZm9jdXMtZWxlbWVudC1vbi10YWItb3BlbmluZ1wiKTtcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRXhlY3V0ZSB0aGlzIHNoZWxsIGNvbW1hbmQgYXV0b21hdGljYWxseSBvbjpcIilcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKSAvLyBNYWtlIHRoZSBuYW1lIGJvbGRcclxuICAgICAgICA7XHJcbiAgICAgICAgZ2V0U0NfRXZlbnRzKHRoaXMucGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNfZXZlbnRfZW5hYmxlZDogYm9vbGVhbiA9IHRoaXMudF9zaGVsbF9jb21tYW5kLmlzU0NfRXZlbnRFbmFibGVkKHNjX2V2ZW50LnN0YXRpYygpLmdldENvZGUoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnlfb2ZfZXh0cmFfdmFyaWFibGVzID0gc2NfZXZlbnQuZ2V0U3VtbWFyeU9mRXZlbnRWYXJpYWJsZXModGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGwoKSk7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoc2NfZXZlbnQuc3RhdGljKCkuZ2V0VGl0bGUoKSlcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKHN1bW1hcnlfb2ZfZXh0cmFfdmFyaWFibGVzID8gXCJBZGRpdGlvbmFsIHZhcmlhYmxlczogXCIgKyBzdW1tYXJ5X29mX2V4dHJhX3ZhcmlhYmxlcyA6IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoaXNfZXZlbnRfZW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKGVuYWJsZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC5lbmFibGVTQ19FdmVudChzY19ldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYV9zZXR0aW5nc19jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy8gU2hvdyBleHRyYSBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLmRpc2FibGVTQ19FdmVudChzY19ldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYV9zZXR0aW5nc19jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyAvLyBIaWRlIGV4dHJhIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEb2N1bWVudGF0aW9uIGljb25cclxuICAgICAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihpY29uID0+IGljb25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcImhlbHBcIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiBnb3RvVVJMKHNjX2V2ZW50LnN0YXRpYygpLmdldERvY3VtZW50YXRpb25MaW5rKCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRG9jdW1lbnRhdGlvbjogXCIgKyBzY19ldmVudC5zdGF0aWMoKS5nZXRUaXRsZSgpICsgXCIgZXZlbnRcIiksXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhIHNldHRpbmdzXHJcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhX3NldHRpbmdzX2NvbnRhaW5lciA9IGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZURpdigpO1xyXG4gICAgICAgICAgICBleHRyYV9zZXR0aW5nc19jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IGlzX2V2ZW50X2VuYWJsZWQgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcclxuICAgICAgICAgICAgc2NfZXZlbnQuY3JlYXRlRXh0cmFTZXR0aW5nc0ZpZWxkcyhleHRyYV9zZXR0aW5nc19jb250YWluZXIsIHRoaXMudF9zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVUYWIodGFiX2lkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLnRhYl9zdHJ1Y3R1cmUuYnV0dG9uc1t0YWJfaWRdKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCB0YWIgaWQ6IFwiICsgdGFiX2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YWJfc3RydWN0dXJlLmJ1dHRvbnNbdGFiX2lkXS5jbGljaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbmV3T3V0cHV0Q2hhbm5lbFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCB0aXRsZTogc3RyaW5nLCBvdXRwdXRfc3RyZWFtX25hbWU6IE91dHB1dFN0cmVhbSwgZGVzY3JpcHRpb246IHN0cmluZyA9IFwiXCIpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXRfY2hhbm5lbF9vcHRpb25zID0gZ2V0T3V0cHV0Q2hhbm5lbERyaXZlcnNPcHRpb25MaXN0KG91dHB1dF9zdHJlYW1fbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZSh0aXRsZSlcclxuICAgICAgICAgICAgLnNldERlc2MoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMob3V0cHV0X2NoYW5uZWxfb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRPdXRwdXRDaGFubmVscygpW291dHB1dF9zdHJlYW1fbmFtZV0pXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBPdXRwdXRDaGFubmVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50X3NoZWxsX2NvbW1hbmQuZ2V0Q29uZmlndXJhdGlvbigpLm91dHB1dF9jaGFubmVsc1tvdXRwdXRfc3RyZWFtX25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtNb2RhbH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtTZXR0aW5nRmllbGRHcm91cH0gZnJvbSBcIi4vU0NfTWFpblNldHRpbmdzVGFiXCI7XHJcbmltcG9ydCB7VFNoZWxsQ29tbWFuZH0gZnJvbSBcIi4uL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uL0RlYnVnXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRGVsZXRlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgICBwcml2YXRlIHBsdWdpbjogU0NfUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZDtcclxuICAgIHByaXZhdGUgc2V0dGluZ19ncm91cDogU2V0dGluZ0ZpZWxkR3JvdXA7XHJcbiAgICBwcml2YXRlIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFNDX1BsdWdpbiwgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nLCBzZXR0aW5nX2dyb3VwOiBTZXR0aW5nRmllbGRHcm91cCwgY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2lkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5nZXRUU2hlbGxDb21tYW5kcygpW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ19ncm91cCA9IHNldHRpbmdfZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJfZWxlbWVudCA9IGNvbnRhaW5lcl9lbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiaDJcIiwge3RleHQ6IFwiRGVsZXRlOiBcIiArIHRoaXMudF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudF9zaGVsbF9jb21tYW5kLmdldEFsaWFzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJBbGlhczogXCIgKyB0aGlzLnRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIHNoZWxsIGNvbW1hbmQ/XCJ9KTtcclxuICAgICAgICBjb25zdCBkZWxldGVfYnV0dG9uID0gdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHt0ZXh0OiBcIlllcywgZGVsZXRlXCJ9KTtcclxuICAgICAgICBkZWxldGVfYnV0dG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBvc3NpYmxlIGV2ZW50cyBpbiBvcmRlciB0byBwcmV2ZW50IHRoZW0gYmVjb21pbmcgZ2hvc3RzIHRoYXQganVzdCBrZWVwIGV4ZWN1dGluZyBldmVuIGFmdGVyIHJlbW92aW5nIHRoZSBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLnRfc2hlbGxfY29tbWFuZC51bnJlZ2lzdGVyU0NfRXZlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbW1hbmRcclxuICAgICAgICAgICAgZGVidWdMb2coXCJDb21tYW5kIFwiICsgdGhpcy5zaGVsbF9jb21tYW5kX2lkICsgXCIgZ29ubmEgYmUgcmVtb3ZlZC5cIik7XHJcbiAgICAgICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kLnVucmVnaXN0ZXJGcm9tQ29tbWFuZFBhbGV0dGUoKTsgLy8gUmVtb3ZlIGZyb20gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLmdldFRTaGVsbENvbW1hbmRzKClbdGhpcy5zaGVsbF9jb21tYW5kX2lkXTsgLy8gUmVtb3ZlIHRoZSBUU2hlbGxDb21tYW5kIG9iamVjdC5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLnNldHRpbmdzLnNoZWxsX2NvbW1hbmRzW3RoaXMuc2hlbGxfY29tbWFuZF9pZF07IC8vIFJlbW92ZSBmcm9tIHRoZSBwbHVnaW4ncyBzZXR0aW5ncy5cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2V0dGluZyBmaWVsZHNcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJfZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nLnNldHRpbmdFbCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyX2VsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zZXR0aW5nX2dyb3VwLnNoZWxsX2NvbW1hbmRfc2V0dGluZy5zZXR0aW5nRWwpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcl9lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuc2V0dGluZ19ncm91cC5wcmV2aWV3X3NldHRpbmcuc2V0dGluZ0VsKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIkNvbW1hbmQgcmVtb3ZlZC5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7SG90a2V5LCBNb2RpZmllciwgUGxhdGZvcm19IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4vRGVidWdcIjtcclxuXHJcbi8qKlxyXG4gKiBUT0RPOiBNb3ZlIHRoaXMgdG8gVFNoZWxsQ29tbWFuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kKHBsdWdpbjogU0NfUGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcpOiBIb3RrZXlbXSB7XHJcbiAgICAvLyBSZXRyaWV2ZSBhbGwgaG90a2V5cyBzZXQgYnkgdXNlci5cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IGFwcF9jdXN0b21faG90a2V5cyA9IHBsdWdpbi5hcHAuaG90a2V5TWFuYWdlcj8uY3VzdG9tS2V5cztcclxuICAgIGlmICghYXBwX2N1c3RvbV9ob3RrZXlzKSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kKCkgZmFpbGVkLCB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheS5cIilcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IG9ubHkgb3VyIGhvdGtleXMuXHJcbiAgICBjb25zdCBob3RrZXlfaW5kZXggPSBwbHVnaW4uZ2V0UGx1Z2luSWQoKSArIFwiOlwiICsgcGx1Z2luLmdlbmVyYXRlT2JzaWRpYW5Db21tYW5kSWQoc2hlbGxfY29tbWFuZF9pZCk7IC8vIEUuZy4gXCJvYnNpZGlhbi1zaGVsbGNvbW1hbmRzOnNoZWxsLWNvbW1hbmQtMFwiXHJcbiAgICBkZWJ1Z0xvZyhcImdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQoKSBzdWNjZWVkZWQuXCIpXHJcbiAgICByZXR1cm4gYXBwX2N1c3RvbV9ob3RrZXlzW2hvdGtleV9pbmRleF0gPz8gW107IC8vIElmIG5vIGhvdGtleSBhcnJheSBpcyBzZXQgZm9yIHRoaXMgY29tbWFuZCwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LiBBbHRob3VnaCBJIGRvIGJlbGlldmUgdGhhdCBhbGwgY29tbWFuZHMgZG8gaGF2ZSBhbiBhcnJheSBhbnl3YXksIGJ1dCBoYXZlIHRoaXMgY2hlY2sganVzdCBpbiBjYXNlLlxyXG59XHJcblxyXG4vKipcclxuICogVE9ETzogSXMgdGhlcmUgYSB3YXkgdG8gbWFrZSBPYnNpZGlhbiBkbyB0aGlzIGNvbnZlcnNpb24gZm9yIHVzP1xyXG4gKlxyXG4gKiBAcGFyYW0gaG90a2V5XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEhvdGtleVRvU3RyaW5nKGhvdGtleTogSG90a2V5KSB7XHJcbiAgICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgaG90a2V5Lm1vZGlmaWVycy5mb3JFYWNoKChtb2RpZmllcjogTW9kaWZpZXIpID0+IHtcclxuICAgICAgICBsZXQgbW9kaWZpZXJfa2V5ID0gbW9kaWZpZXIudG9TdHJpbmcoKTsgLy8gVGhpcyBpcyBvbmUgb2YgJ01vZCcgfCAnQ3RybCcgfCAnTWV0YScgfCAnU2hpZnQnIHwgJ0FsdCdcclxuICAgICAgICBpZiAoXCJNb2RcIiA9PT0gbW9kaWZpZXJfa2V5KSB7XHJcbiAgICAgICAgICAgIC8vIENoYW5nZSBcIk1vZFwiIHRvIHNvbWV0aGluZyBtb3JlIG1lYW5pbmdmdWwuXHJcbiAgICAgICAgICAgIG1vZGlmaWVyX2tleSA9IFBsYXRmb3JtLmlzTWFjT1MgPyBcIkNtZFwiIDogXCJDdHJsXCI7IC8vIGlzTWFjT1Mgc2hvdWxkIGFsc28gYmUgdHJ1ZSBpZiB0aGUgZGV2aWNlIGlzIGlQaG9uZS9pUGFkLiBDYW4gYmUgaGFuZHkgaWYgdGhpcyBwbHVnaW4gZ2V0cyBtb2JpbGUgc3VwcG9ydCBzb21lIGRheS5cclxuICAgICAgICB9XHJcbiAgICAgICAga2V5cy5wdXNoKG1vZGlmaWVyX2tleSk7XHJcbiAgICB9KTtcclxuICAgIGtleXMucHVzaChob3RrZXkua2V5KTsgLy8gVGhpcyBpcyBzb21ldGhpbmcgbGlrZSBhIGxldHRlciAoJ0EnLCAnQicgZXRjKSBvciBzcGFjZS9lbnRlci93aGF0ZXZlci5cclxuICAgIHJldHVybiBrZXlzLmpvaW4oXCIgKyBcIik7XHJcbn0iLCJpbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi8uLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7SG90a2V5LCBzZXRJY29ufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtFeHRyYU9wdGlvbnNNb2RhbH0gZnJvbSBcIi4uL0V4dHJhT3B0aW9uc01vZGFsXCI7XHJcbmltcG9ydCB7RGVsZXRlTW9kYWx9IGZyb20gXCIuLi9EZWxldGVNb2RhbFwiO1xyXG5pbXBvcnQge2dldEhvdGtleXNGb3JTaGVsbENvbW1hbmQsIEhvdGtleVRvU3RyaW5nfSBmcm9tIFwiLi4vLi4vSG90a2V5c1wiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCB7Q3JlYXRlU2hlbGxDb21tYW5kRmllbGRDb3JlfSBmcm9tIFwiLi9DcmVhdGVTaGVsbENvbW1hbmRGaWVsZENvcmVcIjtcclxuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSBcIi4uLy4uL0RlYnVnXCI7XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAcGFyYW0gY29udGFpbmVyX2VsZW1lbnRcclxuICogQHBhcmFtIHNoZWxsX2NvbW1hbmRfaWQgRWl0aGVyIGEgc3RyaW5nIGZvcm1hdHRlZCBpbnRlZ2VyIChcIjBcIiwgXCIxXCIgZXRjKSBvciBcIm5ld1wiIGlmIGl0J3MgYSBmaWVsZCBmb3IgYSBjb21tYW5kIHRoYXQgZG9lcyBub3QgZXhpc3QgeWV0LlxyXG4gKiBAcGFyYW0gc2hvd19hdXRvY29tcGxldGVfbWVudVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkKHBsdWdpbjogU0NfUGx1Z2luLCBjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZywgc2hvd19hdXRvY29tcGxldGVfbWVudTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgaXNfbmV3ID0gXCJuZXdcIiA9PT0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgIGxldCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQ7XHJcbiAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGNvbW1hbmRcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQgPSBwbHVnaW4ubmV3VFNoZWxsQ29tbWFuZCgpO1xyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfaWQgPSB0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKTsgLy8gUmVwbGFjZSBcIm5ld1wiIHdpdGggYSByZWFsIGlkLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBVc2UgYW4gb2xkIHNoZWxsIGNvbW1hbmRcclxuICAgICAgICB0X3NoZWxsX2NvbW1hbmQgPSBwbHVnaW4uZ2V0VFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgIH1cclxuICAgIGRlYnVnTG9nKFwiQ3JlYXRlIGNvbW1hbmQgZmllbGQgZm9yIGNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZCArIChpc19uZXcgPyBcIiAoTkVXKVwiIDogXCJcIikpO1xyXG4gICAgbGV0IHNoZWxsX2NvbW1hbmQ6IHN0cmluZztcclxuICAgIGlmIChpc19uZXcpIHtcclxuICAgICAgICBzaGVsbF9jb21tYW5kID0gXCJcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hlbGxfY29tbWFuZCA9IHRfc2hlbGxfY29tbWFuZC5nZXREZWZhdWx0U2hlbGxDb21tYW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ19ncm91cCA9IENyZWF0ZVNoZWxsQ29tbWFuZEZpZWxkQ29yZShcclxuICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQsXHJcbiAgICAgICAgZ2VuZXJhdGVTaGVsbENvbW1hbmRGaWVsZE5hbWUoc2hlbGxfY29tbWFuZF9pZCwgdF9zaGVsbF9jb21tYW5kKSxcclxuICAgICAgICBzaGVsbF9jb21tYW5kLFxyXG4gICAgICAgIHRfc2hlbGxfY29tbWFuZC5nZXRTaGVsbCgpLFxyXG4gICAgICAgIHNob3dfYXV0b2NvbXBsZXRlX21lbnUsXHJcbiAgICAgICAgYXN5bmMgKHNoZWxsX2NvbW1hbmQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkNyZWF0aW5nIG5ldyBjb21tYW5kIFwiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiOiBcIiArIHNoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJDb21tYW5kIFwiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiIGdvbm5hIGNoYW5nZSB0bzogXCIgKyBzaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG8gdGhpcyBpbiBib3RoIGNhc2VzLCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbW1hbmQgYW5kIHdoZW4gY2hhbmdpbmcgYW4gb2xkIG9uZTpcclxuICAgICAgICAgICAgdF9zaGVsbF9jb21tYW5kLmdldENvbmZpZ3VyYXRpb24oKS5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kcy5kZWZhdWx0ID0gc2hlbGxfY29tbWFuZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc19uZXcpIHtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb21tYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBwbHVnaW4ucmVnaXN0ZXJTaGVsbENvbW1hbmQodF9zaGVsbF9jb21tYW5kKTsgLy8gSSBkb24ndCB0aGluayB0aGlzIGlzIG5lZWRlZCB0byBiZSBkb25lIGFueW1vcmVcclxuICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ29tbWFuZCBjcmVhdGVkLlwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBhbiBvbGQgY29tbWFuZFxyXG4gICAgICAgICAgICAgICAgdF9zaGVsbF9jb21tYW5kLnJlbmFtZU9ic2lkaWFuQ29tbWFuZCh0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGxDb21tYW5kKCksIHRfc2hlbGxfY29tbWFuZC5nZXRBbGlhcygpKTsgLy8gQ2hhbmdlIHRoZSBjb21tYW5kJ3MgbmFtZSBpbiBPYnNpZGlhbidzIGNvbW1hbmQgcGFsZXR0ZSBhbmQgaW4gaG90a2V5IHNldHRpbmdzLlxyXG4gICAgICAgICAgICAgICAgZGVidWdMb2coXCJDb21tYW5kIGNoYW5nZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBJY29uIGJ1dHRvbnNcclxuICAgIHNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJFeGVjdXRlIG5vd1wiKVxyXG4gICAgICAgICAgICAuc2V0SWNvbihcInJ1bi1jb21tYW5kXCIpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHNoZWxsIGNvbW1hbmQgbm93IChmb3IgdHJ5aW5nIGl0IG91dCBpbiB0aGUgc2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBwbHVnaW4uZ2V0VFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTsgLy8gVE9ETzogSXMgdGhpcyByZWR1bmRhbnQ/IENvdWxkIHRoZSB0X3NoZWxsX2NvbW1hbmQgZGVmaW5lZCBpbiBsaW5lcyAyMiAvIDI2IChuZWFyICdjb25zdCBpc19uZXcnKSBiZSB1c2VkP1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2luZ19yZXN1bHQgPSB0X3NoZWxsX2NvbW1hbmQucGFyc2VWYXJpYWJsZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uY29uZmlybUFuZEV4ZWN1dGVTaGVsbENvbW1hbmQodF9zaGVsbF9jb21tYW5kLCBwYXJzaW5nX3Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5uZXdFcnJvcnMocGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChFeHRyYU9wdGlvbnNNb2RhbC5HRU5FUkFMX09QVElPTlNfU1VNTUFSWSlcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlbiBhbiBleHRyYSBvcHRpb25zIG1vZGFsOiBHZW5lcmFsIHRhYlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgRXh0cmFPcHRpb25zTW9kYWwocGx1Z2luLmFwcCwgcGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkLCBzZXR0aW5nX2dyb3VwLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLmFjdGl2YXRlVGFiKFwiZXh0cmEtb3B0aW9ucy1nZW5lcmFsXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChFeHRyYU9wdGlvbnNNb2RhbC5PVVRQVVRfT1BUSU9OU19TVU1NQVJZKVxyXG4gICAgICAgICAgICAuc2V0SWNvbihcImxpbmVzLW9mLXRleHRcIilcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlbiBhbiBleHRyYSBvcHRpb25zIG1vZGFsOiBPdXRwdXQgdGFiXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBFeHRyYU9wdGlvbnNNb2RhbChwbHVnaW4uYXBwLCBwbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQsIHNldHRpbmdfZ3JvdXAsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuYWN0aXZhdGVUYWIoXCJleHRyYS1vcHRpb25zLW91dHB1dFwiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgLnNldFRvb2x0aXAoRXh0cmFPcHRpb25zTW9kYWwuT1BFUkFUSU5HX1NZU1RFTVNfQU5EX1NIRUxMU19PUFRJT05TX1NVTU1BUlkpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKFwic3RhY2tlZC1sZXZlbHNcIilcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlbiBhbiBleHRyYSBvcHRpb25zIG1vZGFsOiBPcGVyYXRpbmcgc3lzdGVtcyBhbmQgc2hlbGxzIHRhYlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgRXh0cmFPcHRpb25zTW9kYWwocGx1Z2luLmFwcCwgcGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkLCBzZXR0aW5nX2dyb3VwLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLmFjdGl2YXRlVGFiKFwiZXh0cmEtb3B0aW9ucy1vcGVyYXRpbmctc3lzdGVtcy1hbmQtc2hlbGxzXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChFeHRyYU9wdGlvbnNNb2RhbC5FVkVOVFNfU1VNTUFSWSlcclxuICAgICAgICAgICAgLnNldEljb24oXCJkaWNlXCIpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE9wZW4gYW4gZXh0cmEgb3B0aW9ucyBtb2RhbDogT3BlcmF0aW5nIHN5c3RlbXMgYW5kIHNoZWxscyB0YWJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsID0gbmV3IEV4dHJhT3B0aW9uc01vZGFsKHBsdWdpbi5hcHAsIHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ19ncm91cCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5hY3RpdmF0ZVRhYihcImV4dHJhLW9wdGlvbnMtZXZlbnRzXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRlbGV0ZSB0aGlzIHNoZWxsIGNvbW1hbmRcIilcclxuICAgICAgICAgICAgLnNldEljb24oXCJ0cmFzaFwiKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGEgZGVsZXRlIG1vZGFsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBEZWxldGVNb2RhbChwbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQsIHNldHRpbmdfZ3JvdXAsIGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICA7XHJcblxyXG4gICAgLy8gSW5mb3JtYXRpb25hbCBpY29ucyAoPSBub24tY2xpY2thYmxlKVxyXG4gICAgY29uc3QgaWNvbl9jb250YWluZXIgPSBzZXR0aW5nX2dyb3VwLm5hbWVfc2V0dGluZy5uYW1lRWwuY3JlYXRlRWwoXCJzcGFuXCIsIHthdHRyOiB7Y2xhc3M6IFwiU0MtbWFpbi1pY29uLWNvbnRhaW5lclwifX0pO1xyXG5cclxuICAgIC8vIFwiQXNrIGNvbmZpcm1hdGlvblwiIGljb24uXHJcbiAgICBjb25zdCBjb25maXJtX2V4ZWN1dGlvbl9pY29uX2NvbnRhaW5lciA9IGljb25fY29udGFpbmVyLmNyZWF0ZUVsKFwic3BhblwiLCB7YXR0cjoge1wiYXJpYS1sYWJlbFwiOiBcIkFza3MgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb24uXCIsIGNsYXNzOiBcInNoZWxsLWNvbW1hbmRzLWNvbmZpcm0tZXhlY3V0aW9uLWljb24tY29udGFpbmVyXCJ9fSk7XHJcbiAgICBzZXRJY29uKGNvbmZpcm1fZXhlY3V0aW9uX2ljb25fY29udGFpbmVyLCBcImxhbmd1YWdlc1wiKTtcclxuICAgIGlmICghdF9zaGVsbF9jb21tYW5kLmdldENvbmZpcm1FeGVjdXRpb24oKSkge1xyXG4gICAgICAgIC8vIERvIG5vdCBkaXNwbGF5IHRoZSBpY29uIGZvciBjb21tYW5kcyB0aGF0IGRvIG5vdCB1c2UgY29uZmlybWF0aW9uLlxyXG4gICAgICAgIGNvbmZpcm1fZXhlY3V0aW9uX2ljb25fY29udGFpbmVyLmFkZENsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBcIklnbm9yZWQgZXJyb3IgY29kZXNcIiBpY29uXHJcbiAgICBjb25zdCBpZ25vcmVkX2Vycm9yX2NvZGVzX2ljb25fY29udGFpbmVyID0gaWNvbl9jb250YWluZXIuY3JlYXRlRWwoXCJzcGFuXCIsIHthdHRyOiB7XCJhcmlhLWxhYmVsXCI6IGdlbmVyYXRlSWdub3JlZEVycm9yQ29kZXNJY29uVGl0bGUodF9zaGVsbF9jb21tYW5kLmdldElnbm9yZUVycm9yQ29kZXMoKSksIGNsYXNzOiBcInNoZWxsLWNvbW1hbmRzLWlnbm9yZWQtZXJyb3ItY29kZXMtaWNvbi1jb250YWluZXJcIn19KTtcclxuICAgIHNldEljb24oaWdub3JlZF9lcnJvcl9jb2Rlc19pY29uX2NvbnRhaW5lciwgXCJzdHJpa2V0aHJvdWdoLWdseXBoXCIpO1xyXG4gICAgaWYgKCF0X3NoZWxsX2NvbW1hbmQuZ2V0SWdub3JlRXJyb3JDb2RlcygpLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIERvIG5vdCBkaXNwbGF5IHRoZSBpY29uIGZvciBjb21tYW5kcyB0aGF0IGRvIG5vdCBpZ25vcmUgYW55IGVycm9ycy5cclxuICAgICAgICBpZ25vcmVkX2Vycm9yX2NvZGVzX2ljb25fY29udGFpbmVyLmFkZENsYXNzKFwiU0MtaGlkZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgaG90a2V5IGluZm9ybWF0aW9uXHJcbiAgICBpZiAoIWlzX25ldykge1xyXG4gICAgICAgIGNvbnN0IGhvdGtleXMgPSBnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kKHBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCk7XHJcbiAgICAgICAgaWYgKGhvdGtleXMpIHtcclxuICAgICAgICAgICAgbGV0IGhvdGtleXNfam9pbmVkOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICBob3RrZXlzLmZvckVhY2goKGhvdGtleTogSG90a2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG90a2V5c19qb2luZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3RrZXlzX2pvaW5lZCArPSBcIjxicj5cIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaG90a2V5c19qb2luZWQgKz0gSG90a2V5VG9TdHJpbmcoaG90a2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvdGtleV9kaXYgPSBzZXR0aW5nX2dyb3VwLnByZXZpZXdfc2V0dGluZy5jb250cm9sRWwuY3JlYXRlRWwoXCJkaXZcIiwge2F0dHI6IHtjbGFzczogXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24gU0MtaG90a2V5LWluZm9cIn19KTtcclxuICAgICAgICAgICAgLy8gQ29tbWVudCBvdXQgdGhlIGljb24gYmVjYXVzZSBpdCB3b3VsZCBsb29rIGxpa2UgYSBjbGlja2FibGUgYnV0dG9uIChhcyB0aGVyZSBhcmUgb3RoZXIgY2xpY2thYmxlIGljb25zIGluIHRoZSBzZXR0aW5ncykuXHJcbiAgICAgICAgICAgIC8vIHNldEljb24oaG90a2V5X2RpdiwgXCJhbnkta2V5XCIsIDIyKTsgLy8gSG90a2V5IGljb25cclxuICAgICAgICAgICAgaG90a2V5X2Rpdi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCIgXCIgKyBob3RrZXlzX2pvaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVidWdMb2coXCJDcmVhdGVkLlwiKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX2lkIFN0cmluZyBsaWtlIFwiMFwiIG9yIFwiMVwiIGV0Yy4gVE9ETzogUmVtb3ZlIHRoaXMgcGFyYW1ldGVyIGFuZCB1c2UgaWQgZnJvbSB0X3NoZWxsX2NvbW1hbmQuXHJcbiAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmRcclxuICogQHB1YmxpYyBFeHBvcnRlZCBiZWNhdXNlIFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsIHVzZXMgdGhpcyB0b28uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGVsbENvbW1hbmRGaWVsZE5hbWUoc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nLCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgIGlmICh0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSkge1xyXG4gICAgICAgIHJldHVybiB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBcIkNvbW1hbmQgI1wiICsgc2hlbGxfY29tbWFuZF9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBpZ25vcmVkX2Vycm9yX2NvZGVzXHJcbiAqIEBwdWJsaWMgRXhwb3J0ZWQgYmVjYXVzZSBTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbCB1c2VzIHRoaXMgdG9vLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSWdub3JlZEVycm9yQ29kZXNJY29uVGl0bGUoaWdub3JlZF9lcnJvcl9jb2RlczogbnVtYmVyW10pIHtcclxuICAgIGNvbnN0IHBsdXJhbCA9IGlnbm9yZWRfZXJyb3JfY29kZXMubGVuZ3RoICE9PSAxID8gXCJzXCIgOiBcIlwiO1xyXG4gICAgcmV0dXJuIFwiSWdub3JlZCBlcnJvclwiK3BsdXJhbCtcIjogXCIgKyBpZ25vcmVkX2Vycm9yX2NvZGVzLmpvaW4oXCIsXCIpO1xyXG59IiwiaW1wb3J0IHtBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGgsIGdvdG9VUkx9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtjcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkfSBmcm9tIFwiLi9zZXR0aW5nX2VsZW1lbnRzL0NyZWF0ZVNoZWxsU2VsZWN0aW9uRmllbGRcIjtcclxuaW1wb3J0IHtjcmVhdGVTaGVsbENvbW1hbmRGaWVsZH0gZnJvbSBcIi4vc2V0dGluZ19lbGVtZW50cy9DcmVhdGVTaGVsbENvbW1hbmRGaWVsZFwiO1xyXG5pbXBvcnQge2NyZWF0ZVRhYnMsIFRhYlN0cnVjdHVyZX0gZnJvbSBcIi4vc2V0dGluZ19lbGVtZW50cy9UYWJzXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuLi9EZWJ1Z1wiO1xyXG5pbXBvcnQge1xyXG4gICAgRG9jdW1lbnRhdGlvbkF1dG9jb21wbGV0ZUxpbmssXHJcbiAgICBEb2N1bWVudGF0aW9uTWFpbkxpbmssXHJcbiAgICBEb2N1bWVudGF0aW9uVmFyaWFibGVzTGluayxcclxuICAgIEdpdEh1YkxpbmssXHJcbiAgICBDaGFuZ2Vsb2dMaW5rLFxyXG59IGZyb20gXCIuLi9Eb2N1bWVudGF0aW9uXCI7XHJcbmltcG9ydCB7Z2V0VmFyaWFibGVzfSBmcm9tIFwiLi4vdmFyaWFibGVzL1ZhcmlhYmxlTGlzdHNcIjtcclxuaW1wb3J0IHtWYXJpYWJsZX0gZnJvbSBcIi4uL3ZhcmlhYmxlcy9WYXJpYWJsZVwiO1xyXG5pbXBvcnQge2dldFNDX0V2ZW50c30gZnJvbSBcIi4uL2V2ZW50cy9TQ19FdmVudExpc3RcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4uL2V2ZW50cy9TQ19FdmVudFwiO1xyXG5pbXBvcnQge1RTaGVsbENvbW1hbmR9IGZyb20gXCIuLi9UU2hlbGxDb21tYW5kXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU0NfTWFpblNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBsdWdpbjogU0NfUGx1Z2luO1xyXG5cclxuICAgIHByaXZhdGUgdGFiX3N0cnVjdHVyZTogVGFiU3RydWN0dXJlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFNDX1BsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgdGhpcy50YWJfc3RydWN0dXJlID0gY3JlYXRlVGFicyhjb250YWluZXJFbCwge1xyXG4gICAgICAgICAgICBcIm1haW4tc2hlbGwtY29tbWFuZHNcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiU2hlbGwgY29tbWFuZHNcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwicnVuLWNvbW1hbmRcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJTaGVsbENvbW1hbmRzKGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWFpbi1vcGVyYXRpbmctc3lzdGVtcy1hbmQtc2hlbGxzXCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk9wZXJhdGluZyBzeXN0ZW1zICYgc2hlbGxzXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcInN0YWNrZWQtbGV2ZWxzXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiT3BlcmF0aW5nU3lzdGVtc0FuZFNoZWxscyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1haW4tb3V0cHV0XCI6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk91dHB1dFwiLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogXCJsaW5lcy1vZi10ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50X2dlbmVyYXRvcjogKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFiT3V0cHV0KGNvbnRhaW5lcl9lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWFpbi1ldmVudHNcIjoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRXZlbnRzXCIsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBcImRpY2VcIixcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRfZ2VuZXJhdG9yOiAoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJFdmVudHMoY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtYWluLXZhcmlhYmxlc1wiOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJWYXJpYWJsZXNcIixcclxuICAgICAgICAgICAgICAgIGljb246IFwiY29kZS1nbHlwaFwiLFxyXG4gICAgICAgICAgICAgICAgY29udGVudF9nZW5lcmF0b3I6IChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYlZhcmlhYmxlcyhjb250YWluZXJfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBEb2N1bWVudGF0aW9uIGxpbmsgJiBHaXRIdWIgbGlua3NcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBEb2N1bWVudGF0aW9uTWFpbkxpbmsgKyBcIlxcXCI+RG9jdW1lbnRhdGlvbjwvYT4gLSBcIiArXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBHaXRIdWJMaW5rICsgXCJcXFwiPlNDIG9uIEdpdEh1YjwvYT4gLSBcIiArXHJcbiAgICAgICAgICAgIFwiPGEgaHJlZj1cXFwiXCIgKyBDaGFuZ2Vsb2dMaW5rICsgXCJcXFwiPlNDIHZlcnNpb246IFwiICsgdGhpcy5wbHVnaW4uZ2V0UGx1Z2luVmVyc2lvbigpICsgXCI8L2E+XCIsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gS0VFUCBUSElTIEFGVEVSIENSRUFUSU5HIEFMTCBFTEVNRU5UUzpcclxuICAgICAgICB0aGlzLnJlbWVtYmVyTGFzdFBvc2l0aW9uKGNvbnRhaW5lckVsKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhYlNoZWxsQ29tbWFuZHMoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgLy8gQSA8ZGl2PiBlbGVtZW50IGZvciBhbGwgY29tbWFuZCBpbnB1dCBmaWVsZHMuIE5ldyBjb21tYW5kIGZpZWxkcyBjYW4gYmUgY3JlYXRlZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAgICBjb25zdCBjb21tYW5kX2ZpZWxkc19jb250YWluZXIgPSBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcImRpdlwiKTtcclxuXHJcbiAgICAgICAgLy8gRmllbGRzIGZvciBtb2RpZnlpbmcgZXhpc3RpbmcgY29tbWFuZHNcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmRfaWQgaW4gdGhpcy5wbHVnaW4uZ2V0VFNoZWxsQ29tbWFuZHMoKSkge1xyXG4gICAgICAgICAgICBjcmVhdGVTaGVsbENvbW1hbmRGaWVsZCh0aGlzLnBsdWdpbiwgY29tbWFuZF9maWVsZHNfY29udGFpbmVyLCBjb21tYW5kX2lkLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFwiTmV3IGNvbW1hbmRcIiBidXR0b25cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIk5ldyBjb21tYW5kXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2hlbGxDb21tYW5kRmllbGQodGhpcy5wbHVnaW4sIGNvbW1hbmRfZmllbGRzX2NvbnRhaW5lciwgXCJuZXdcIiwgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd19hdXRvY29tcGxldGVfbWVudSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJOZXcgZW1wdHkgY29tbWFuZCBjcmVhdGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0YWJFdmVudHMoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vIEEgZ2VuZXJhbCBkZXNjcmlwdGlvbiBhYm91dCBldmVudHNcclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiRXZlbnRzIGludHJvZHVjZSBhIHdheSB0byBleGVjdXRlIHNoZWxsIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgaW4gY2VydGFpbiBzaXR1YXRpb25zLCBlLmcuIHdoZW4gT2JzaWRpYW4gc3RhcnRzLiBUaGV5IGFyZSBzZXQgdXAgZm9yIGVhY2ggc2hlbGwgY29tbWFuZCBzZXBhcmF0ZWx5LCBidXQgdGhpcyB0YWIgY29udGFpbnMgZ2VuZXJhbCBvcHRpb25zIGZvciB0aGVtLlwifSk7XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZS9kaXNhYmxlIGFsbCBldmVudHNcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJFbmFibGUgZXZlbnRzXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiVGhpcyBpcyBhIHF1aWNrIHdheSB0byBpbW1lZGlhdGVseSB0dXJuIG9mZiBhbGwgZXZlbnRzLCBpZiB5b3Ugd2FudC5cIilcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlX2V2ZW50cylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAoZW5hYmxlX2V2ZW50czogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0b2dnbGUgd2FzIGNsaWNrZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlX2V2ZW50cyA9IGVuYWJsZV9ldmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZV9ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWdpc3RlclNDX0V2ZW50cyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4udW5yZWdpc3RlclNDX0V2ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBBIGxpc3Qgb2YgY3VycmVudCBlbmFibGUgZXZlbnRzXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIlRoZSBmb2xsb3dpbmcgZ2l2ZXMganVzdCBhIHF1aWNrIGdsYW5jZSBvdmVyIHdoaWNoIGV2ZW50cyBhcmUgZW5hYmxlZCBvbiB3aGljaCBzaGVsbCBjb21tYW5kcy4gVG8gZW5hYmxlL2Rpc2FibGUgZXZlbnRzIGZvciBhIHNoZWxsIGNvbW1hbmQsIGdvIHRvIHRoZSBwYXJ0aWN1bGFyIHNoZWxsIGNvbW1hbmQncyBzZXR0aW5ncyB2aWEgdGhlICdTaGVsbCBjb21tYW5kcycgdGFiLiBUaGUgbGlzdCBpcyBvbmx5IHVwZGF0ZWQgd2hlbiB5b3UgcmVvcGVuIHRoZSB3aG9sZSBzZXR0aW5ncyBwYW5lbC5cIn0pO1xyXG4gICAgICAgIGxldCBmb3VuZF9lbmFibGVkX2V2ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgZ2V0U0NfRXZlbnRzKHRoaXMucGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRfZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzID0gc2NfZXZlbnQuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuICAgICAgICAgICAgLy8gSGFzIHRoZSBldmVudCBiZWVuIGVuYWJsZWQgZm9yIGFueSBzaGVsbCBjb21tYW5kcz9cclxuICAgICAgICAgICAgaWYgKGV2ZW50X2VuYWJsZWRfdF9zaGVsbF9jb21tYW5kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFllcywgaXQncyBlbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhIGxpc3Qgb2Ygc2hlbGwgY29tbWFuZHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaF9lbGVtZW50ID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBzY19ldmVudC5zdGF0aWMoKS5nZXRUaXRsZSgpfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0X2VsZW1lbnQgPSBwYXJhZ3JhcGhfZWxlbWVudC5jcmVhdGVFbChcInVsXCIpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRfZW5hYmxlZF90X3NoZWxsX2NvbW1hbmRzLmZvckVhY2goKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RfZWxlbWVudC5jcmVhdGVFbChcImxpXCIsIHt0ZXh0OiB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXNPclNoZWxsQ29tbWFuZCgpfSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZm91bmRfZW5hYmxlZF9ldmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWZvdW5kX2VuYWJsZWRfZXZlbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIk5vIGV2ZW50cyBhcmUgZW5hYmxlZCBmb3IgYW55IHNoZWxsIGNvbW1hbmRzLlwifSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiVmFyaWFibGVzKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudClcclxuICAgIHtcclxuICAgICAgICAvLyBcIlByZXZpZXcgdmFyaWFibGVzIGluIGNvbW1hbmQgcGFsZXR0ZVwiIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiUHJldmlldyB2YXJpYWJsZXMgaW4gY29tbWFuZCBwYWxldHRlIGFuZCBtZW51c1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIklmIG9uLCB2YXJpYWJsZSBuYW1lcyBhcmUgc3Vic3RpdHV0ZWQgd2l0aCB0aGVpciByZWFsdGltZSB2YWx1ZXMgd2hlbiB5b3UgdmlldyB5b3VyIGNvbW1hbmRzIGluIHRoZSBjb21tYW5kIHBhbGV0dGUgYW5kIHJpZ2h0IGNsaWNrIGNvbnRleHQgbWVudXMgKGlmIHVzZWQpLiBBIG5pY2Ugd2F5IHRvIGVuc3VyZSB5b3VyIGNvbW1hbmRzIHdpbGwgdXNlIGNvcnJlY3QgdmFsdWVzLlwiKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKGNoZWNrYm94ID0+IGNoZWNrYm94XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdpbmcgcHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlIHRvIFwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXZpZXdfdmFyaWFibGVzX2luX2NvbW1hbmRfcGFsZXR0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gXCJTaG93IGF1dG9jb21wbGV0ZSBtZW51XCIgZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJTaG93IGF1dG9jb21wbGV0ZSBtZW51XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiSWYgb24sIGEgZHJvcGRvd24gbWVudSBzaG93cyB1cCB3aGVuIHlvdSBiZWdpbiB3cml0aW5nIHt7dmFyaWFibGV9fSBuYW1lcywgc2hvd2luZyBtYXRjaGluZyB2YXJpYWJsZXMgYW5kIHRoZWlyIGluc3RydWN0aW9ucy4gQWxzbyBhbGxvd3MgZGVmaW5pbmcgY3VzdG9tIHN1Z2dlc3Rpb25zIGluIGF1dG9jb21wbGV0ZS55YW1sIGZpbGUgLSBzZWUgdGhlIGRvY3VtZW50YXRpb24uXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoY2hlY2tib3ggPT4gY2hlY2tib3hcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdpbmcgc2hvd19hdXRvY29tcGxldGVfbWVudSB0byBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93X2F1dG9jb21wbGV0ZV9tZW51ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0aGUgd2hvbGUgc2V0dGluZ3MgdmlldyB0byBhcHBseSB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGV4dHJhX2J1dHRvbiA9PiBleHRyYV9idXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiaGVscFwiKVxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJEb2N1bWVudGF0aW9uOiBBdXRvY29tcGxldGVcIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBnb3RvVVJMKERvY3VtZW50YXRpb25BdXRvY29tcGxldGVMaW5rKVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFZhcmlhYmxlIGluc3RydWN0aW9uc1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJWYXJpYWJsZXNcIilcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKSAvLyBNYWtlIHRoZSBcIlZhcmlhYmxlc1wiIHRleHQgYm9sZC5cclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGV4dHJhX2J1dHRvbiA9PiBleHRyYV9idXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiaGVscFwiKVxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJEb2N1bWVudGF0aW9uOiBWYXJpYWJsZXNcIilcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBnb3RvVVJMKERvY3VtZW50YXRpb25WYXJpYWJsZXNMaW5rKVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IGdldFZhcmlhYmxlcyh0aGlzLnBsdWdpbiwgdGhpcy5wbHVnaW4uZ2V0RGVmYXVsdFNoZWxsKCkpO1xyXG4gICAgICAgIHZhcmlhYmxlcy5mb3JFYWNoKCh2YXJpYWJsZTogVmFyaWFibGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIpO1xyXG4gICAgICAgICAgICBwYXJhZ3JhcGguaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJiZWdpblwiLFxyXG4gICAgICAgICAgICAgICAgdmFyaWFibGUuZ2V0SGVscE5hbWUoKSArXHJcbiAgICAgICAgICAgICAgICBcIjxicj5cIiArXHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5nZXRIZWxwVGV4dCgpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJpbGl0eV90ZXh0OiBzdHJpbmcgPSB2YXJpYWJsZS5zdGF0aWMoKS5nZXRBdmFpbGFiaWxpdHlUZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChhdmFpbGFiaWxpdHlfdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBcIjxicj5cIiArIGF2YWlsYWJpbGl0eV90ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb250YWluZXJfZWxlbWVudC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiV2hlbiB5b3UgdHlwZSB2YXJpYWJsZXMgaW50byBjb21tYW5kcywgYSBwcmV2aWV3IHRleHQgYXBwZWFycyB1bmRlciB0aGUgY29tbWFuZCBmaWVsZCB0byBzaG93IGhvdyB0aGUgY29tbWFuZCB3aWxsIGxvb2sgbGlrZSB3aGVuIGl0IGdldHMgZXhlY3V0ZWQgd2l0aCB2YXJpYWJsZXMgc3Vic3RpdHV0ZWQgd2l0aCB0aGVpciByZWFsIHZhbHVlcy5cIn0pO1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJTcGVjaWFsIGNoYXJhY3RlcnMgaW4gdmFyaWFibGUgdmFsdWVzIGFyZSB0cmllZCB0byBiZSBlc2NhcGVkIChleGNlcHQgaWYgeW91IHVzZSBDTUQgYXMgdGhlIHNoZWxsIGluIFdpbmRvd3MpLiBUaGlzIGlzIHRvIGltcHJvdmUgc2VjdXJpdHkgc28gdGhhdCBhIHZhcmlhYmxlIHdvbid0IGFjY2lkZW50YWxseSBjYXVzZSBiYWQgdGhpbmdzIHRvIGhhcHBlbi4gSWYgeW91IHdhbnQgdG8gdXNlIGEgcmF3LCB1bmVzY2FwZWQgdmFsdWUsIGFkZCBhbiBleGNsYW1hdGlvbiBtYXJrIGJlZm9yZSB0aGUgdmFyaWFibGUncyBuYW1lLCBlLmcuIHt7IXRpdGxlfX0sIGJ1dCBiZSBjYXJlZnVsLCBpdCdzIGRhbmdlcm91cyFcIn0pO1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJUaGVyZSBpcyBubyB3YXkgdG8gcHJldmVudCB2YXJpYWJsZSBwYXJzaW5nLiBJZiB5b3UgbmVlZCB7eyB9fSBjaGFyYWN0ZXJzIGluIHlvdXIgY29tbWFuZCwgdGhleSB3b24ndCBiZSBwYXJzZWQgYXMgdmFyaWFibGVzIGFzIGxvbmcgYXMgdGhleSBkbyBub3QgY29udGFpbiBhbnkgb2YgdGhlIHZhcmlhYmxlIG5hbWVzIGxpc3RlZCBiZWxvdy4gSWYgeW91IHdvdWxkIG5lZWQgdG8gcGFzcyBlLmcuIHt7dGl0bGV9fSBsaXRlcmFsbHkgdG8geW91ciBjb21tYW5kLCB0aGVyZSBpcyBubyB3YXkgdG8gZG8gaXQgYXRtLCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwifSk7XHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFsbCB2YXJpYWJsZXMgdGhhdCBhY2Nlc3MgdGhlIGN1cnJlbnQgZmlsZSwgbWF5IGNhdXNlIHRoZSBjb21tYW5kIHByZXZpZXcgdG8gZmFpbCBpZiB5b3UgaGFkIG5vIGZpbGUgcGFuZWwgYWN0aXZlIHdoZW4geW91IG9wZW5lZCB0aGUgc2V0dGluZ3Mgd2luZG93IC0gZS5nLiB5b3UgaGFkIGZvY3VzIG9uIGdyYXBoIHZpZXcgaW5zdGVhZCBvZiBhIG5vdGUgPSBubyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUuIEJ1dCB0aGlzIGRvZXMgbm90IGJyZWFrIGFueXRoaW5nIGVsc2UgdGhhbiB0aGUgcHJldmlldy5cIn0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiT3BlcmF0aW5nU3lzdGVtc0FuZFNoZWxscyhjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBcIldvcmtpbmcgZGlyZWN0b3J5XCIgZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJfZWxlbWVudClcclxuICAgICAgICAgICAgLnNldE5hbWUoXCJXb3JraW5nIGRpcmVjdG9yeVwiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkEgZGlyZWN0b3J5IHdoZXJlIHlvdXIgY29tbWFuZHMgd2lsbCBiZSBydW4uIElmIGVtcHR5LCBkZWZhdWx0cyB0byB5b3VyIHZhdWx0J3MgbG9jYXRpb24uIENhbiBiZSByZWxhdGl2ZSAoPSBhIGZvbGRlciBpbiB0aGUgdmF1bHQpIG9yIGFic29sdXRlICg9IGNvbXBsZXRlIGZyb20gZmlsZXN5c3RlbSByb290KS5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5hcHApKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLndvcmtpbmdfZGlyZWN0b3J5KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiQ2hhbmdpbmcgd29ya2luZ19kaXJlY3RvcnkgdG8gXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mud29ya2luZ19kaXJlY3RvcnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIC8vIFBsYXRmb3JtcycgZGVmYXVsdCBzaGVsbHNcclxuICAgICAgICBjcmVhdGVTaGVsbFNlbGVjdGlvbkZpZWxkKHRoaXMucGx1Z2luLCBjb250YWluZXJfZWxlbWVudCwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdF9zaGVsbHMsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFiT3V0cHV0KGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIC8vIFwiRXJyb3IgbWVzc2FnZSBkdXJhdGlvblwiIGZpZWxkXHJcbiAgICAgICAgdGhpcy5jcmVhdGVOb3RpZmljYXRpb25EdXJhdGlvbkZpZWxkKGNvbnRhaW5lcl9lbGVtZW50LCBcIkVycm9yIG1lc3NhZ2UgZHVyYXRpb25cIiwgXCJDb25jZXJucyBtZXNzYWdlcyBhYm91dCBmYWlsZWQgc2hlbGwgY29tbWFuZHMuXCIsIFwiZXJyb3JfbWVzc2FnZV9kdXJhdGlvblwiKTtcclxuXHJcbiAgICAgICAgLy8gXCJOb3RpZmljYXRpb24gbWVzc2FnZSBkdXJhdGlvblwiIGZpZWxkXHJcbiAgICAgICAgdGhpcy5jcmVhdGVOb3RpZmljYXRpb25EdXJhdGlvbkZpZWxkKGNvbnRhaW5lcl9lbGVtZW50LCBcIk5vdGlmaWNhdGlvbiBtZXNzYWdlIGR1cmF0aW9uXCIsIFwiQ29uY2VybnMgaW5mb3JtYXRpb25hbCwgbm9uIGZhdGFsIG1lc3NhZ2VzLCBlLmcuIG91dHB1dCBkaXJlY3RlZCB0byAnTm90aWZpY2F0aW9uIGJhbGxvb24nLlwiLCBcIm5vdGlmaWNhdGlvbl9tZXNzYWdlX2R1cmF0aW9uXCIpO1xyXG5cclxuICAgICAgICAvLyBcIk91dHB1dCBjaGFubmVsICdDbGlwYm9hcmQnIGRpc3BsYXlzIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2UsIHRvb1wiIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiT3V0cHV0IGNoYW5uZWwgJ0NsaXBib2FyZCcgZGlzcGxheXMgYSBub3RpZmljYXRpb24gbWVzc2FnZSwgdG9vXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiSWYgYSBzaGVsbCBjb21tYW5kJ3Mgb3V0cHV0IGlzIGRpcmVjdGVkIHRvIHRoZSBjbGlwYm9hcmQsIGFsc28gc2hvdyB0aGUgb3V0cHV0IGluIGEgcG9wdXAgYm94IG9uIHRoZSB0b3AgcmlnaHQgY29ybmVyLiBUaGlzIGhlbHBzIHRvIG5vdGljZSB3aGF0IHdhcyBpbnNlcnRlZCBpbnRvIGNsaXBib2FyZC5cIilcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZShjaGVja2JveCA9PiBjaGVja2JveFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm91dHB1dF9jaGFubmVsX2NsaXBib2FyZF9hbHNvX291dHB1dHNfdG9fbm90aWZpY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm91dHB1dF9jaGFubmVsX2NsaXBib2FyZF9hbHNvX291dHB1dHNfdG9fbm90aWZpY2F0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZU5vdGlmaWNhdGlvbkR1cmF0aW9uRmllbGQoY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50LCB0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBzZXR0aW5nX25hbWU6IFwiZXJyb3JfbWVzc2FnZV9kdXJhdGlvblwiIHwgXCJub3RpZmljYXRpb25fbWVzc2FnZV9kdXJhdGlvblwiKSB7XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKHRpdGxlKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhkZXNjcmlwdGlvbiArIFwiIEluIHNlY29uZHMsIGJldHdlZW4gMSBhbmQgMTgwLlwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dChmaWVsZCA9PiBmaWVsZFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5nc1tzZXR0aW5nX25hbWVdKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAoZHVyYXRpb25fc3RyaW5nOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkdXJhdGlvbjogbnVtYmVyID0gcGFyc2VJbnQoZHVyYXRpb25fc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gMSAmJiBkdXJhdGlvbiA8PSAxODApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMb2coXCJDaGFuZ2UgXCIgKyBzZXR0aW5nX25hbWUgKyBcIiBmcm9tIFwiICsgdGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ19uYW1lXSArIFwiIHRvIFwiICsgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1tzZXR0aW5nX25hbWVdID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xvZyhcIkNoYW5nZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGEgbm90aWNlIGlmIGR1cmF0aW9uIGlzIG5vdCBiZXR3ZWVuIDEgYW5kIDE4MCwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIGEgdXNlciB0eXBlcyBpbiB0aGlzIGZpZWxkLCBzbyB0aGUgdmFsdWUgbWlnaHQgbm90IGJlIGZpbmFsLlxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxhc3RfcG9zaXRpb246IHtcclxuICAgICAgICBzY3JvbGxfcG9zaXRpb246IG51bWJlcjtcclxuICAgICAgICB0YWJfbmFtZTogc3RyaW5nO1xyXG4gICAgfSA9IHtcclxuICAgICAgICBzY3JvbGxfcG9zaXRpb246IDAsXHJcbiAgICAgICAgdGFiX25hbWU6IFwibWFpbi1zaGVsbC1jb21tYW5kc1wiLFxyXG4gICAgfTtcclxuICAgIHByaXZhdGUgcmVtZW1iZXJMYXN0UG9zaXRpb24oY29udGFpbmVyX2VsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdF9wb3NpdGlvbiA9IHRoaXMubGFzdF9wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gR28gdG8gbGFzdCBwb3NpdGlvbiBub3dcclxuICAgICAgICB0aGlzLnRhYl9zdHJ1Y3R1cmUuYnV0dG9uc1tsYXN0X3Bvc2l0aW9uLnRhYl9uYW1lXS5jbGljaygpO1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgdG9wOiB0aGlzLmxhc3RfcG9zaXRpb24uc2Nyb2xsX3Bvc2l0aW9uLFxyXG4gICAgICAgICAgICBiZWhhdmlvcjogXCJhdXRvXCIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzXHJcbiAgICAgICAgY29udGFpbmVyX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0X3Bvc2l0aW9uLnNjcm9sbF9wb3NpdGlvbiA9IGNvbnRhaW5lcl9lbGVtZW50LnNjcm9sbFRvcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRhYl9uYW1lIGluIHRoaXMudGFiX3N0cnVjdHVyZS5idXR0b25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMudGFiX3N0cnVjdHVyZS5idXR0b25zW3RhYl9uYW1lXTtcclxuICAgICAgICAgICAgYnV0dG9uLm9uQ2xpY2tFdmVudCgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxhc3RfcG9zaXRpb24udGFiX25hbWUgPSB0YWJfbmFtZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdGaWVsZEdyb3VwIHtcclxuICAgIG5hbWVfc2V0dGluZzogU2V0dGluZztcclxuICAgIHNoZWxsX2NvbW1hbmRfc2V0dGluZzogU2V0dGluZztcclxuICAgIHByZXZpZXdfc2V0dGluZzogU2V0dGluZztcclxufSIsImltcG9ydCB7TW9kYWwsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU0NfUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHtQYXJzaW5nUmVzdWx0LCBUU2hlbGxDb21tYW5kfSBmcm9tIFwiLi9UU2hlbGxDb21tYW5kXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuL0RlYnVnXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ29uZmlybUV4ZWN1dGlvbk1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IFNDX1BsdWdpbjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdDtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogU0NfUGx1Z2luLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0LCB0X3NoZWxsX2NvbW1hbmQ6IFRTaGVsbENvbW1hbmQpIHtcclxuICAgICAgICBzdXBlcihwbHVnaW4uYXBwKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQgPSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0O1xyXG4gICAgICAgIHRoaXMudF9zaGVsbF9jb21tYW5kID0gdF9zaGVsbF9jb21tYW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVuKCkge1xyXG4gICAgICAgIHN1cGVyLm9wZW4oKTtcclxuXHJcbiAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHNoZWxsIGNvbW1hbmRcclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJoMlwiLCB7dGV4dDogdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LnNoZWxsX2NvbW1hbmQsIGF0dHI6IHtzdHlsZTogXCJtYXJnaW4tYm90dG9tOiAwO1wifX0pO1xyXG4gICAgICAgIGlmICh0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQuYWxpYXMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJBbGlhczogXCIgKyB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQuYWxpYXMsIGF0dHI6IHtzdHlsZTogXCJtYXJnaW4tdG9wOiAwO1wifX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkV4ZWN1dGUgdGhpcyBzaGVsbCBjb21tYW5kP1wifSk7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgYnV0dG9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiWWVzLCBleGVjdXRlIVwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTG9nKFwiVXNlciBjb25maXJtZWQgZXhlY3V0aW9uIG9mIHNoZWxsIGNvbW1hbmQ6IFwiICsgdGhpcy5zaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5leGVjdXRlU2hlbGxDb21tYW5kKHRoaXMudF9zaGVsbF9jb21tYW5kLCB0aGlzLnNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCBTQ19QbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge2dlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZSwgZ2V0T3BlcmF0aW5nU3lzdGVtfSBmcm9tIFwiLi9Db21tb25cIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcbmltcG9ydCB7Z2V0U0NfRXZlbnRzfSBmcm9tIFwiLi9ldmVudHMvU0NfRXZlbnRMaXN0XCI7XHJcbmltcG9ydCB7IHBhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzIH0gZnJvbSBcIi4vdmFyaWFibGVzL3BhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7ZGVidWdMb2d9IGZyb20gXCIuL0RlYnVnXCI7XHJcbmltcG9ydCB7Q29tbWFuZH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRTaGVsbENvbW1hbmRDb250YWluZXIge1xyXG4gICAgW2tleTogc3RyaW5nXTogVFNoZWxsQ29tbWFuZCxcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRTaGVsbENvbW1hbmQge1xyXG5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaWQ6IHN0cmluZztcclxuICAgIHByaXZhdGUgcGx1Z2luOiBTQ19QbHVnaW47XHJcbiAgICBwcml2YXRlIGNvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb247XHJcbiAgICBwcml2YXRlIG9ic2lkaWFuX2NvbW1hbmQ6IENvbW1hbmQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHBsdWdpbjogU0NfUGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcsIGNvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLmlkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQbHVnaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhpcyB3aGVuIHlvdSBuZWVkIHRvIGFsdGVyIHRoZSBjb25maWd1cmF0aW9uIHZhbHVlcy4gaWYgeW91IG9ubHkgbmVlZCB0byByZWFkIGNvbmZpZ3VyYXRpb24gdmFsdWVzLCB1c2UgZ2V0KigpXHJcbiAgICAgKiBtZXRob2RzIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldElkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTaGVsbCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG9wZXJhdGluZ19zeXN0ZW0gPSBnZXRPcGVyYXRpbmdTeXN0ZW0oKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNoZWxsIGNvbW1hbmQgaGFzIGRlZmluZWQgYSBzcGVjaWZpYyBzaGVsbC5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLmNvbmZpZ3VyYXRpb24uc2hlbGxzW29wZXJhdGluZ19zeXN0ZW1dKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjb21tYW5kIGRvZXMgbm90IGRlZmluZSBhbiBleHBsaWNpdCBzaGVsbC5cclxuICAgICAgICAgICAgLy8gVXNlIGEgZGVmYXVsdCBzaGVsbCBmcm9tIHRoZSBwbHVnaW4ncyBzZXR0aW5ncy5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLmdldERlZmF1bHRTaGVsbCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaGVsbCBjb21tYW5kIGhhcyBhbiBleHBsaWNpdCBzaGVsbCBkZWZpbmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnNoZWxsc1tvcGVyYXRpbmdfc3lzdGVtXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFNoZWxscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnNoZWxscztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzaGVsbCBjb21tYW5kIHN0cmluZyBzcGVjaWZpYyBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSwgb3IgYSBnZW5lcmljIHNoZWxsIGNvbW1hbmQgaWYgdGhpcyBzaGVsbFxyXG4gICAgICogY29tbWFuZCBkb2VzIG5vdCBoYXZlIGFuIGV4cGxpY2l0IHZlcnNpb24gZm9yIHRoZSBjdXJyZW50IE9TLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hlbGxDb21tYW5kKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3Qgb3BlcmF0aW5nX3N5c3RlbSA9IGdldE9wZXJhdGluZ1N5c3RlbSgpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2hlbGwgY29tbWFuZCBoYXMgZGVmaW5lZCBhIHNwZWNpZmljIGNvbW1hbmQgZm9yIHRoaXMgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHNbb3BlcmF0aW5nX3N5c3RlbV0pIHtcclxuICAgICAgICAgICAgLy8gTm8gY29tbWFuZCBpcyBkZWZpbmVkIHNwZWNpZmljYWxseSBmb3IgdGhpcyBvcGVyYXRpbmcgc3lzdGVtLlxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gXCJPUyBhZ25vc3RpY1wiIGNvbW1hbmQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHMuZGVmYXVsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2hlbGwgY29tbWFuZCBoYXMgZGVmaW5lZCBhIHNwZWNpZmljIGNvbW1hbmQgZm9yIHRoaXMgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5wbGF0Zm9ybV9zcGVjaWZpY19jb21tYW5kc1tvcGVyYXRpbmdfc3lzdGVtXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgc2hlbGwgY29tbWFuZCB0aGF0IHNob3VsZCBiZSB1c2VkIGlmIG5vIHBsYXRmb3JtIHNwZWNpZmljIGNvbW1hbmQgaXMgZGVmaW5lZCBmb3IgdGhlXHJcbiAgICAgKiBjdXJyZW50IHBsYXRmb3JtLiBJZiB5b3UgcGxhbiB0byB1c2UgdGhpcyBmb3IgZXhlY3V0aW9uLCBjb25zaWRlciB1c2luZyBnZXRTaGVsbENvbW1hbmQoKSBpbnN0ZWFkLCBhcyBpdCB0YWtlcyB0aGVcclxuICAgICAqIGN1cnJlbnQgcGxhdGZvcm0gaW50byBhY2NvdW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGVmYXVsdFNoZWxsQ29tbWFuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBsYXRmb3JtX3NwZWNpZmljX2NvbW1hbmRzLmRlZmF1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBsYXRmb3JtU3BlY2lmaWNTaGVsbENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucGxhdGZvcm1fc3BlY2lmaWNfY29tbWFuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFsaWFzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYWxpYXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBVc2UgdGhpcyBtZXRob2QgaW4gYWxsIHBsYWNlcyB3aGVyZSBzaW1pbGFyIGxvZ2ljIGlzIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFsaWFzT3JTaGVsbENvbW1hbmQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmFsaWFzIHx8IHRoaXMuZ2V0U2hlbGxDb21tYW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENvbmZpcm1FeGVjdXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5jb25maXJtX2V4ZWN1dGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SWdub3JlRXJyb3JDb2RlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmlnbm9yZV9lcnJvcl9jb2RlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0Q2hhbm5lbE9yZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxfb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE91dHB1dENoYW5uZWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRFdmVudHNDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZXZlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRFdmVudENvbmZpZ3VyYXRpb24oc2NfZXZlbnQ6IFNDX0V2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnRzQ29uZmlndXJhdGlvbigpW3NjX2V2ZW50LnN0YXRpYygpLmdldENvZGUoKV0gfHwgc2NfZXZlbnQuZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc1NDX0V2ZW50RW5hYmxlZChldmVudF9jb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBldmVudHNfY29uZmlndXJhdGlvbiA9ICB0aGlzLmdldEV2ZW50c0NvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBldmVudHNfY29uZmlndXJhdGlvbltldmVudF9jb2RlXSkge1xyXG4gICAgICAgICAgICAvLyBOb3QgZW5hYmxlZFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0uZW5hYmxlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyBldmVudCBzZXR0aW5ncyBpbiBTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbC5cclxuICAgICAqIHBsdWdpbi5zYXZlU2V0dGluZ3MoKSBuZWVkcyB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZVNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50X2NvZGUgPSBzY19ldmVudC5zdGF0aWMoKS5nZXRDb2RlKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzX2NvbmZpZ3VyYXRpb24gPSAgdGhpcy5nZXRFdmVudHNDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pIHtcclxuICAgICAgICAgICAgLy8gTm90IGVuYWJsZWRcclxuICAgICAgICAgICAgLy8gRW5hYmxlXHJcbiAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdID0gc2NfZXZlbnQuZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZiAoIWV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY19ldmVudC5jYW5SZWdpc3RlckFmdGVyQ2hhbmdpbmdTZXR0aW5ncygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJTQ19FdmVudChzY19ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjX2V2ZW50Lm9uQWZ0ZXJFbmFibGluZyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIGV2ZW50IHNldHRpbmdzIGluIFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsLlxyXG4gICAgICogcGx1Z2luLnNhdmVTZXR0aW5ncygpIG5lZWRzIHRvIGJlIGNhbGxlZCBhZnRlciB0aGlzIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzY19ldmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzYWJsZVNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50X2NvZGUgPSBzY19ldmVudC5zdGF0aWMoKS5nZXRDb2RlKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzX2NvbmZpZ3VyYXRpb24gPSAgdGhpcy5nZXRFdmVudHNDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pIHtcclxuICAgICAgICAgICAgLy8gTWF5YmUgZW5hYmxlZFxyXG4gICAgICAgICAgICBpZiAoZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0uZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXMgZW5hYmxlZC5cclxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uX3Byb3BlcnR5X25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXZlbnRzX2NvbmZpZ3VyYXRpb25bZXZlbnRfY29kZV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25fcHJvcGVydHlfbmFtZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgbW9yZSBzZXR0aW5ncyB0aGFuIGp1c3QgJ2VuYWJsZScuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBieSBzZXR0aW5nICdlbmFibGUnIHRvIGZhbHNlLCBkb24ndCBmbHVzaCB0aGUgc2V0dGluZ3MsIHRoZXkgY2FuIGJlIHVzZWZ1bCBpZiB0aGUgZXZlbnQgZ2V0cyByZS1lbmFibGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2VuYWJsZWQnIGlzIHRoZSBvbmx5IHNldHRpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBieSByZW1vdmluZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29tcGxldGVseSB0byBtYWtlIHRoZSBzZXR0aW5ncyBmaWxlIGNsZWFuZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c19jb25maWd1cmF0aW9uW2V2ZW50X2NvZGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY19ldmVudC5jYW5SZWdpc3RlckFmdGVyQ2hhbmdpbmdTZXR0aW5ncygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBTQ19FdmVudHMgdGhhdCBhcmUgZW5hYmxlZCBmcm8gdGhpcyBzaGVsbCBjb21tYW5kLlxyXG4gICAgICpcclxuICAgICAqIFByaXZhdGUgYXMgaXQncyBjdXJyZW50bHkgb25seSB1c2VkIGRvbWVzdGljYWxseSwgYnV0IGNhbiBiZSBjaGFuZ2VkIHRvIHB1YmxpYyBpZiBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U0NfRXZlbnRzKCk6IFNDX0V2ZW50W10ge1xyXG4gICAgICAgIGNvbnN0IGVuYWJsZWRfc2NfZXZlbnRzOiBTQ19FdmVudFtdID0gW107XHJcbiAgICAgICAgZ2V0U0NfRXZlbnRzKHRoaXMucGx1Z2luKS5mb3JFYWNoKChzY19ldmVudDogU0NfRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTQ19FdmVudEVuYWJsZWQoc2NfZXZlbnQuc3RhdGljKCkuZ2V0Q29kZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZF9zY19ldmVudHMucHVzaChzY19ldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZW5hYmxlZF9zY19ldmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlLCBpZiB5b3UgbmVlZCBhY2Nlc3MgZnJvbSBvdXRzaWRlLCB1c2UgZW5hYmxlU0NfRXZlbnQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaXN0ZXJTQ19FdmVudChzY19ldmVudDogU0NfRXZlbnQpIHtcclxuICAgICAgICBzY19ldmVudC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGUsIGlmIHlvdSBuZWVkIGFjY2VzcyBmcm9tIG91dHNpZGUsIHVzZSBkaXNhYmxlU0NfRXZlbnQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NfZXZlbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50OiBTQ19FdmVudCkge1xyXG4gICAgICAgIHNjX2V2ZW50LnVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQncyB1cCBhbGwgZXZlbnRzIHRoYXQgYXJlIGVuYWJsZWQgZm9yIHRoaXMgc2hlbGwgY29tbWFuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGVkX2FmdGVyX2NoYW5naW5nX3NldHRpbmdzIFNldCB0bzogdHJ1ZSwgaWYgdGhpcyBoYXBwZW5zIGFmdGVyIGNoYW5naW5nIGNvbmZpZ3VyYXRpb247IGZhbHNlLCBpZiB0aGlzIGhhcHBlbnMgZHVyaW5nIGxvYWRpbmcgdGhlIHBsdWdpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZ2lzdGVyU0NfRXZlbnRzKGNhbGxlZF9hZnRlcl9jaGFuZ2luZ19zZXR0aW5nczogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuZ2V0U0NfRXZlbnRzKCkuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbl9yZWdpc3RlciA9ICFjYWxsZWRfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3MgfHwgc2NfZXZlbnQuY2FuUmVnaXN0ZXJBZnRlckNoYW5naW5nU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgaWYgKGNhbl9yZWdpc3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bnJlZ2lzdGVyU0NfRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U0NfRXZlbnRzKCkuZm9yRWFjaCgoc2NfZXZlbnQ6IFNDX0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlclNDX0V2ZW50KHNjX2V2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJUb0NvbW1hbmRQYWxldHRlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhlIGxvZ2ljIGZyb20gcGx1Z2luLnJlZ2lzdGVyU2hlbGxDb21tYW5kKCkgdG8gaGVyZSwgYnV0IHNwbGl0IHRvIG11bHRpcGxlIG1ldGhvZHMuXHJcbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJTaGVsbENvbW1hbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVucmVnaXN0ZXJGcm9tQ29tbWFuZFBhbGV0dGUoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRklYTUU6IEkgdGhpbmsgdGhlIHVucmVnaXN0ZXJpbmcgZG9lcyBub3Qgd29yay5cclxuICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW4ub2JzaWRpYW5fY29tbWFuZHNbdGhpcy5nZXRJZCgpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eSBhbmQgcmV0dXJuczpcclxuICAgICAqICAtIHRydWUsIGlmIHRoZSB2YWx1ZSBpcyBcImVuYWJsZWRcIiBvciBcInVubGlzdGVkXCJcclxuICAgICAqICAtIGZhbHNlLCBpZiB0aGUgdmFsdWUgaXMgXCJkaXNhYmxlZFwiXHJcbiAgICAgKlxyXG4gICAgICogQWRkaW5nIHRvIGNvbW1hbmQgcGFsZXR0ZSBhbHNvIGVuYWJsZXMgaG90a2V5cywgd2hpY2ggaXMgd2h5IGFkZGluZyBjYW4gYmUgcGVybWl0dGVkLCBidXQgc2hvd2luZyBkZW5pZWQsIGlmIGEgc2hlbGwgY29tbWFuZCBzaG91bGQgb25seSBiZSBhdmFpbGFibGUgdmlhIGhvdGtleXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYW5BZGRUb0NvbW1hbmRQYWxldHRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZ3VyYXRpb24oKS5jb21tYW5kX3BhbGV0dGVfYXZhaWxhYmlsaXR5ICE9PSBcImRpc2FibGVkXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkgYW5kIHJldHVybnM6XHJcbiAgICAgKiAgLSB0cnVlLCBpZiB0aGUgdmFsdWUgaXMgXCJlbmFibGVkXCJcclxuICAgICAqICAtIGZhbHNlLCBpZiB0aGUgdmFsdWUgaXMgXCJkaXNhYmxlZFwiIG9yIFwidW5saXN0ZWRcIlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FuU2hvd0luQ29tbWFuZFBhbGV0dGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpLmNvbW1hbmRfcGFsZXR0ZV9hdmFpbGFiaWxpdHkgPT09IFwiZW5hYmxlZFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwYXJzZVZhcmlhYmxlcyhzY19ldmVudD86IFNDX0V2ZW50KTogUGFyc2luZ1Jlc3VsdCB7XHJcbiAgICAgICAgLy8gUGFyc2UgdmFyaWFibGVzIGluIHRoZSBhY3R1YWwgc2hlbGwgY29tbWFuZFxyXG4gICAgICAgIGNvbnN0IHBhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kOiBcIlwiLFxyXG4gICAgICAgICAgICBhbGlhczogXCJcIixcclxuICAgICAgICAgICAgc3VjY2VlZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3JfbWVzc2FnZXM6IFtdLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcnNlZF9zaGVsbF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcy5wbHVnaW4sIHRoaXMuZ2V0U2hlbGxDb21tYW5kKCksIHRoaXMuZ2V0U2hlbGwoKSwgc2NfZXZlbnQpO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRfc2hlbGxfY29tbWFuZCkpIHtcclxuICAgICAgICAgICAgLy8gVmFyaWFibGUgcGFyc2luZyBmYWlsZWQsIGJlY2F1c2UgYW4gYXJyYXkgd2FzIHJldHVybmVkLCB3aGljaCBjb250YWlucyBlcnJvciBtZXNzYWdlcy5cclxuICAgICAgICAgICAgZGVidWdMb2coXCJTaGVsbCBjb21tYW5kIHByZXZpZXc6IFZhcmlhYmxlIHBhcnNpbmcgZmFpbGVkIGZvciBzaGVsbCBjb21tYW5kIFwiICsgdGhpcy5nZXRTaGVsbENvbW1hbmQoKSk7XHJcbiAgICAgICAgICAgIHBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlcyA9IHBhcnNlZF9zaGVsbF9jb21tYW5kO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2luZ19yZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVmFyaWFibGUgcGFyc2luZyBzdWNjZWVkZWQuXHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcGFyc2VkIHZhbHVlcy5cclxuICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQuc2hlbGxfY29tbWFuZCA9IHBhcnNlZF9zaGVsbF9jb21tYW5kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWxzbyBwYXJzZSB2YXJpYWJsZXMgaW4gYW4gYWxpYXMsIGluIGNhc2UgdGhlIGNvbW1hbmQgaGFzIG9uZS4gVmFyaWFibGVzIGluIGFsaWFzZXMgZG8gbm90IGRvIGFueXRoaW5nIHByYWN0aWNhbCwgYnV0IHRoZXkgY2FuIHJldmVhbCB0aGUgdXNlciB3aGF0IHZhcmlhYmxlcyBhcmUgdXNlZCBpbiB0aGUgY29tbWFuZC5cclxuICAgICAgICBjb25zdCBwYXJzZWRfYWxpYXMgPSBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcyh0aGlzLnBsdWdpbiwgdGhpcy5nZXRBbGlhcygpLCB0aGlzLmdldFNoZWxsKCksIHNjX2V2ZW50KTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRfYWxpYXMpKSB7XHJcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIHBhcnNpbmcgZmFpbGVkLCBiZWNhdXNlIGFuIGFycmF5IHdhcyByZXR1cm5lZCwgd2hpY2ggY29udGFpbnMgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwiU2hlbGwgY29tbWFuZCBwcmV2aWV3OiBWYXJpYWJsZSBwYXJzaW5nIGZhaWxlZCBmb3IgYWxpYXMgXCIgKyB0aGlzLmdldEFsaWFzKCkpO1xyXG4gICAgICAgICAgICBwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcGFyc2luZ19yZXN1bHQuZXJyb3JfbWVzc2FnZXMgPSBwYXJzZWRfYWxpYXM7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzaW5nX3Jlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBWYXJpYWJsZSBwYXJzaW5nIHN1Y2NlZWRlZC5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBwYXJzZWQgdmFsdWVzLlxyXG4gICAgICAgICAgICBwYXJzaW5nX3Jlc3VsdC5hbGlhcyA9IHBhcnNlZF9hbGlhcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsbCBva1xyXG4gICAgICAgIHBhcnNpbmdfcmVzdWx0LnN1Y2NlZWRlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNpbmdfcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRPYnNpZGlhbkNvbW1hbmQob2JzaWRpYW5fY29tbWFuZDogQ29tbWFuZCkge1xyXG4gICAgICAgIHRoaXMub2JzaWRpYW5fY29tbWFuZCA9IG9ic2lkaWFuX2NvbW1hbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBObyByZW5hbWluZyBpcyBkb25lIGlmIHRoZSBzaGVsbCBjb21tYW5kIGlzIGV4Y2x1ZGVkIGZyb20gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbmFtZU9ic2lkaWFuQ29tbWFuZChzaGVsbF9jb21tYW5kOiBzdHJpbmcsIGFsaWFzOiBzdHJpbmcpIHtcclxuICAgICAgICAvLyBSZW5hbWUgdGhlIGNvbW1hbmQgaW4gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luTmFtZSgpICsgXCI6IFwiOyAvLyBOb3JtYWxseSBPYnNpZGlhbiBwcmVmaXhlcyBhbGwgY29tbWFuZHMgd2l0aCB0aGUgcGx1Z2luIG5hbWUgYXV0b21hdGljYWxseSwgYnV0IG5vdyB0aGF0IHdlIGFyZSBhY3R1YWxseSBfZWRpdGluZ18gYSBjb21tYW5kIGluIHRoZSBwYWxldHRlIChub3QgY3JlYXRpbmcgYSBuZXcgb25lKSwgT2JzaWRpYW4gd29uJ3QgZG8gdGhlIHByZWZpeGluZyBmb3IgdXMuXHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNoZWxsIGNvbW1hbmQgaXMgYWN0dWFsbHkgcmVnaXN0ZXJlZCB0byBPYnNpZGlhbidzIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSB0aGlzLm9ic2lkaWFuX2NvbW1hbmQpIHtcclxuICAgICAgICAgICAgLy8gWWVzLCB0aGUgc2hlbGwgY29tbWFuZCBpcyByZWdpc3RlcmVkIGluIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlLlxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbW1hbmQgcGFsZXR0ZSBuYW1lLlxyXG4gICAgICAgICAgICB0aGlzLm9ic2lkaWFuX2NvbW1hbmQubmFtZSA9IHByZWZpeCArIGdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZSh0aGlzLnBsdWdpbiwgc2hlbGxfY29tbWFuZCwgYWxpYXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgc2hlbGwgY29tbWFuZCdzIFwiY29tbWFuZF9wYWxldHRlX2F2YWlsYWJpbGl0eVwiIHNldHRpbmdzIGlzIHNldCB0byBcImRpc2FibGVkXCIsIHRoZW4gdGhlIHNoZWxsIGNvbW1hbmQgaXMgbm90IHByZXNlbnQgaW4gdGhpcy5vYnNpZGlhbl9jb21tYW5kIGFuZCBzbyB0aGUgY29tbWFuZCBwYWxldHRlIG5hbWUgZG9lcyBub3QgbmVlZCB1cGRhdGluZy5cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYXJzaW5nUmVzdWx0IHtcclxuICAgIHNoZWxsX2NvbW1hbmQ6IHN0cmluZztcclxuICAgIGFsaWFzOiBzdHJpbmc7XHJcbiAgICBzdWNjZWVkZWQ6IGJvb2xlYW47XHJcbiAgICBlcnJvcl9tZXNzYWdlczogc3RyaW5nW107XHJcbn0iLCIvKipcclxuICogQ29waWVkIDIwMjEtMTAtMjkgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9UaGVEaXN0YW50U2VhLzgwMjEzNTlcclxuICogTW9kaWZpY2F0aW9uczpcclxuICogIC0gTWFkZSBjb21wYXRpYmxlIHdpdGggVHlwZVNjcmlwdCBieSBhZGRpbmcgdHlwZSBkZWZpbml0aW9ucy5cclxuICogIC0gQ2hhbmdlZCB2YXIgdG8gbGV0LlxyXG4gKlxyXG4gKiBDb21wYXJlcyB0d28gc29mdHdhcmUgdmVyc2lvbiBudW1iZXJzIChlLmcuIFwiMS43LjFcIiBvciBcIjEuMmJcIikuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gd2FzIGJvcm4gaW4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjgzMjcyMS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHYxIFRoZSBmaXJzdCB2ZXJzaW9uIHRvIGJlIGNvbXBhcmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdjIgVGhlIHNlY29uZCB2ZXJzaW9uIHRvIGJlIGNvbXBhcmVkLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIGZsYWdzIHRoYXQgYWZmZWN0IGNvbXBhcmlzb24gYmVoYXZpb3I6XHJcbiAqIDx1bD5cclxuICogICAgIDxsaT5cclxuICogICAgICAgICA8dHQ+bGV4aWNvZ3JhcGhpY2FsOiB0cnVlPC90dD4gY29tcGFyZXMgZWFjaCBwYXJ0IG9mIHRoZSB2ZXJzaW9uIHN0cmluZ3MgbGV4aWNvZ3JhcGhpY2FsbHkgaW5zdGVhZCBvZlxyXG4gKiAgICAgICAgIG5hdHVyYWxseTsgdGhpcyBhbGxvd3Mgc3VmZml4ZXMgc3VjaCBhcyBcImJcIiBvciBcImRldlwiIGJ1dCB3aWxsIGNhdXNlIFwiMS4xMFwiIHRvIGJlIGNvbnNpZGVyZWQgc21hbGxlciB0aGFuXHJcbiAqICAgICAgICAgXCIxLjJcIi5cclxuICogICAgIDwvbGk+XHJcbiAqICAgICA8bGk+XHJcbiAqICAgICAgICAgPHR0Pnplcm9FeHRlbmQ6IHRydWU8L3R0PiBjaGFuZ2VzIHRoZSByZXN1bHQgaWYgb25lIHZlcnNpb24gc3RyaW5nIGhhcyBsZXNzIHBhcnRzIHRoYW4gdGhlIG90aGVyLiBJblxyXG4gKiAgICAgICAgIHRoaXMgY2FzZSB0aGUgc2hvcnRlciBzdHJpbmcgd2lsbCBiZSBwYWRkZWQgd2l0aCBcInplcm9cIiBwYXJ0cyBpbnN0ZWFkIG9mIGJlaW5nIGNvbnNpZGVyZWQgc21hbGxlci5cclxuICogICAgIDwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8TmFOfVxyXG4gKiA8dWw+XHJcbiAqICAgIDxsaT4wIGlmIHRoZSB2ZXJzaW9ucyBhcmUgZXF1YWw8L2xpPlxyXG4gKiAgICA8bGk+YSBuZWdhdGl2ZSBpbnRlZ2VyIGlmZiB2MSA8IHYyPC9saT5cclxuICogICAgPGxpPmEgcG9zaXRpdmUgaW50ZWdlciBpZmYgdjEgPiB2MjwvbGk+XHJcbiAqICAgIDxsaT5OYU4gaWYgZWl0aGVyIHZlcnNpb24gc3RyaW5nIGlzIGluIHRoZSB3cm9uZyBmb3JtYXQ8L2xpPlxyXG4gKiA8L3VsPlxyXG4gKlxyXG4gKiBAY29weXJpZ2h0IGJ5IEpvbiBQYXBhaW9hbm5vdSAoW1wiam9oblwiLCBcInBhcGFpb2Fubm91XCJdLmpvaW4oXCIuXCIpICsgXCJAZ21haWwuY29tXCIpXHJcbiAqIEBsaWNlbnNlIFRoaXMgZnVuY3Rpb24gaXMgaW4gdGhlIHB1YmxpYyBkb21haW4uIERvIHdoYXQgeW91IHdhbnQgd2l0aCBpdCwgbm8gc3RyaW5ncyBhdHRhY2hlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uQ29tcGFyZSh2MTogc3RyaW5nLCB2Mjogc3RyaW5nLCBvcHRpb25zOiB7bGV4aWNvZ3JhcGhpY2FsPzogYm9vbGVhbiwgemVyb0V4dGVuZD86IGJvb2xlYW59ID0ge30pIHtcclxuICAgIGxldCBsZXhpY29ncmFwaGljYWwgPSBvcHRpb25zICYmIG9wdGlvbnMubGV4aWNvZ3JhcGhpY2FsLFxyXG4gICAgICAgIHplcm9FeHRlbmQgPSBvcHRpb25zICYmIG9wdGlvbnMuemVyb0V4dGVuZCxcclxuICAgICAgICB2MXBhcnRzOiBhbnkgPSB2MS5zcGxpdCgnLicpLFxyXG4gICAgICAgIHYycGFydHM6IGFueSA9IHYyLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNWYWxpZFBhcnQoeDogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIChsZXhpY29ncmFwaGljYWwgPyAvXlxcZCtbQS1aYS16XSokLyA6IC9eXFxkKyQvKS50ZXN0KHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdjFwYXJ0cy5ldmVyeShpc1ZhbGlkUGFydCkgfHwgIXYycGFydHMuZXZlcnkoaXNWYWxpZFBhcnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoemVyb0V4dGVuZCkge1xyXG4gICAgICAgIHdoaWxlICh2MXBhcnRzLmxlbmd0aCA8IHYycGFydHMubGVuZ3RoKSB2MXBhcnRzLnB1c2goXCIwXCIpO1xyXG4gICAgICAgIHdoaWxlICh2MnBhcnRzLmxlbmd0aCA8IHYxcGFydHMubGVuZ3RoKSB2MnBhcnRzLnB1c2goXCIwXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbGV4aWNvZ3JhcGhpY2FsKSB7XHJcbiAgICAgICAgdjFwYXJ0cyA9IHYxcGFydHMubWFwKE51bWJlcik7XHJcbiAgICAgICAgdjJwYXJ0cyA9IHYycGFydHMubWFwKE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2MXBhcnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHYycGFydHMubGVuZ3RoID09IGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodjFwYXJ0c1tpXSA9PSB2MnBhcnRzW2ldKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2MXBhcnRzW2ldID4gdjJwYXJ0c1tpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHYxcGFydHMubGVuZ3RoICE9IHYycGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG59IiwiaW1wb3J0IHtDb21tYW5kLCBOb3RpY2UsIFBsdWdpbn0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQge2V4ZWMsIEV4ZWNFeGNlcHRpb24sIEV4ZWNPcHRpb25zfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xyXG5pbXBvcnQge1xyXG5cdGNvbWJpbmVPYmplY3RzLFxyXG5cdGdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZSxcclxuXHRnZXRPcGVyYXRpbmdTeXN0ZW0sXHJcblx0Z2V0UGx1Z2luQWJzb2x1dGVQYXRoLFxyXG5cdGdldFZhdWx0QWJzb2x1dGVQYXRoLFxyXG59IGZyb20gXCIuL0NvbW1vblwiO1xyXG5pbXBvcnQge1J1bk1pZ3JhdGlvbnN9IGZyb20gXCIuL01pZ3JhdGlvbnNcIjtcclxuaW1wb3J0IHtcclxuXHRuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLFxyXG5cdFNoZWxsQ29tbWFuZHNDb25maWd1cmF0aW9uXHJcbn0gZnJvbSBcIi4vc2V0dGluZ3MvU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGdldERlZmF1bHRTZXR0aW5ncyxcclxuXHRTZXR0aW5nc1ZlcnNpb25TdHJpbmcsXHJcblx0U0NfTWFpblNldHRpbmdzLFxyXG59IGZyb20gXCIuL3NldHRpbmdzL1NDX01haW5TZXR0aW5nc1wiO1xyXG5pbXBvcnQge09ic2lkaWFuQ29tbWFuZHNDb250YWluZXJ9IGZyb20gXCIuL09ic2lkaWFuQ29tbWFuZHNDb250YWluZXJcIjtcclxuaW1wb3J0IHtTQ19NYWluU2V0dGluZ3NUYWJ9IGZyb20gXCIuL3NldHRpbmdzL1NDX01haW5TZXR0aW5nc1RhYlwiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xyXG5pbXBvcnQge0NvbmZpcm1FeGVjdXRpb25Nb2RhbH0gZnJvbSBcIi4vQ29uZmlybUV4ZWN1dGlvbk1vZGFsXCI7XHJcbmltcG9ydCB7aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0fSBmcm9tIFwiLi9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQge0Jhc2VFbmNvZGluZ09wdGlvbnN9IGZyb20gXCJmc1wiO1xyXG5pbXBvcnQge1BhcnNpbmdSZXN1bHQsIFRTaGVsbENvbW1hbmQsIFRTaGVsbENvbW1hbmRDb250YWluZXJ9IGZyb20gXCIuL1RTaGVsbENvbW1hbmRcIjtcclxuaW1wb3J0IHtnZXRVc2Vyc0RlZmF1bHRTaGVsbCwgaXNTaGVsbFN1cHBvcnRlZH0gZnJvbSBcIi4vU2hlbGxcIjtcclxuaW1wb3J0IHt2ZXJzaW9uQ29tcGFyZX0gZnJvbSBcIi4vbGliL3ZlcnNpb25fY29tcGFyZVwiO1xyXG5pbXBvcnQge2RlYnVnTG9nLCBzZXRERUJVR19PTn0gZnJvbSBcIi4vRGVidWdcIjtcclxuaW1wb3J0IHthZGRDdXN0b21BdXRvY29tcGxldGVJdGVtc30gZnJvbSBcIi4vc2V0dGluZ3Mvc2V0dGluZ19lbGVtZW50cy9BdXRvY29tcGxldGVcIjtcclxuaW1wb3J0IHtnZXRTQ19FdmVudHN9IGZyb20gXCIuL2V2ZW50cy9TQ19FdmVudExpc3RcIjtcclxuaW1wb3J0IHtTQ19FdmVudH0gZnJvbSBcIi4vZXZlbnRzL1NDX0V2ZW50XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTQ19QbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdC8qKlxyXG5cdCAqIERlZmluZXMgdGhlIHNldHRpbmdzIHN0cnVjdHVyZSB2ZXJzaW9uLiBDaGFuZ2UgdGhpcyB3aGVuIGEgbmV3IHBsdWdpbiB2ZXJzaW9uIGlzIHJlbGVhc2VkLCBidXQgb25seSBpZiB0aGF0IHBsdWdpblxyXG5cdCAqIHZlcnNpb24gaW50cm9kdWNlcyBjaGFuZ2VzIHRvIHRoZSBzZXR0aW5ncyBzdHJ1Y3R1cmUuIERvIG5vdCBjaGFuZ2UgaWYgdGhlIHNldHRpbmdzIHN0cnVjdHVyZSBzdGF5cyB1bmNoYW5nZWQuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBTZXR0aW5nc1ZlcnNpb246IFNldHRpbmdzVmVyc2lvblN0cmluZyA9IFwiMC4xMS4wXCI7XHJcblxyXG5cdHB1YmxpYyBzZXR0aW5nczogU0NfTWFpblNldHRpbmdzOyAvLyBUT0RPOiBNYWtlIHByaXZhdGUgYW5kIGFkZCBhIGdldHRlci5cclxuXHRwdWJsaWMgb2JzaWRpYW5fY29tbWFuZHM6IE9ic2lkaWFuQ29tbWFuZHNDb250YWluZXIgPSB7fTtcclxuXHRwcml2YXRlIHRfc2hlbGxfY29tbWFuZHM6IFRTaGVsbENvbW1hbmRDb250YWluZXIgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogSG9sZGVyIGZvciBzaGVsbCBjb21tYW5kcyBhbmQgYWxpYXNlcywgd2hvc2UgdmFyaWFibGVzIGFyZSBwYXJzZWQgYmVmb3JlIHRoZSBhY3R1YWwgZXhlY3V0aW9uIGR1cmluZyBjb21tYW5kXHJcblx0ICogcGFsZXR0ZSBwcmV2aWV3LiBUaGlzIGFycmF5IGdldHMgZW1wdGllZCBhZnRlciBldmVyeSB0aW1lIGEgc2hlbGwgY29tbWFuZCBpcyBleGVjdXRlZCB2aWEgdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgb25seSB1c2VkIGZvciBjb21tYW5kIHBhbGV0dGUsIG5vdCB3aGVuIGV4ZWN1dGluZyBhIHNoZWxsIGNvbW1hbmQgZnJvbSB0aGUgc2V0dGluZ3MgcGFuZWwsIG5vciB3aGVuXHJcblx0ICogZXhlY3V0aW5nIHNoZWxsIGNvbW1hbmRzIHZpYSBTQ19FdmVudHMuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHByaXZhdGUgY2FjaGVkX3BhcnNpbmdfcmVzdWx0czoge1xyXG5cdFx0W2tleTogc3RyaW5nXTogUGFyc2luZ1Jlc3VsdCxcclxuXHR9ID0ge307XHJcblxyXG5cdHB1YmxpYyBhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRkZWJ1Z0xvZygnbG9hZGluZyBwbHVnaW4nKTtcclxuXHJcblx0XHQvLyBMb2FkIHNldHRpbmdzXHJcblx0XHRpZiAoIWF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCkpIHtcclxuXHRcdFx0Ly8gTG9hZGluZyB0aGUgc2V0dGluZ3MgaGFzIGZhaWxlZCBkdWUgdG8gYW4gdW5zdXBwb3J0ZWQgc2V0dGluZ3MgZmlsZSB2ZXJzaW9uLlxyXG5cdFx0XHQvLyBUaGUgcGx1Z2luIHNob3VsZCBub3QgYmUgdXNlZCwgYW5kIGl0IGhhcyBhY3R1YWxseSBkaXNhYmxlZCBpdHNlbGYsIGJ1dCB0aGUgY29kZSBleGVjdXRpb24gbmVlZHMgdG8gYmVcclxuXHRcdFx0Ly8gc3RvcHBlZCBtYW51YWxseS5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJ1biBwb3NzaWJsZSBjb25maWd1cmF0aW9uIG1pZ3JhdGlvbnNcclxuXHRcdGF3YWl0IFJ1bk1pZ3JhdGlvbnModGhpcyk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgVFNoZWxsQ29tbWFuZCBvYmplY3RzIGZyb20gY29uZmlndXJhdGlvbiAob25seSBhZnRlciBjb25maWd1cmF0aW9uIG1pZ3JhdGlvbnMgYXJlIGRvbmUpXHJcblx0XHR0aGlzLmxvYWRUU2hlbGxDb21tYW5kcygpO1xyXG5cclxuXHRcdC8vIE1ha2UgYWxsIGRlZmluZWQgc2hlbGwgY29tbWFuZHMgdG8gYXBwZWFyIGluIHRoZSBPYnNpZGlhbiBjb21tYW5kIHBhbGV0dGUuXHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kcyA9IHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdGZvciAoY29uc3Qgc2hlbGxfY29tbWFuZF9pZCBpbiBzaGVsbF9jb21tYW5kcykge1xyXG5cdFx0XHRjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuXHRcdFx0aWYgKHRfc2hlbGxfY29tbWFuZC5jYW5BZGRUb0NvbW1hbmRQYWxldHRlKCkpIHtcclxuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQZXJmb3JtIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIGlmIGVuYWJsZWQuXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVfZXZlbnRzKSB7XHJcblx0XHRcdHRoaXMucmVnaXN0ZXJTQ19FdmVudHMoZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExvYWQgYSBjdXN0b20gYXV0b2NvbXBsZXRlIGxpc3QgaWYgaXQgZXhpc3RzLlxyXG5cdFx0dGhpcy5sb2FkQ3VzdG9tQXV0b2NvbXBsZXRlTGlzdCgpO1xyXG5cclxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU0NfTWFpblNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGxvYWRUU2hlbGxDb21tYW5kcygpIHtcclxuXHRcdHRoaXMudF9zaGVsbF9jb21tYW5kcyA9IHt9O1xyXG5cdFx0Y29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucyA9IHRoaXMuZ2V0U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbnMoKTtcclxuXHJcblx0XHRmb3IgKGNvbnN0IHNoZWxsX2NvbW1hbmRfaWQgaW4gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucykge1xyXG5cdFx0XHR0aGlzLnRfc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0gPSBuZXcgVFNoZWxsQ29tbWFuZCh0aGlzLCBzaGVsbF9jb21tYW5kX2lkLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zW3NoZWxsX2NvbW1hbmRfaWRdKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRUU2hlbGxDb21tYW5kcygpIHtcclxuXHRcdHJldHVybiB0aGlzLnRfc2hlbGxfY29tbWFuZHM7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25zKCk6IFNoZWxsQ29tbWFuZHNDb25maWd1cmF0aW9uIHtcclxuXHRcdHJldHVybiB0aGlzLnNldHRpbmdzLnNoZWxsX2NvbW1hbmRzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBzaGVsbCBjb21tYW5kIG9iamVjdCBhbmQgcmVnaXN0ZXJzIGl0IHRvIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlLCBidXQgZG9lcyBub3Qgc2F2ZSB0aGUgbW9kaWZpZWRcclxuXHQgKiBjb25maWd1cmF0aW9uIHRvIGRpc2suIFRvIHNhdmUgdGhlIGFkZGl0aW9uLCBjYWxsIHNhdmVTZXR0aW5ncygpLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBuZXdUU2hlbGxDb21tYW5kKCkge1xyXG5cdFx0Y29uc3Qgc2hlbGxfY29tbWFuZF9pZCA9IHRoaXMuZ2VuZXJhdGVOZXdTaGVsbENvbW1hbmRJRCgpO1xyXG5cdFx0Y29uc3Qgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uID0gbmV3U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbigpO1xyXG5cdFx0dGhpcy5zZXR0aW5ncy5zaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXSA9IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjtcclxuXHRcdGNvbnN0IHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCA9IG5ldyBUU2hlbGxDb21tYW5kKHRoaXMsIHNoZWxsX2NvbW1hbmRfaWQsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7XHJcblx0XHR0aGlzLnRfc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0gPSB0X3NoZWxsX2NvbW1hbmQ7XHJcblx0XHRpZiAodF9zaGVsbF9jb21tYW5kLmNhbkFkZFRvQ29tbWFuZFBhbGV0dGUoKSkgeyAvLyBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLCBiZWNhdXNlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZW5hYmxlcyBhZGRpbmcgdG8gdGhlIGNvbW1hbmQgcGFsZXR0ZSwgYnV0IGNoZWNrIGp1c3QgaW4gY2FzZS5cclxuXHRcdFx0dGhpcy5yZWdpc3RlclNoZWxsQ29tbWFuZCh0X3NoZWxsX2NvbW1hbmQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRfc2hlbGxfY29tbWFuZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRPRE86IE1vdmUgdG8gVFNoZWxsQ29tbWFuZC5yZWdpc3RlclRvQ29tbWFuZFBhbGV0dGUoKSwgYnV0IHNwbGl0IHRvIG11bHRpcGxlIG1ldGhvZHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdF9zaGVsbF9jb21tYW5kXHJcblx0ICovXHJcblx0cHVibGljIHJlZ2lzdGVyU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCkge1xyXG5cdFx0Y29uc3Qgc2hlbGxfY29tbWFuZF9pZCA9IHRfc2hlbGxfY29tbWFuZC5nZXRJZCgpO1xyXG5cdFx0ZGVidWdMb2coXCJSZWdpc3RlcmluZyBzaGVsbCBjb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfaWQgKyBcIi4uLlwiKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgYSBmdW5jdGlvbiBmb3IgZXhlY3V0aW5nIHRoZSBzaGVsbCBjb21tYW5kLlxyXG5cdFx0Y29uc3QgZXhlY3V0b3IgPSAocGFyc2luZ19yZXN1bHQ6IFBhcnNpbmdSZXN1bHQgfCB1bmRlZmluZWQpID0+IHtcclxuXHRcdFx0aWYgKHVuZGVmaW5lZCA9PT0gcGFyc2luZ19yZXN1bHQpIHtcclxuXHRcdFx0XHRwYXJzaW5nX3Jlc3VsdCA9IHRfc2hlbGxfY29tbWFuZC5wYXJzZVZhcmlhYmxlcygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQpIHtcclxuXHRcdFx0XHQvLyBUaGUgY29tbWFuZCB3YXMgcGFyc2VkIGNvcnJlY3RseS5cclxuXHRcdFx0XHR0aGlzLmNvbmZpcm1BbmRFeGVjdXRlU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZCwgcGFyc2luZ19yZXN1bHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFRoZSBjb21tYW5kIGNvdWxkIG5vdCBiZSBwYXJzZWQgY29ycmVjdGx5LlxyXG5cdFx0XHRcdC8vIERpc3BsYXkgZXJyb3IgbWVzc2FnZXNcclxuXHRcdFx0XHR0aGlzLm5ld0Vycm9ycyhwYXJzaW5nX3Jlc3VsdC5lcnJvcl9tZXNzYWdlcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWdpc3RlciBhbiBPYnNpZGlhbiBjb21tYW5kXHJcblx0XHRjb25zdCBvYnNpZGlhbl9jb21tYW5kOiBDb21tYW5kID0ge1xyXG5cdFx0XHRpZDogdGhpcy5nZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZElkKHNoZWxsX2NvbW1hbmRfaWQpLFxyXG5cdFx0XHRuYW1lOiBnZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZE5hbWUodGhpcywgdF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpLCB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSksIC8vIFdpbGwgYmUgb3ZlcnJpZGRlbiBpbiBjb21tYW5kIHBhbGV0dGUsIGJ1dCB0aGlzIHdpbGwgcHJvYmFibHkgc2hvdyB1cCBpbiBob3RrZXkgc2V0dGluZ3MgcGFuZWwuXHJcblx0XHRcdC8vIFVzZSAnY2hlY2tDYWxsYmFjaycgaW5zdGVhZCBvZiBub3JtYWwgJ2NhbGxiYWNrJyBiZWNhdXNlIHdlIGFsc28gd2FudCB0byBnZXQgY2FsbGVkIHdoZW4gdGhlIGNvbW1hbmQgcGFsZXR0ZSBpcyBvcGVuZWQuXHJcblx0XHRcdGNoZWNrQ2FsbGJhY2s6IChpc19vcGVuaW5nX2NvbW1hbmRfcGFsZXR0ZSkgPT4ge1xyXG5cdFx0XHRcdGlmIChpc19vcGVuaW5nX2NvbW1hbmRfcGFsZXR0ZSkge1xyXG5cdFx0XHRcdFx0Ly8gVGhlIHVzZXIgaXMgY3VycmVudGx5IG9wZW5pbmcgdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuXHJcblx0XHRcdFx0XHQvLyBDaGVjayBjYW4gdGhlIHNoZWxsIGNvbW1hbmQgYmUgc2hvd24gaW4gY29tbWFuZCBwYWxldHRlXHJcblx0XHRcdFx0XHRpZiAoIXRfc2hlbGxfY29tbWFuZC5jYW5TaG93SW5Db21tYW5kUGFsZXR0ZSgpKSB7XHJcblx0XHRcdFx0XHRcdC8vIENhbmNlbCBwcmV2aWV3IGFuZCBkZW55IHNob3dpbmcgaW4gY29tbWFuZCBwYWxldHRlLlxyXG5cdFx0XHRcdFx0XHRkZWJ1Z0xvZyhcIlNoZWxsIGNvbW1hbmQgI1wiICsgdF9zaGVsbF9jb21tYW5kLmdldElkKCkgKyBcIiB3b24ndCBiZSBzaG93biBpbiBjb21tYW5kIHBhbGV0dGUuXCIpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gRG8gbm90IGV4ZWN1dGUgdGhlIGNvbW1hbmQgeWV0LCBidXQgcGFyc2UgdmFyaWFibGVzIGZvciBwcmV2aWV3LCBpZiBlbmFibGVkIGluIHRoZSBzZXR0aW5ncy5cclxuXHRcdFx0XHRcdGRlYnVnTG9nKFwiR2V0dGluZyBjb21tYW5kIHBhbGV0dGUgcHJldmlldyBmb3Igc2hlbGwgY29tbWFuZCAjXCIgKyB0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKSk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5wcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGUpIHtcclxuXHRcdFx0XHRcdFx0Ly8gUHJlcGFyc2UgdmFyaWFibGVzXHJcblx0XHRcdFx0XHRcdGNvbnN0IHBhcnNpbmdfcmVzdWx0ID0gdF9zaGVsbF9jb21tYW5kLnBhcnNlVmFyaWFibGVzKCk7XHJcblx0XHRcdFx0XHRcdGlmIChwYXJzaW5nX3Jlc3VsdC5zdWNjZWVkZWQpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBQYXJzaW5nIHN1Y2NlZWRlZFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBSZW5hbWUgT2JzaWRpYW4gY29tbWFuZFxyXG5cdFx0XHRcdFx0XHRcdHRfc2hlbGxfY29tbWFuZC5yZW5hbWVPYnNpZGlhbkNvbW1hbmQocGFyc2luZ19yZXN1bHQuc2hlbGxfY29tbWFuZCwgcGFyc2luZ19yZXN1bHQuYWxpYXMpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgcHJlcGFyc2VkIHZhcmlhYmxlcyBzbyB0aGF0IHRoZXkgd2lsbCBiZSB1c2VkIGlmIHRoaXMgc2hlbGwgY29tbWFuZCBnZXRzIGV4ZWN1dGVkLlxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY2FjaGVkX3BhcnNpbmdfcmVzdWx0c1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0gPSBwYXJzaW5nX3Jlc3VsdDtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gQWxsIGRvbmUgbm93XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBJZiBwYXJzaW5nIGZhaWxlZCAob3Igd2FzIGRpc2FibGVkKSwgdGhlbiB1c2UgdW5wYXJzZWQgdF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpIGFuZCB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKS5cclxuXHRcdFx0XHRcdHRfc2hlbGxfY29tbWFuZC5yZW5hbWVPYnNpZGlhbkNvbW1hbmQodF9zaGVsbF9jb21tYW5kLmdldFNoZWxsQ29tbWFuZCgpLCB0X3NoZWxsX2NvbW1hbmQuZ2V0QWxpYXMoKSk7XHJcblx0XHRcdFx0XHR0aGlzLmNhY2hlZF9wYXJzaW5nX3Jlc3VsdHNbdF9zaGVsbF9jb21tYW5kLmdldElkKCldID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBUaGUgdXNlciBoYXMgaW5zdHJ1Y3RlZCB0byBleGVjdXRlIHRoZSBjb21tYW5kLlxyXG5cdFx0XHRcdFx0ZXhlY3V0b3IoXHJcblx0XHRcdFx0XHRcdHRoaXMuY2FjaGVkX3BhcnNpbmdfcmVzdWx0c1t0X3NoZWxsX2NvbW1hbmQuZ2V0SWQoKV0gLy8gQ2FuIGJlIHVuZGVmaW5lZCwgaWYgbm8gcHJlcGFyc2luZyB3YXMgZG9uZS4gZXhlY3V0b3IoKSB3aWxsIGhhbmRsZSBwYXJzaW5nIHRoZW4uXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIERlbGV0ZSB0aGUgd2hvbGUgYXJyYXkgb2YgcHJlcGFyc2VkIGNvbW1hbmRzLiBFdmVuIHRob3VnaCB3ZSBvbmx5IHVzZWQganVzdCBvbmUgY29tbWFuZCBmcm9tIGl0LCB3ZSBuZWVkIHRvIG5vdGljZSB0aGF0IG9wZW5pbmcgYSBjb21tYW5kXHJcblx0XHRcdFx0XHQvLyBwYWxldHRlIG1pZ2h0IGdlbmVyYXRlIG11bHRpcGxlIHByZXBhcnNlZCBjb21tYW5kcyBpbiB0aGUgYXJyYXksIGJ1dCBhcyB0aGUgdXNlciBzZWxlY3RzIGFuZCBleGVjdXRlcyBvbmx5IG9uZSBjb21tYW5kLCBhbGwgdGhlc2UgdGVtcG9yYXJ5XHJcblx0XHRcdFx0XHQvLyBjb21tYW5kcyBhcmUgbm93IG9ic29sZXRlLiBEZWxldGUgdGhlbSBqdXN0IGluIGNhc2UgdGhlIHVzZXIgdG9nZ2xlcyB0aGUgdmFyaWFibGUgcHJldmlldyBmZWF0dXJlIG9mZiBpbiB0aGUgc2V0dGluZ3MsIG9yIGV4ZWN1dGVzIGNvbW1hbmRzIHZpYSBob3RrZXlzLiBXZSBkbyBub3Qgd2FudCB0b1xyXG5cdFx0XHRcdFx0Ly8gZXhlY3V0ZSBvYnNvbGV0ZSBjb21tYW5kcyBhY2NpZGVudGFsbHkuXHJcblx0XHRcdFx0XHQvLyBUaGlzIGRlbGV0aW9uIGFsc28gbmVlZHMgdG8gYmUgZG9uZSBldmVuIGlmIHRoZSBleGVjdXRlZCBjb21tYW5kIHdhcyBub3QgYSBwcmVwYXJzZWQgY29tbWFuZCwgYmVjYXVzZVxyXG5cdFx0XHRcdFx0Ly8gZXZlbiB3aGVuIHByZXBhcnNpbmcgaXMgdHVybmVkIG9uIGluIHRoZSBzZXR0aW5ncywgc29tZSBjb21tYW5kcyBtYXkgZmFpbCB0byBwYXJzZSwgYW5kIHRoZXJlZm9yZSB0aGV5IHdvdWxkIG5vdCBiZSBpbiB0aGlzIGFycmF5LCBidXQgb3RoZXJcclxuXHRcdFx0XHRcdC8vIGNvbW1hbmRzIG1pZ2h0IGJlLlxyXG5cdFx0XHRcdFx0dGhpcy5jYWNoZWRfcGFyc2luZ19yZXN1bHRzID0ge307IC8vIFJlbW92ZXMgb2Jzb2xldGUgcHJlcGFyc2VkIHZhcmlhYmxlcyBmcm9tIGFsbCBzaGVsbCBjb21tYW5kcy5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR0aGlzLmFkZENvbW1hbmQob2JzaWRpYW5fY29tbWFuZClcclxuXHRcdHRoaXMub2JzaWRpYW5fY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0gPSBvYnNpZGlhbl9jb21tYW5kOyAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIHNvIHRoYXQgd2UgY2FuIGVkaXQgdGhlIGNvbW1hbmQgbGF0ZXIgaW4gU2hlbGxDb21tYW5kc1NldHRpbmdzVGFiIGlmIG5lZWRlZC4gVE9ETzogVXNlIHRTaGVsbENvbW1hbmQgaW5zdGVhZC5cclxuXHRcdHRfc2hlbGxfY29tbWFuZC5zZXRPYnNpZGlhbkNvbW1hbmQob2JzaWRpYW5fY29tbWFuZCk7XHJcblx0XHRkZWJ1Z0xvZyhcIlJlZ2lzdGVyZWQuXCIpXHJcblx0fVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogR29lcyB0aHJvdWdoIGFsbCBldmVudHMgYW5kIGFsbCBzaGVsbCBjb21tYW5kcywgYW5kIGZvciBlYWNoIHNoZWxsIGNvbW1hbmQsIHJlZ2lzdGVycyBhbGwgdGhlIGV2ZW50cyB0aGF0IHRoZSBzaGVsbFxyXG5cdCAqIGNvbW1hbmQgYXMgZW5hYmxlZCBpbiBpdHMgY29uZmlndXJhdGlvbi4gRG9lcyBub3QgbW9kaWZ5IHRoZSBjb25maWd1cmF0aW9ucy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjYWxsZWRfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3MgU2V0IHRvOiB0cnVlLCBpZiB0aGlzIGhhcHBlbnMgYWZ0ZXIgY2hhbmdpbmcgY29uZmlndXJhdGlvbjsgZmFsc2UsIGlmIHRoaXMgaGFwcGVucyBkdXJpbmcgbG9hZGluZyB0aGUgcGx1Z2luLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWdpc3RlclNDX0V2ZW50cyhjYWxsZWRfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3M6IGJvb2xlYW4pIHtcclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IE9ic2lkaWFuIGlzIGZ1bGx5IGxvYWRlZCBiZWZvcmUgYWxsb3dpbmcgYW55IGV2ZW50cyB0byB0cmlnZ2VyLlxyXG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHQvLyBFdmVuIGFmdGVyIE9ic2lkaWFuIGlzIGZ1bGx5IGxvYWRlZCwgd2FpdCBhIHdoaWxlIGluIG9yZGVyIHRvIHByZXZlbnQgU0NfRXZlbnRfb25BY3RpdmVMZWFmQ2hhbmdlZCB0cmlnZ2VyaW5nIHJpZ2h0IGFmdGVyIHN0YXJ0LXVwLlxyXG5cdFx0XHQvLyBBdCBsZWFzdCBvbiBPYnNpZGlhbiAwLjEyLjE5IGl0J3Mgbm90IGVub3VnaCB0byBkZWxheSB1bnRpbCBvbkxheW91dFJlYWR5LCBuZWVkIHRvIHdhaXQgYSBiaXQgbW9yZSBpbiBvcmRlciB0byBhdm9pZCB0aGUgbWlzcy10cmlnZ2VyaW5nLlxyXG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IC8vIHNldFRpbWVvdXQoKSBzaG91bGQgbm90IG5lZWQgcmVnaXN0ZXJpbmcgdG8gT2JzaWRpYW4gQVBJLCBJIGd1ZXNzLlxyXG5cdFx0XHRcdC8vIEl0ZXJhdGUgYWxsIHNoZWxsIGNvbW1hbmRzIGFuZCByZWdpc3RlciBwb3NzaWJsZSBldmVudHMuXHJcblx0XHRcdFx0Y29uc3Qgc2hlbGxfY29tbWFuZHMgPSB0aGlzLmdldFRTaGVsbENvbW1hbmRzKCk7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBzaGVsbF9jb21tYW5kX2lkIGluIHNoZWxsX2NvbW1hbmRzKSB7XHJcblx0XHRcdFx0XHRjb25zdCB0X3NoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuXHRcdFx0XHRcdHRfc2hlbGxfY29tbWFuZC5yZWdpc3RlclNDX0V2ZW50cyhjYWxsZWRfYWZ0ZXJfY2hhbmdpbmdfc2V0dGluZ3MpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMCk7IC8vIDAgbWVhbnMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgb24gXCJ0aGUgbmV4dCBldmVudCBjeWNsZVwiLCBhY2NvcmRpbmcgdG8gd2luZG93LnNldFRpbWVvdXQoKSBkb2N1bWVudGF0aW9uLiBJdCBzaG91bGQgYmUgYSBsb25nIGVub3VnaCBkZWxheS4gQnV0IGlmIFNDX0V2ZW50X29uQWN0aXZlTGVhZkNoYW5nZWQgc3RpbGwgZ2V0cyB0cmlnZ2VyZWQgZHVyaW5nIHN0YXJ0LXVwLCB0aGlzIHZhbHVlIGNhbiBiZSByYWlzZWQgdG8gZm9yIGV4YW1wbGUgMTAwMCAoPSBvbmUgc2Vjb25kKS5cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR29lcyB0aHJvdWdoIGFsbCBldmVudHMgYW5kIGFsbCBzaGVsbCBjb21tYW5kcywgYW5kIG1ha2VzIHN1cmUgYWxsIG9mIHRoZW0gYXJlIHVucmVnaXN0ZXJlZCwgZS5nLiB3aWxsIG5vdCB0cmlnZ2VyXHJcblx0ICogYXV0b21hdGljYWxseS4gRG9lcyBub3QgbW9kaWZ5IHRoZSBjb25maWd1cmF0aW9ucy5cclxuXHQgKi9cclxuXHRwdWJsaWMgdW5yZWdpc3RlclNDX0V2ZW50cygpIHtcclxuXHRcdC8vIEl0ZXJhdGUgYWxsIGV2ZW50c1xyXG5cdFx0Z2V0U0NfRXZlbnRzKHRoaXMpLmZvckVhY2goKHNjX2V2ZW50OiBTQ19FdmVudCkgPT4ge1xyXG5cdFx0XHQvLyBJdGVyYXRlIGFsbCBzaGVsbCBjb21tYW5kc1xyXG5cdFx0XHRjb25zdCBzaGVsbF9jb21tYW5kcyA9IHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdFx0Zm9yIChjb25zdCBzaGVsbF9jb21tYW5kX2lkIGluIHNoZWxsX2NvbW1hbmRzKSB7XHJcblx0XHRcdFx0Y29uc3QgdF9zaGVsbF9jb21tYW5kID0gc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF07XHJcblx0XHRcdFx0c2NfZXZlbnQudW5yZWdpc3Rlcih0X3NoZWxsX2NvbW1hbmQpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZElkKHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIFwic2hlbGwtY29tbWFuZC1cIiArIHNoZWxsX2NvbW1hbmRfaWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmQgVXNlZCBmb3IgcmVhZGluZyBvdGhlciBwcm9wZXJ0aWVzLiB0X3NoZWxsX2NvbW1hbmQuc2hlbGxfY29tbWFuZCB3b24ndCBiZSB1c2VkIVxyXG5cdCAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0IFRoZSBhY3R1YWwgc2hlbGwgY29tbWFuZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXHJcblx0ICovXHJcblx0cHVibGljIGNvbmZpcm1BbmRFeGVjdXRlU2hlbGxDb21tYW5kKHRfc2hlbGxfY29tbWFuZDogVFNoZWxsQ29tbWFuZCwgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdDogUGFyc2luZ1Jlc3VsdCkge1xyXG5cclxuXHRcdC8vIENoZWNrIGlmIHRoZSBjb21tYW5kIG5lZWRzIGNvbmZpcm1hdGlvbiBiZWZvcmUgZXhlY3V0aW9uXHJcblx0XHRpZiAodF9zaGVsbF9jb21tYW5kLmdldENvbmZpcm1FeGVjdXRpb24oKSkge1xyXG5cdFx0XHQvLyBZZXMsIGEgY29uZmlybWF0aW9uIGlzIG5lZWRlZC5cclxuXHRcdFx0Ly8gT3BlbiBhIGNvbmZpcm1hdGlvbiBtb2RhbC5cclxuXHRcdFx0bmV3IENvbmZpcm1FeGVjdXRpb25Nb2RhbCh0aGlzLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0LCB0X3NoZWxsX2NvbW1hbmQpXHJcblx0XHRcdFx0Lm9wZW4oKVxyXG5cdFx0XHQ7XHJcblx0XHRcdHJldHVybjsgLy8gRG8gbm90IGV4ZWN1dGUgbm93LiBUaGUgbW9kYWwgd2lsbCBjYWxsIGV4ZWN1dGVTaGVsbENvbW1hbmQoKSBsYXRlciBpZiBuZWVkZWQuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNvbmZpcm0uXHJcblx0XHRcdC8vIEV4ZWN1dGUuXHJcblx0XHRcdHRoaXMuZXhlY3V0ZVNoZWxsQ29tbWFuZCh0X3NoZWxsX2NvbW1hbmQsIHNoZWxsX2NvbW1hbmRfcGFyc2luZ19yZXN1bHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRG9lcyBub3QgYXNrIGZvciBjb25maXJtYXRpb24gYmVmb3JlIGV4ZWN1dGlvbi4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWY6IGEpIGEgY29uZmlybWF0aW9uIGlzIGFscmVhZHkgYXNrZWQgZnJvbSBhIHVzZXIsIG9yIGIpIHRoaXMgY29tbWFuZCBpcyBkZWZpbmVkIG5vdCB0byBuZWVkIGEgY29uZmlybWF0aW9uLlxyXG5cdCAqIFVzZSBjb25maXJtQW5kRXhlY3V0ZVNoZWxsQ29tbWFuZCgpIGluc3RlYWQgdG8gaGF2ZSBhIGNvbmZpcm1hdGlvbiBhc2tlZCBiZWZvcmUgdGhlIGV4ZWN1dGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0X3NoZWxsX2NvbW1hbmQgVXNlZCBmb3IgcmVhZGluZyBvdGhlciBwcm9wZXJ0aWVzLiB0X3NoZWxsX2NvbW1hbmQuc2hlbGxfY29tbWFuZCB3b24ndCBiZSB1c2VkIVxyXG5cdCAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0IFRoZSBhY3R1YWwgc2hlbGwgY29tbWFuZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgaXMgdGFrZW4gZnJvbSB0aGlzIG9iamVjdCdzICcuc2hlbGxfY29tbWFuZCcgcHJvcGVydHkuXHJcblx0ICovXHJcblx0cHVibGljIGV4ZWN1dGVTaGVsbENvbW1hbmQodF9zaGVsbF9jb21tYW5kOiBUU2hlbGxDb21tYW5kLCBzaGVsbF9jb21tYW5kX3BhcnNpbmdfcmVzdWx0OiBQYXJzaW5nUmVzdWx0KSB7XHJcblx0XHRjb25zdCB3b3JraW5nX2RpcmVjdG9yeSA9IHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpO1xyXG5cclxuXHRcdC8vIENoZWNrIHRoYXQgdGhlIHNoZWxsIGNvbW1hbmQgaXMgbm90IGVtcHR5XHJcblx0XHRjb25zdCBzaGVsbF9jb21tYW5kID0gc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdC5zaGVsbF9jb21tYW5kLnRyaW0oKTtcclxuXHRcdGlmICghc2hlbGxfY29tbWFuZC5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gSXQgaXMgZW1wdHlcclxuXHRcdFx0ZGVidWdMb2coXCJUaGUgc2hlbGwgY29tbWFuZCBpcyBlbXB0eS4gOihcIik7XHJcblx0XHRcdHRoaXMubmV3RXJyb3IoXCJUaGUgc2hlbGwgY29tbWFuZCBpcyBlbXB0eSA6KFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIHRoYXQgdGhlIGN1cnJlbnRseSBkZWZpbmVkIHNoZWxsIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi4gSWYgdXNpbmcgc3lzdGVtIGRlZmF1bHQgc2hlbGwsIGl0J3MgcG9zc2libGVcclxuXHRcdC8vIHRoYXQgdGhlIHNoZWxsIGlzIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQuIEFsc28sIHRoZSBzZXR0aW5ncyBmaWxlIGNhbiBiZSBlZGl0ZWQgbWFudWFsbHksIGFuZCBpbmNvcnJlY3RcclxuXHRcdC8vIHNoZWxsIGNhbiBiZSB3cml0dGVuIHRoZXJlLlxyXG5cdFx0Y29uc3Qgc2hlbGwgPSB0X3NoZWxsX2NvbW1hbmQuZ2V0U2hlbGwoKTtcclxuXHRcdGlmICghaXNTaGVsbFN1cHBvcnRlZChzaGVsbCkpIHtcclxuXHRcdFx0ZGVidWdMb2coXCJTaGVsbCBpcyBub3Qgc3VwcG9ydGVkOiBcIiArIHNoZWxsKTtcclxuXHRcdFx0dGhpcy5uZXdFcnJvcihcIlRoaXMgcGx1Z2luIGRvZXMgbm90IHN1cHBvcnQgdGhlIGZvbGxvd2luZyBzaGVsbDogXCIgKyBzaGVsbCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgd29ya2luZyBkaXJlY3RvcnkgZXhpc3RzIGFuZCBpcyBhIGZvbGRlclxyXG5cdFx0aWYgKCFmcy5leGlzdHNTeW5jKHdvcmtpbmdfZGlyZWN0b3J5KSkge1xyXG5cdFx0XHQvLyBXb3JraW5nIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdFxyXG5cdFx0XHQvLyBQcmV2ZW50IGV4ZWN1dGlvblxyXG5cdFx0XHRkZWJ1Z0xvZyhcIldvcmtpbmcgZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0OiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuXHRcdFx0dGhpcy5uZXdFcnJvcihcIldvcmtpbmcgZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0OiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKCFmcy5sc3RhdFN5bmMod29ya2luZ19kaXJlY3RvcnkpLmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0Ly8gV29ya2luZyBkaXJlY3RvcnkgaXMgbm90IGEgZGlyZWN0b3J5LlxyXG5cdFx0XHQvLyBQcmV2ZW50IGV4ZWN1dGlvblxyXG5cdFx0XHRkZWJ1Z0xvZyhcIldvcmtpbmcgZGlyZWN0b3J5IGV4aXN0cyBidXQgaXMgbm90IGEgZm9sZGVyOiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuXHRcdFx0dGhpcy5uZXdFcnJvcihcIldvcmtpbmcgZGlyZWN0b3J5IGV4aXN0cyBidXQgaXMgbm90IGEgZm9sZGVyOiBcIiArIHdvcmtpbmdfZGlyZWN0b3J5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFdvcmtpbmcgZGlyZWN0b3J5IGlzIE9LXHJcblx0XHRcdC8vIFByZXBhcmUgZXhlY3V0aW9uIG9wdGlvbnNcclxuXHRcdFx0Y29uc3Qgb3B0aW9uczogQmFzZUVuY29kaW5nT3B0aW9ucyAmIEV4ZWNPcHRpb25zID0ge1xyXG5cdFx0XHRcdFwiY3dkXCI6IHdvcmtpbmdfZGlyZWN0b3J5LFxyXG5cdFx0XHRcdFwic2hlbGxcIjogc2hlbGwsXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBFeGVjdXRlIHRoZSBzaGVsbCBjb21tYW5kXHJcblx0XHRcdGRlYnVnTG9nKFwiRXhlY3V0aW5nIGNvbW1hbmQgXCIgKyBzaGVsbF9jb21tYW5kICsgXCIgaW4gXCIgKyB3b3JraW5nX2RpcmVjdG9yeSArIFwiLi4uXCIpO1xyXG5cdFx0XHRleGVjKHNoZWxsX2NvbW1hbmQsIG9wdGlvbnMsIChlcnJvcjogRXhlY0V4Y2VwdGlvbnxudWxsLCBzdGRvdXQ6IHN0cmluZywgc3RkZXJyOiBzdHJpbmcpID0+IHtcclxuXHJcblx0XHRcdFx0Ly8gRGlkIHRoZSBzaGVsbCBjb21tYW5kIGV4ZWN1dGUgc3VjY2Vzc2Z1bGx5P1xyXG5cdFx0XHRcdGlmIChudWxsICE9PSBlcnJvcikge1xyXG5cdFx0XHRcdFx0Ly8gU29tZSBlcnJvciBvY2N1cnJlZFxyXG5cdFx0XHRcdFx0ZGVidWdMb2coXCJDb21tYW5kIGV4ZWN1dGVkIGFuZCBmYWlsZWQuIEVycm9yIG51bWJlcjogXCIgKyBlcnJvci5jb2RlICsgXCIuIE1lc3NhZ2U6IFwiICsgZXJyb3IubWVzc2FnZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhpcyBlcnJvciBzaG91bGQgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIG9yIG5vdFxyXG5cdFx0XHRcdFx0aWYgKHRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkuY29udGFpbnMoZXJyb3IuY29kZSkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gVGhlIHVzZXIgaGFzIGlnbm9yZWQgdGhpcyBlcnJvci5cclxuXHRcdFx0XHRcdFx0ZGVidWdMb2coXCJVc2VyIGhhcyBpZ25vcmVkIHRoaXMgZXJyb3IsIHNvIHdvbid0IGRpc3BsYXkgaXQuXCIpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG9ubHkgc3Rkb3V0IG91dHB1dCBzdHJlYW1cclxuXHRcdFx0XHRcdFx0aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0KHRoaXMsIHRfc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCwgc3Rkb3V0LCBcIlwiLCBudWxsKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIFNob3cgdGhlIGVycm9yLlxyXG5cdFx0XHRcdFx0XHRkZWJ1Z0xvZyhcIldpbGwgZGlzcGxheSB0aGUgZXJyb3IgdG8gdXNlci5cIik7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBDaGVjayB0aGF0IHN0ZGVyciBhY3R1YWxseSBjb250YWlucyBhbiBlcnJvciBtZXNzYWdlXHJcblx0XHRcdFx0XHRcdGlmICghc3RkZXJyLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFN0ZGVyciBpcyBlbXB0eSwgc28gdGhlIGVycm9yIG1lc3NhZ2UgaXMgcHJvYmFibHkgZ2l2ZW4gYnkgTm9kZS5qcydzIGNoaWxkX3Byb2Nlc3MuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRGlyZWN0IGVycm9yLm1lc3NhZ2UgdG8gdGhlIHN0ZGVyciB2YXJpYWJsZSwgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIGVycm9yLm1lc3NhZ2Ugd2hlbiBzdGRlcnIgaXMgdW5hdmFpbGFibGUuXHJcblx0XHRcdFx0XHRcdFx0c3RkZXJyID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGJvdGggc3Rkb3V0IGFuZCBzdGRlcnIgb3V0cHV0IHN0cmVhbXNcclxuXHRcdFx0XHRcdFx0aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0KHRoaXMsIHRfc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCwgc3Rkb3V0LCBzdGRlcnIsIGVycm9yLmNvZGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBQcm9iYWJseSBubyBlcnJvcnMsIGJ1dCBkbyBvbmUgbW9yZSBjaGVjay5cclxuXHJcblx0XHRcdFx0XHQvLyBFdmVuIHdoZW4gJ2Vycm9yJyBpcyBudWxsIGFuZCBldmVyeXRoaW5nIHNob3VsZCBiZSBvaywgdGhlcmUgbWF5IHN0aWxsIGJlIGVycm9yIG1lc3NhZ2VzIG91dHB1dHRlZCBpbiBzdGRlcnIuXHJcblx0XHRcdFx0XHRpZiAoc3RkZXJyLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgYSBzcGVjaWFsIGNhc2U6IHNob3VsZCBlcnJvciBjb2RlIDAgYmUgaWdub3JlZD9cclxuXHRcdFx0XHRcdFx0aWYgKHRfc2hlbGxfY29tbWFuZC5nZXRJZ25vcmVFcnJvckNvZGVzKCkuY29udGFpbnMoMCkpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBFeGl0IGNvZGUgMCBpcyBvbiB0aGUgaWdub3JlIGxpc3QsIHNvIHN1cHByZXNzIHN0ZGVyciBvdXRwdXQuXHJcblx0XHRcdFx0XHRcdFx0c3RkZXJyID0gXCJcIjtcclxuXHRcdFx0XHRcdFx0XHRkZWJ1Z0xvZyhcIlNoZWxsIGNvbW1hbmQgZXhlY3V0ZWQ6IEVuY291bnRlcmVkIGVycm9yIGNvZGUgMCwgYnV0IHN0ZGVyciBpcyBpZ25vcmVkLlwiKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRkZWJ1Z0xvZyhcIlNoZWxsIGNvbW1hbmQgZXhlY3V0ZWQ6IEVuY291bnRlcmVkIGVycm9yIGNvZGUgMCwgYW5kIHN0ZGVyciB3aWxsIGJlIHJlbGF5ZWQgdG8gYW4gb3V0cHV0IGhhbmRsZXIuXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRkZWJ1Z0xvZyhcIlNoZWxsIGNvbW1hbmQgZXhlY3V0ZWQ6IE5vIGVycm9ycy5cIik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG91dHB1dFxyXG5cdFx0XHRcdFx0aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0KHRoaXMsIHRfc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9wYXJzaW5nX3Jlc3VsdCwgc3Rkb3V0LCBzdGRlcnIsIDApOyAvLyBVc2UgemVybyBhcyBhbiBlcnJvciBjb2RlIGluc3RlYWQgb2YgbnVsbCAoMCBtZWFucyBubyBlcnJvcikuIElmIHN0ZGVyciBoYXBwZW5zIHRvIGNvbnRhaW4gc29tZXRoaW5nLCBleGl0IGNvZGUgMCBnZXRzIGRpc3BsYXllZCBpbiBhbiBlcnJvciBiYWxsb29uIChpZiB0aGF0IGlzIHNlbGVjdGVkIGFzIGEgZHJpdmVyIGZvciBzdGRlcnIpLlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldFdvcmtpbmdEaXJlY3RvcnkoKSB7XHJcblx0XHQvLyBSZXR1cm5zIGVpdGhlciBhIHVzZXIgZGVmaW5lZCB3b3JraW5nIGRpcmVjdG9yeSwgb3IgYW4gYXV0b21hdGljYWxseSBkZXRlY3RlZCBvbmUuXHJcblx0XHRjb25zdCB3b3JraW5nX2RpcmVjdG9yeSA9IHRoaXMuc2V0dGluZ3Mud29ya2luZ19kaXJlY3Rvcnk7XHJcblx0XHRpZiAod29ya2luZ19kaXJlY3RvcnkubGVuZ3RoID09IDApIHtcclxuXHRcdFx0Ly8gTm8gd29ya2luZyBkaXJlY3Rvcnkgc3BlY2lmaWVkLCBzbyB1c2UgdGhlIHZhdWx0IGRpcmVjdG9yeS5cclxuXHRcdFx0cmV0dXJuIGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKTtcclxuXHRcdH0gZWxzZSBpZiAoIXBhdGguaXNBYnNvbHV0ZSh3b3JraW5nX2RpcmVjdG9yeSkpIHtcclxuXHRcdFx0Ly8gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IGlzIHJlbGF0aXZlLlxyXG5cdFx0XHQvLyBIZWxwIHRvIG1ha2UgaXQgcmVmZXIgdG8gdGhlIHZhdWx0J3MgZGlyZWN0b3J5LiBXaXRob3V0IHRoaXMsIHRoZSByZWxhdGl2ZSBwYXRoIHdvdWxkIHJlZmVyIHRvIE9ic2lkaWFuJ3MgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSAoYXQgbGVhc3Qgb24gV2luZG93cykuXHJcblx0XHRcdHJldHVybiBwYXRoLmpvaW4oZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5hcHApLCB3b3JraW5nX2RpcmVjdG9yeSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gd29ya2luZ19kaXJlY3Rvcnk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgb251bmxvYWQoKSB7XHJcblx0XHRkZWJ1Z0xvZygndW5sb2FkaW5nIHBsdWdpbicpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY3VycmVudF9zZXR0aW5nc192ZXJzaW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIHNldHRpbmdzIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoaXMgcGx1Z2luIHZlcnNpb24sIG9yIGFuIGVycm9yIG1lc3NhZ2Ugc3RyaW5nIGlmIGl0J3Mgbm90IHN1cHBvcnRlZC5cclxuXHQgKi9cclxuXHRwcml2YXRlIGlzU2V0dGluZ3NWZXJzaW9uU3VwcG9ydGVkKGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvbjogU2V0dGluZ3NWZXJzaW9uU3RyaW5nKSB7XHJcblx0XHRpZiAoY3VycmVudF9zZXR0aW5nc192ZXJzaW9uID09PSBcInByaW9yLXRvLTAuNy4wXCIpIHtcclxuXHRcdFx0Ly8gMC54Lnkgc3VwcG9ydHMgYWxsIG9sZCBzZXR0aW5ncyBmb3JtYXRzIHRoYXQgZG8gbm90IGRlZmluZSBhIHZlcnNpb24gbnVtYmVyLiBUaGlzIHN1cHBvcnQgd2lsbCBiZSByZW1vdmVkIGluIDEuMC4wLlxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIENvbXBhcmUgdGhlIHZlcnNpb24gbnVtYmVyXHJcblx0XHRcdC8qKiBOb3RlIHRoYXQgdGhlIHBsdWdpbiB2ZXJzaW9uIG1heSBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdpbGwgYmUgdXNlZCBpbiB0aGUgdmVyc2lvbiBjb21wYXJpc29uLiBUaGUgcGx1Z2luIHZlcnNpb24gd2lsbCBiZSBkaXNwbGF5ZWQgaW4gcG9zc2libGUgZXJyb3IgbWVzc2FnZXMuICovXHJcblx0XHRcdGNvbnN0IHBsdWdpbl92ZXJzaW9uID0gdGhpcy5nZXRQbHVnaW5WZXJzaW9uKCk7XHJcblx0XHRcdGNvbnN0IHZlcnNpb25fY29tcGFyaXNvbiA9IHZlcnNpb25Db21wYXJlKFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb24sIGN1cnJlbnRfc2V0dGluZ3NfdmVyc2lvbik7XHJcblx0XHRcdGlmICh2ZXJzaW9uX2NvbXBhcmlzb24gPT09IDApIHtcclxuXHRcdFx0XHQvLyBUaGUgdmVyc2lvbnMgYXJlIGVxdWFsLlxyXG5cdFx0XHRcdC8vIFN1cHBvcnRlZC5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ZXJzaW9uX2NvbXBhcmlzb24gPCAwKSB7XHJcblx0XHRcdFx0Ly8gVGhlIGNvbXBhcmVkIHZlcnNpb24gaXMgbmV3ZXIgdGhhbiB3aGF0IHRoZSBwbHVnaW4gY2FuIHN1cHBvcnQuXHJcblx0XHRcdFx0cmV0dXJuIFwiVGhlIHNldHRpbmdzIGZpbGUgaXMgc2F2ZWQgYnkgYSBuZXdlciB2ZXJzaW9uIG9mIHRoaXMgcGx1Z2luLCBzbyB0aGlzIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHNldHRpbmdzIGZpbGUuIFBsZWFzZSB1cGdyYWRlIHRoaXMgcGx1Z2luIHRvIGF0IGxlYXN0IHZlcnNpb24gXCIgKyBjdXJyZW50X3NldHRpbmdzX3ZlcnNpb24gKyBcIi4gTm93IHRoZSBwbHVnaW4gdmVyc2lvbiBpcyBcIiArIHBsdWdpbl92ZXJzaW9uO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFRoZSBjb21wYXJlZCB2ZXJzaW9uIGlzIG9sZGVyIHRoYW4gdGhlIHZlcnNpb24gdGhhdCB0aGUgcGx1Z2luIGN1cnJlbnRseSB1c2VzIHRvIHdyaXRlIHNldHRpbmdzLlxyXG5cdFx0XHRcdC8vIDAueC55IHN1cHBvcnRzIGFsbCBvbGQgc2V0dGluZ3MgdmVyc2lvbnMuIEluIDEuMC4wLCBzb21lIG9sZCBzZXR0aW5ncyBmb3JtYXRzIG1pZ2h0IGxvc2UgdGhlaXIgc3VwcG9ydCwgYnV0IHRoYXQncyBub3QgeWV0IGNlcnRhaW4uXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0UGx1Z2luVmVyc2lvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm1hbmlmZXN0LnZlcnNpb247XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHJcblx0XHQvLyBUcnkgdG8gcmVhZCBhIHNldHRpbmdzIGZpbGVcclxuXHRcdGxldCBhbGxfc2V0dGluZ3M6IFNDX01haW5TZXR0aW5ncztcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7IC8vIE1heSBoYXZlIG1pc3NpbmcgbWFpbiBzZXR0aW5ncyBmaWVsZHMsIGlmIHRoZSBzZXR0aW5ncyBmaWxlIGlzIGZyb20gYW4gb2xkZXIgdmVyc2lvbiBvZiBTQy4gSXQgd2lsbCBiZSBtaWdyYXRlZCBsYXRlci5cclxuXHRcdGlmIChudWxsID09PSB0aGlzLnNldHRpbmdzKSB7XHJcblx0XHRcdC8vIFRoZSBzZXR0aW5ncyBmaWxlIGRvZXMgbm90IGV4aXN0LlxyXG5cdFx0XHQvLyBVc2UgZGVmYXVsdCBzZXR0aW5nc1xyXG5cdFx0XHR0aGlzLnNldHRpbmdzID0gZ2V0RGVmYXVsdFNldHRpbmdzKHRydWUpO1xyXG5cdFx0XHRhbGxfc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gU3VjY2VlZGVkIHRvIGxvYWQgYSBzZXR0aW5ncyBmaWxlLlxyXG5cdFx0XHQvLyBJbiBjYXNlIHRoZSBzZXR0aW5ncyBmaWxlIGRvZXMgbm90IGhhdmUgJ2RlYnVnJyBvciAnc2V0dGluZ3NfdmVyc2lvbicgZmllbGRzLCBjcmVhdGUgdGhlbS5cclxuXHRcdFx0YWxsX3NldHRpbmdzID0gY29tYmluZU9iamVjdHMoZ2V0RGVmYXVsdFNldHRpbmdzKGZhbHNlKSwgdGhpcy5zZXR0aW5ncyk7IC8vIFRoaXMgdGVtcG9yYXJ5IHNldHRpbmdzIG9iamVjdCBhbHdheXMgaGFzIGFsbCBmaWVsZHMgZGVmaW5lZCAoZXhjZXB0IHN1YiBmaWVsZHMsIHN1Y2ggYXMgc2hlbGwgY29tbWFuZCBzcGVjaWZpYyBmaWVsZHMsIG1heSBzdGlsbCBiZSBtaXNzaW5nLCBidXQgdGhleSBhcmUgbm90IG5lZWRlZCB0aGlzIGVhcmx5KS4gVGhpcyBpcyB1c2VkIHNvIHRoYXQgaXQncyBjZXJ0YWluIHRoYXQgdGhlIGZpZWxkcyAnZGVidWcnIGFuZCAnc2V0dGluZ3NfdmVyc2lvbicgZXhpc3QuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGRlYnVnIHN0YXR1cyAtIGJlZm9yZSB0aGlzIGxpbmUgZGVidWdnaW5nIGlzIGFsd2F5cyBPRkYhXHJcblx0XHRzZXRERUJVR19PTihhbGxfc2V0dGluZ3MuZGVidWcpO1xyXG5cclxuXHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBsb2FkZWQgc2V0dGluZ3MgZmlsZSBpcyBzdXBwb3J0ZWQuXHJcblx0XHRjb25zdCB2ZXJzaW9uX3N1cHBvcnQgPSB0aGlzLmlzU2V0dGluZ3NWZXJzaW9uU3VwcG9ydGVkKGFsbF9zZXR0aW5ncy5zZXR0aW5nc192ZXJzaW9uKTtcclxuXHRcdGlmICh0eXBlb2YgdmVyc2lvbl9zdXBwb3J0ID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIFRoZSBzZXR0aW5ncyB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuXHJcblx0XHRcdG5ldyBOb3RpY2UoXCJTSEVMTCBDT01NQU5EUyBQTFVHSU4gSEFTIERJU0FCTEVEIElUU0VMRiBpbiBvcmRlciB0byBwcmV2ZW50IG1pc2ludGVycHJldGluZyBzZXR0aW5ncyAvIGNvcnJ1cHRpbmcgdGhlIHNldHRpbmdzIGZpbGUhXCIsIDEyMCoxMDAwKTtcclxuXHRcdFx0bmV3IE5vdGljZSh2ZXJzaW9uX3N1cHBvcnQgYXMgc3RyaW5nLCAxMjAqMTAwMCk7XHJcblx0XHRcdGF3YWl0IHRoaXMuZGlzYWJsZVBsdWdpbigpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7IC8vIFRoZSBwbHVnaW4gc2hvdWxkIG5vdCBiZSB1c2VkLlxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7IC8vIFNldHRpbmdzIGFyZSBsb2FkZWQgYW5kIHRoZSBwbHVnaW4gY2FuIGJlIHVzZWQuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0Ly8gVXBkYXRlIHNldHRpbmdzIHZlcnNpb24gaW4gY2FzZSBpdCdzIG9sZC5cclxuXHRcdHRoaXMuc2V0dGluZ3Muc2V0dGluZ3NfdmVyc2lvbiA9IFNDX1BsdWdpbi5TZXR0aW5nc1ZlcnNpb247XHJcblxyXG5cdFx0Ly8gV3JpdGUgc2V0dGluZ3NcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGxvYWRDdXN0b21BdXRvY29tcGxldGVMaXN0KCkge1xyXG5cdFx0Y29uc3QgY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX25hbWUgPSBcImF1dG9jb21wbGV0ZS55YW1sXCI7XHJcblx0XHRjb25zdCBjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfcGF0aCA9IHBhdGguam9pbihnZXRQbHVnaW5BYnNvbHV0ZVBhdGgodGhpcyksIGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9uYW1lKTtcclxuXHJcblx0XHRpZiAoZnMuZXhpc3RzU3luYyhjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfcGF0aCkpIHtcclxuXHRcdFx0ZGVidWdMb2coXCJsb2FkQ3VzdG9tQXV0b2NvbXBsZXRlTGlzdCgpOiBcIiArIGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9uYW1lICsgXCIgZXhpc3RzLCB3aWxsIGxvYWQgaXQgbm93LlwiKTtcclxuXHRcdFx0Y29uc3QgY3VzdG9tX2F1dG9jb21wbGV0ZV9jb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGN1c3RvbV9hdXRvY29tcGxldGVfZmlsZV9wYXRoKS50b0xvY2FsZVN0cmluZygpO1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSBhZGRDdXN0b21BdXRvY29tcGxldGVJdGVtcyhjdXN0b21fYXV0b2NvbXBsZXRlX2NvbnRlbnQpXHJcblx0XHRcdGlmICh0cnVlID09PSByZXN1bHQpIHtcclxuXHRcdFx0XHQvLyBPS1xyXG5cdFx0XHRcdGRlYnVnTG9nKFwibG9hZEN1c3RvbUF1dG9jb21wbGV0ZUxpc3QoKTogXCIgKyBjdXN0b21fYXV0b2NvbXBsZXRlX2ZpbGVfbmFtZSArIFwiIGxvYWRlZC5cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gQW4gZXJyb3IgaGFzIG9jY3VycmVkLlxyXG5cdFx0XHRcdGRlYnVnTG9nKFwibG9hZEN1c3RvbUF1dG9jb21wbGV0ZUxpc3QoKTogXCIgKyByZXN1bHQpO1xyXG5cdFx0XHRcdHRoaXMubmV3RXJyb3IoXCJTaGVsbCBjb21tYW5kczogVW5hYmxlIHRvIHBhcnNlIFwiICsgY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX25hbWUgKyBcIjogXCIgKyByZXN1bHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZWJ1Z0xvZyhcImxvYWRDdXN0b21BdXRvY29tcGxldGVMaXN0KCk6IFwiICsgY3VzdG9tX2F1dG9jb21wbGV0ZV9maWxlX25hbWUgKyBcIiBkb2VzIG5vdCBleGlzdHMsIHNvIHdvbid0IGxvYWQgaXQuIFRoaXMgaXMgcGVyZmVjdGx5IG9rLlwiKTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGRpc2FibGVQbHVnaW4oKSB7XHJcblx0XHQvLyBUaGlzIHVuZm9ydHVuYXRlbHkgYWNjZXNzZXMgYSBwcml2YXRlIEFQSS5cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdGF3YWl0IHRoaXMuYXBwLnBsdWdpbnMuZGlzYWJsZVBsdWdpbih0aGlzLm1hbmlmZXN0LmlkKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEByZXR1cm4gc3RyaW5nIFJldHVybnMgXCIwXCIgaWYgdGhlcmUgYXJlIG5vIHNoZWxsIGNvbW1hbmRzIHlldCwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIG1heCBJRCArIDEsIGFzIGEgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgZ2VuZXJhdGVOZXdTaGVsbENvbW1hbmRJRCgpIHtcclxuXHRcdGNvbnN0IGV4aXN0aW5nX2lkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuZ2V0VFNoZWxsQ29tbWFuZHMoKSk7XHJcblx0XHRsZXQgbmV3X2lkID0gMDtcclxuXHRcdGZvciAoY29uc3QgaSBpbiBleGlzdGluZ19pZHMpIHtcclxuXHRcdFx0Y29uc3QgZXhpc3RpbmdfaWQgPSBwYXJzZUludChleGlzdGluZ19pZHNbaV0pO1xyXG5cdFx0XHRpZiAoZXhpc3RpbmdfaWQgPj0gbmV3X2lkKSB7XHJcblx0XHRcdFx0bmV3X2lkID0gZXhpc3RpbmdfaWQgKyAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gU3RyaW5nKG5ld19pZCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0UGx1Z2luSWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYW5pZmVzdC5pZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRQbHVnaW5OYW1lKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFuaWZlc3QubmFtZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBuZXdFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcclxuXHRcdG5ldyBOb3RpY2UobWVzc2FnZSwgdGhpcy5zZXR0aW5ncy5lcnJvcl9tZXNzYWdlX2R1cmF0aW9uICogMTAwMCk7IC8vICogMTAwMCA9IGNvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHMuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbmV3RXJyb3JzKG1lc3NhZ2VzOiBzdHJpbmdbXSkge1xyXG5cdFx0bWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcblx0XHRcdHRoaXMubmV3RXJyb3IobWVzc2FnZSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBuZXdOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nKSB7XHJcblx0XHRuZXcgTm90aWNlKG1lc3NhZ2UsIHRoaXMuc2V0dGluZ3Mubm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb24gKiAxMDAwKTsgLy8gKiAxMDAwID0gY29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kcy5cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXREZWZhdWx0U2hlbGwoKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IG9wZXJhdGluZ19zeXN0ZW0gPSBnZXRPcGVyYXRpbmdTeXN0ZW0oKTtcclxuXHRcdGxldCBzaGVsbF9uYW1lID0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0X3NoZWxsc1tvcGVyYXRpbmdfc3lzdGVtXTsgLy8gQ2FuIGFsc28gYmUgdW5kZWZpbmVkLlxyXG5cdFx0aWYgKHVuZGVmaW5lZCA9PT0gc2hlbGxfbmFtZSkge1xyXG5cdFx0XHRzaGVsbF9uYW1lID0gZ2V0VXNlcnNEZWZhdWx0U2hlbGwoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzaGVsbF9uYW1lO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJGaWxlU3lzdGVtQWRhcHRlciIsInBhdGgiLCJwbGF0Zm9ybSIsIk1hcmtkb3duVmlldyIsIm5vcm1hbGl6ZVBhdGgiLCJzaGVsbCIsImZzIiwiU2V0dGluZyIsIkVPTCIsImNsaXBib2FyZCIsIk1vZGFsIiwiTm90aWNlIiwibW9tZW50IiwiZ2V0QWxsVGFncyIsIlRGb2xkZXIiLCJURmlsZSIsInRoaXMiLCJwYXJzZVlhbWwiLCJzZXRJY29uIiwiUGxhdGZvcm0iLCJQbHVnaW5TZXR0aW5nVGFiIiwiUGx1Z2luIiwiZXhlYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
