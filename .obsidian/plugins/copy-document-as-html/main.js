/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyDocumentAsHTMLPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
function allWithProgress(promises, callback) {
  let count = 0;
  callback(0);
  for (const promise of promises) {
    promise.then(() => {
      count++;
      callback(count * 100 / promises.length);
    });
  }
  return Promise.all(promises);
}
async function delay(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
var DEFAULT_STYLESHEET = `body,input {
  font-family: "Roboto","Helvetica Neue",Helvetica,Arial,sans-serif
}

code, kbd, pre {
  font-family: "Roboto Mono", "Courier New", Courier, monospace;
  background-color: #f5f5f5;
}

pre {
  padding: 1em 0.5em;
}

table {
  background: white;
  border: 1px solid #666;
  border-collapse: collapse;
  padding: 0.5em;
}

table thead th,
table tfoot th {
  text-align: left;
  background-color: #eaeaea;
  color: black;
}

table th, table td {
  border: 1px solid #ddd;
  padding: 0.5em;
}

table td {
  color: #222222;
}

.callout[data-callout="abstract"] .callout-title,
.callout[data-callout="summary"] .callout-title,
.callout[data-callout="tldr"]  .callout-title,
.callout[data-callout="faq"] .callout-title,
.callout[data-callout="info"] .callout-title,
.callout[data-callout="help"] .callout-title {
  background-color: #828ee7;
}
.callout[data-callout="tip"] .callout-title,
.callout[data-callout="hint"] .callout-title,
.callout[data-callout="important"] .callout-title {
  background-color: #34bbe6;
}
.callout[data-callout="success"] .callout-title,
.callout[data-callout="check"] .callout-title,
.callout[data-callout="done"] .callout-title {
  background-color: #a3e048;
}
.callout[data-callout="question"] .callout-title,
.callout[data-callout="todo"] .callout-title {
  background-color: #49da9a;
}
.callout[data-callout="caution"] .callout-title,
.callout[data-callout="attention"] .callout-title {
  background-color: #f7d038;
}
.callout[data-callout="warning"] .callout-title,
.callout[data-callout="missing"] .callout-title,
.callout[data-callout="bug"] .callout-title {
  background-color: #eb7532;
}
.callout[data-callout="failure"] .callout-title,
.callout[data-callout="fail"] .callout-title,
.callout[data-callout="danger"] .callout-title,
.callout[data-callout="error"] .callout-title {
  background-color: #e6261f;
}
.callout[data-callout="example"] .callout-title {
  background-color: #d23be7;
}
.callout[data-callout="quote"] .callout-title,
.callout[data-callout="cite"] .callout-title {
  background-color: #aaaaaa;
}

.callout-icon {
  flex: 0 0 auto;
  display: flex;
  align-self: center;
}

svg.svg-icon {
  height: 18px;
  width: 18px;
  stroke-width: 1.75px;
}

.callout {
  overflow: hidden;
  margin: 1em 0;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.callout-title {
  padding: .5em;
  display: flex;
  gap: 8px;
  font-size: inherit;
  color: black;
  line-height: 1.3em;
}

.callout-title-inner {
  font-weight: bold;
  color: black;
}

.callout-content {
  overflow-x: auto;
  padding: 0.25em .5em;
  color: #222222;
  background-color: white !important;
}

ul.contains-task-list {
  padding-left: 0;
  list-style: none;
}

ul.contains-task-list ul.contains-task-list {
  padding-left: 2em;
}

ul.contains-task-list li input[type="checkbox"] {
  margin-right: .5em;
}

.callout-table,
.callout-table tr,
.callout-table p {
  width: 100%;
  padding: 0;
}

.callout-table td {
  width: 100%;
  padding: 0 1em;
}

.callout-table p {
  padding-bottom: 0.5em;
}

.source-table {
  width: 100%;
  background-color: #f5f5f5;
}
`;
var MERMAID_STYLESHEET = `
:root {
  --default-font: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --font-monospace: 'Source Code Pro', monospace;
  --background-primary: #ffffff;
  --background-modifier-border: #ddd;
  --text-accent: #705dcf;
  --text-accent-hover: #7a6ae6;
  --text-normal: #2e3338;
  --background-secondary: #f2f3f5;
  --background-secondary-alt: #e3e5e8;
  --text-muted: #888888;
  --font-mermaid: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --text-error: #E4374B;
  --background-primary-alt: '#fafafa';
  --background-accent: '';
  --interactive-accent: hsl( 254,  80%, calc( 68% + 2.5%));
  --background-modifier-error: #E4374B;
}
`;
var htmlTemplate = (stylesheet, body, title) => `<html>
<head>
  <title>${title}</title>
  <style>
    ${MERMAID_STYLESHEET}
    ${stylesheet}
  </style>
</head>
<body>
${body}
</body>
</html>`;
var copyIsRunning = false;
var ppIsProcessing = false;
var ppLastBlockDate = Date.now();
var documentRendererDefaults = {
  convertSvgToBitmap: true,
  removeFrontMatter: true,
  formatAsTables: false,
  embedExternalLinks: false
};
var DocumentRenderer = class {
  constructor(view, app, options = documentRendererDefaults) {
    this.view = view;
    this.app = app;
    this.options = options;
    this.optionRenderSettlingDelay = 100;
    this.mimeMap = /* @__PURE__ */ new Map([
      ["svg", "image/svg+xml"],
      ["jpg", "image/jpeg"]
    ]);
    this.imageExtensions = ["gif", "png", "jpg", "jpeg", "bmp", "png", "webp", "tiff", "svg"];
    this.externalSchemes = ["http", "https"];
    this.vaultPath = this.app.vault.getRoot().vault.adapter.getBasePath().replace(/\\/g, "/");
    this.vaultUriPrefix = `app://local/${this.vaultPath}`;
  }
  async renderDocument() {
    this.modal = new CopyingToHtmlModal(this.app);
    this.modal.open();
    try {
      const topNode = await this.renderMarkdown();
      return await this.transformHTML(topNode);
    } finally {
      this.modal.close();
    }
  }
  async renderMarkdown() {
    const inputFile = this.view.file;
    const markdown = this.view.data;
    const wrapper = document.createElement("div");
    wrapper.style.display = "hidden";
    document.body.appendChild(wrapper);
    await import_obsidian.MarkdownRenderer.renderMarkdown(markdown, wrapper, inputFile.path, this.view);
    await this.untilRendered();
    await this.replaceEmbeds(wrapper);
    const result = wrapper.cloneNode(true);
    document.body.removeChild(wrapper);
    return result;
  }
  async untilRendered() {
    while (ppIsProcessing || Date.now() - ppLastBlockDate < this.optionRenderSettlingDelay) {
      if (ppLastBlockDate === 0) {
        break;
      }
      await delay(20);
    }
  }
  async replaceEmbeds(rootNode) {
    for (const node of Array.from(rootNode.querySelectorAll(".internal-embed"))) {
      const src = node.getAttr("src");
      const alt = node.getAttr("alt");
      if (!src) {
        node.remove();
        continue;
      }
      const extension = this.getExtension(src);
      if (extension === "" || extension === "md") {
        const file = this.getEmbeddedFile(src);
        if (file) {
          const markdown = await this.app.vault.cachedRead(file);
          await import_obsidian.MarkdownRenderer.renderMarkdown(markdown, node, file.path, this.view);
        }
      } else if (this.imageExtensions.includes(extension)) {
        const file = this.getEmbeddedFile(src);
        if (file) {
          const replacement = document.createElement("img");
          replacement.setAttribute("src", `${this.vaultUriPrefix}/${file.path}`);
          if (alt) {
            replacement.setAttribute("alt", alt);
          }
          node.replaceWith(replacement);
        }
      } else {
        node.remove();
      }
    }
  }
  getEmbeddedFile(src) {
    const subfolder = src.substring(this.vaultPath.length);
    const file = this.app.metadataCache.getFirstLinkpathDest(src, subfolder);
    if (!file) {
      console.error(`Could not load ${src}, not found in metadataCache`);
      return void 0;
    }
    if (!(file instanceof import_obsidian.TFile)) {
      console.error(`Embedded element '${src}' is not a file`);
      return void 0;
    }
    return file;
  }
  async transformHTML(element) {
    const node = element.cloneNode(true);
    node.removeAttribute("style");
    if (this.options.removeFrontMatter) {
      this.removeFrontMatter(node);
    }
    this.makeCheckboxesReadOnly(node);
    this.removeCollapseIndicators(node);
    this.removeButtons(node);
    if (this.options.formatAsTables) {
      this.transformCodeToTables(node);
      this.transformCalloutsToTables(node);
    }
    await this.embedImages(node);
    await this.renderSvg(node);
    return node;
  }
  removeFrontMatter(node) {
    node.querySelectorAll(".frontmatter, .frontmatter-container").forEach((node2) => node2.remove());
  }
  makeCheckboxesReadOnly(node) {
    node.querySelectorAll('input[type="checkbox"]').forEach((node2) => node2.setAttribute("disabled", "disabled"));
  }
  removeCollapseIndicators(node) {
    node.querySelectorAll(".collapse-indicator").forEach((node2) => node2.remove());
  }
  removeButtons(node) {
    node.querySelectorAll("button").forEach((node2) => node2.remove());
  }
  transformCodeToTables(node) {
    node.querySelectorAll("pre").forEach((node2) => {
      const codeEl = node2.querySelector("code");
      if (codeEl) {
        const code = codeEl.innerHTML.replace(/\n*$/, "");
        const table = node2.parentElement.createEl("table");
        table.className = "source-table";
        table.innerHTML = `<tr><td><pre>${code}</pre></td></tr>`;
        node2.parentElement.replaceChild(table, node2);
      }
    });
  }
  transformCalloutsToTables(node) {
    node.querySelectorAll(".callout").forEach((node2) => {
      var _a;
      const callout = node2.parentElement.createEl("table");
      callout.addClass("callout-table", "callout");
      callout.setAttribute("data-callout", (_a = node2.getAttribute("data-callout")) != null ? _a : "quote");
      const headRow = callout.createEl("tr");
      const headColumn = headRow.createEl("td");
      headColumn.addClass("callout-title");
      const title = node2.querySelector(".callout-title-inner");
      if (title) {
        const span = headColumn.createEl("span");
        span.innerHTML = title.innerHTML;
      }
      const originalContent = node2.querySelector(".callout-content");
      if (originalContent) {
        const row = callout.createEl("tr");
        const column = row.createEl("td");
        column.innerHTML = originalContent.innerHTML;
      }
      node2.remove();
    });
  }
  async embedImages(node) {
    const promises = [];
    node.querySelectorAll("img").forEach((img) => {
      if (img.src) {
        if (img.src.startsWith("data:image/svg+xml") && this.options.convertSvgToBitmap) {
          promises.push(this.replaceImageSource(img));
          return;
        }
        if (!this.options.embedExternalLinks) {
          const [scheme] = img.src.split(":", 1);
          if (this.externalSchemes.includes(scheme.toLowerCase())) {
            return;
          } else {
          }
        }
        if (!img.src.startsWith("data:")) {
          promises.push(this.replaceImageSource(img));
          return;
        }
      }
    });
    this.modal.progress.max = 100;
    await allWithProgress(promises, (percentCompleted) => this.modal.progress.value = percentCompleted);
    return node;
  }
  async renderSvg(node) {
    const xmlSerializer = new XMLSerializer();
    if (!this.options.convertSvgToBitmap) {
      return node;
    }
    const promises = [];
    const replaceSvg = async (svg) => {
      let style = svg.querySelector("style") || svg.appendChild(document.createElement("style"));
      style.innerHTML += MERMAID_STYLESHEET;
      const svgAsString = xmlSerializer.serializeToString(svg);
      const svgData = `data:image/svg+xml;base64,` + Buffer.from(svgAsString).toString("base64");
      const dataUri = await this.imageToDataUri(svgData);
      const img = svg.createEl("img");
      img.style.cssText = svg.style.cssText;
      img.src = dataUri;
      svg.parentElement.replaceChild(img, svg);
    };
    node.querySelectorAll("svg").forEach((svg) => {
      promises.push(replaceSvg(svg));
    });
    this.modal.progress.max = 0;
    await allWithProgress(promises, (percentCompleted) => this.modal.progress.value = percentCompleted);
    return node;
  }
  async replaceImageSource(image) {
    const imageSourcePath = decodeURI(image.src);
    if (imageSourcePath.startsWith(this.vaultUriPrefix)) {
      let path = imageSourcePath.substring(this.vaultUriPrefix.length + 1).replace(/[?#].*/, "");
      path = decodeURI(path);
      const mimeType = this.guessMimeType(path);
      const data = await this.readFromVault(path, mimeType);
      if (this.isSvg(mimeType) && this.options.convertSvgToBitmap) {
        image.src = await this.imageToDataUri(data);
      } else {
        image.src = data;
      }
    } else {
      image.src = await this.imageToDataUri(image.src);
    }
  }
  async imageToDataUri(url) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.setAttribute("crossOrigin", "anonymous");
    const dataUriPromise = new Promise((resolve, reject) => {
      image.onload = () => {
        canvas.width = image.naturalWidth;
        canvas.height = image.naturalHeight;
        ctx.drawImage(image, 0, 0);
        try {
          const uri = canvas.toDataURL("image/png");
          resolve(uri);
        } catch (err) {
          console.log(`failed ${url}`, err);
          resolve(url);
        }
        canvas.remove();
      };
      image.onerror = (err) => {
        console.log("could not load data uri");
        resolve(url);
      };
    });
    image.src = url;
    return dataUriPromise;
  }
  async readFromVault(path, mimeType) {
    const tfile = this.app.vault.getAbstractFileByPath(path);
    const data = await this.app.vault.readBinary(tfile);
    return `data:${mimeType};base64,` + (0, import_obsidian.arrayBufferToBase64)(data);
  }
  guessMimeType(filePath) {
    const extension = this.getExtension(filePath) || "png";
    return this.mimeMap.get(extension) || `image/${extension}`;
  }
  getExtension(filePath) {
    const fileName = filePath.slice(filePath.lastIndexOf("/") + 1);
    return fileName.slice(fileName.lastIndexOf(".") + 1 || fileName.length).toLowerCase();
  }
  isSvg(mimeType) {
    return mimeType === "image/svg+xml";
  }
};
var CopyingToHtmlModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  get progress() {
    return this._progress;
  }
  onOpen() {
    let { titleEl, contentEl } = this;
    titleEl.setText("Copying to clipboard");
    this._progress = contentEl.createEl("progress");
    this._progress.style.width = "100%";
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var CopyDocumentAsHTMLSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Copy document as HTML - Settings" });
    new import_obsidian.Setting(containerEl).setName("Remove front-matter sections").setDesc("If checked, the YAML content between --- lines at the front of the document are removed. If you don't know what this means, leave it on.").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeFrontMatter).onChange(async (value) => {
      this.plugin.settings.removeFrontMatter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Convert SVG files to bitmap").setDesc("If checked, SVG files are converted to bitmap. This makes the copied documents heavier but improves compatibility (eg. with gmail).").addToggle((toggle) => toggle.setValue(this.plugin.settings.convertSvgToBitmap).onChange(async (value) => {
      this.plugin.settings.convertSvgToBitmap = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Embed external images").setDesc("If checked, external images are downloaded and embedded. If unchecked, the resulting document may contain links to external resources").addToggle((toggle) => toggle.setValue(this.plugin.settings.embedExternalLinks).onChange(async (value) => {
      this.plugin.settings.embedExternalLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Render some elements as tables").setDesc("If checked code blocks and callouts are rendered as tables, which makes pasting into Google docs somewhat prettier.").addToggle((toggle) => toggle.setValue(this.plugin.settings.formatAsTables).onChange(async (value) => {
      this.plugin.settings.formatAsTables = value;
      await this.plugin.saveSettings();
    }));
    const useCustomStylesheetSetting = new import_obsidian.Setting(containerEl).setName("Provide a custom stylesheet").setDesc("The default stylesheet provides minimalistic theming. You may want to customize it for better looks.");
    const customStylesheetSetting = new import_obsidian.Setting(containerEl).setName("Custom stylesheet").setDesc("Disabling the setting above will replace the custom stylesheet with the default.").setClass("custom-css-setting").addTextArea((textArea) => textArea.setValue(this.plugin.settings.styleSheet).onChange(async (value) => {
      this.plugin.settings.styleSheet = value;
      await this.plugin.saveSettings();
    }));
    useCustomStylesheetSetting.addToggle((toggle) => {
      customStylesheetSetting.settingEl.toggle(this.plugin.settings.useCustomStylesheet);
      toggle.setValue(this.plugin.settings.useCustomStylesheet).onChange(async (value) => {
        this.plugin.settings.useCustomStylesheet = value;
        customStylesheetSetting.settingEl.toggle(this.plugin.settings.useCustomStylesheet);
        if (!value) {
          this.plugin.settings.styleSheet = DEFAULT_STYLESHEET;
        }
        await this.plugin.saveSettings();
      });
    });
  }
};
var DEFAULT_SETTINGS = {
  removeFrontMatter: true,
  convertSvgToBitmap: true,
  useCustomStylesheet: false,
  embedExternalLinks: false,
  formatAsTables: false,
  styleSheet: DEFAULT_STYLESHEET
};
var CopyDocumentAsHTMLPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "copy-as-html",
      name: "Copy current document to clipboard",
      checkCallback: (checking) => {
        if (copyIsRunning) {
          console.log("Document is already being copied");
          return false;
        }
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (!activeView) {
          console.log("Nothing to copy: No active markdown view");
          return false;
        }
        if (!checking) {
          this.doCopy(activeView);
        }
        return true;
      }
    });
    const beforeAllPostProcessor = this.registerMarkdownPostProcessor(async () => {
      ppIsProcessing = true;
    });
    beforeAllPostProcessor.sortOrder = -1e4;
    const afterAllPostProcessor = this.registerMarkdownPostProcessor(async () => {
      ppLastBlockDate = Date.now();
      ppIsProcessing = false;
    });
    afterAllPostProcessor.sortOrder = 1e4;
    this.addSettingTab(new CopyDocumentAsHTMLSettingsTab(this.app, this));
    this.setupEditorMenuEntry();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.useCustomStylesheet) {
      this.settings.styleSheet = DEFAULT_STYLESHEET;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async doCopy(activeView) {
    console.log(`Copying "${activeView.file.path}" to clipboard...`);
    const copier = new DocumentRenderer(activeView, this.app, this.settings);
    try {
      copyIsRunning = true;
      ppLastBlockDate = Date.now();
      ppIsProcessing = true;
      const htmlBody = await copier.renderDocument();
      const htmlDocument = htmlTemplate(this.settings.styleSheet, htmlBody.outerHTML, activeView.file.name);
      const data = new ClipboardItem({
        "text/html": new Blob([htmlDocument], {
          type: ["text/html", "text/plain"]
        }),
        "text/plain": new Blob([htmlDocument], {
          type: "text/plain"
        })
      });
      await navigator.clipboard.write([data]);
      console.log("Copied document to clipboard");
      new import_obsidian.Notice("document copied to clipboard");
    } catch (error) {
      new import_obsidian.Notice(`copy failed: ${error}`);
      console.error("copy failed", error);
    } finally {
      copyIsRunning = false;
    }
  }
  setupEditorMenuEntry() {
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, view) => {
      menu.addItem((item) => {
        item.setTitle("Copy as HTML").setIcon("clipboard-copy").onClick(async () => {
          this.app.commands.executeCommandById("copy-document-as-html:copy-as-html");
        });
      });
    }));
  }
};
