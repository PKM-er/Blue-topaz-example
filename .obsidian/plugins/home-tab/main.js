/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/font-list/libs/darwin/index.js
var require_darwin = __commonJS({
  "node_modules/font-list/libs/darwin/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var execFile = require("child_process").execFile;
    var bin = path.join(__dirname, "fontlist");
    var font_exceptions = ["iconfont"];
    function tryToGetFonts(s) {
      let fonts = [];
      let m = s.match(/\(([\s\S]+)\)/);
      if (m) {
        fonts = m[1].split("\n").map((i) => i.trim()).map((i) => i.replace(/,$/, ""));
      }
      return fonts;
    }
    module2.exports = () => new Promise((resolve, reject) => {
      execFile(bin, { maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
        if (error) {
          reject(error);
          return;
        }
        let fonts = [];
        if (stdout) {
          fonts = fonts.concat(tryToGetFonts(stdout));
        }
        if (stderr) {
          fonts = fonts.concat(tryToGetFonts(stderr));
        }
        fonts = Array.from(new Set(fonts)).filter((i) => i && !font_exceptions.includes(i));
        resolve(fonts);
      });
    });
  }
});

// node_modules/font-list/libs/win32/getByPowerShell.js
var require_getByPowerShell = __commonJS({
  "node_modules/font-list/libs/win32/getByPowerShell.js"(exports, module2) {
    var exec = require("child_process").exec;
    var parse2 = (str) => {
      return str.split("\n").map((ln) => ln.trim()).filter((f) => !!f);
    };
    module2.exports = () => new Promise((resolve, reject) => {
      let cmd = `chcp 65001|powershell -command "chcp 65001|Out-Null;Add-Type -AssemblyName PresentationCore;$families=[Windows.Media.Fonts]::SystemFontFamilies;foreach($family in $families){$name='';if(!$family.FamilyNames.TryGetValue([Windows.Markup.XmlLanguage]::GetLanguage('zh-cn'),[ref]$name)){$name=$family.FamilyNames[[Windows.Markup.XmlLanguage]::GetLanguage('en-us')]}echo $name}"`;
      exec(cmd, { maxBuffer: 1024 * 1024 * 10 }, (err, stdout) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(parse2(stdout));
      });
    });
  }
});

// node_modules/font-list/libs/win32/getByVBS.js
var require_getByVBS = __commonJS({
  "node_modules/font-list/libs/win32/getByVBS.js"(exports, module2) {
    var os = require("os");
    var fs = require("fs");
    var path = require("path");
    var execFile = require("child_process").execFile;
    var util = require("util");
    var p_copyFile = util.promisify(fs.copyFile);
    function tryToGetFonts(s) {
      let a = s.split("\n");
      if (a[0].includes("Microsoft")) {
        a.splice(0, 3);
      }
      a = a.map((i) => {
        i = i.split("	")[0].split(path.sep);
        i = i[i.length - 1];
        if (!i.match(/^[\w\s]+$/)) {
          i = "";
        }
        i = i.replace(/^\s+|\s+$/g, "").replace(/(Regular|常规)$/i, "").replace(/^\s+|\s+$/g, "");
        return i;
      });
      return a.filter((i) => i);
    }
    async function writeToTmpDir(fn2) {
      let tmp_fn = path.join(os.tmpdir(), "node-font-list-fonts.vbs");
      await p_copyFile(fn2, tmp_fn);
      return tmp_fn;
    }
    module2.exports = async () => {
      let fn2 = path.join(__dirname, "fonts.vbs");
      const is_in_asar = fn2.includes("app.asar");
      if (is_in_asar) {
        fn2 = await writeToTmpDir(fn2);
      }
      return new Promise((resolve, reject) => {
        let cmd = `cscript`;
        execFile(cmd, [fn2], { maxBuffer: 1024 * 1024 * 10 }, (err, stdout, stderr) => {
          let fonts = [];
          if (err) {
            reject(err);
            return;
          }
          if (stdout) {
            fonts = fonts.concat(tryToGetFonts(stdout));
          }
          if (stderr) {
            fonts = fonts.concat(tryToGetFonts(stderr));
          }
          resolve(fonts);
        });
      });
    };
  }
});

// node_modules/font-list/libs/win32/index.js
var require_win32 = __commonJS({
  "node_modules/font-list/libs/win32/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var getByPowerShell = require_getByPowerShell();
    var getByVBS = require_getByVBS();
    var methods_new = [getByPowerShell, getByVBS];
    var methods_old = [getByVBS, getByPowerShell];
    module2.exports = async () => {
      let fonts = [];
      let os_v = parseInt(os.release());
      let methods = os_v >= 10 ? methods_new : methods_old;
      for (let method of methods) {
        try {
          fonts = await method();
          if (fonts.length > 0)
            break;
        } catch (e) {
          console.log(e);
        }
      }
      return fonts;
    };
  }
});

// node_modules/font-list/libs/linux/index.js
var require_linux = __commonJS({
  "node_modules/font-list/libs/linux/index.js"(exports, module2) {
    var exec = require("child_process").exec;
    var util = require("util");
    var pexec = util.promisify(exec);
    async function binaryExists(binary) {
      const { stdout } = await pexec(`whereis ${binary}`);
      return stdout.length > binary.length + 2;
    }
    module2.exports = async () => {
      const fcListBinary = await binaryExists("fc-list") ? "fc-list" : "fc-list2";
      const cmd = fcListBinary + ' -f "%{family[0]}\\n"';
      const { stdout } = await pexec(cmd, { maxBuffer: 1024 * 1024 * 10 });
      const fonts = stdout.split("\n").filter((f) => !!f);
      return Array.from(new Set(fonts));
    };
  }
});

// node_modules/font-list/index.js
var require_font_list = __commonJS({
  "node_modules/font-list/index.js"(exports) {
    "use strict";
    var platform = void 0;
    try {
      platform = process.platform;
    } catch (e) {
    }
    var getFontsFunc;
    switch (platform) {
      case "darwin":
        getFontsFunc = require_darwin();
        break;
      case "win32":
        getFontsFunc = require_win32();
        break;
      case "linux":
        getFontsFunc = require_linux();
        break;
      default:
    }
    var defaultOptions = {
      disableQuoting: false
    };
    exports.getFonts = async (options) => {
      options = Object.assign({}, defaultOptions, options);
      let fonts = await getFontsFunc();
      fonts = fonts.map((i) => {
        try {
          i = i.replace(/\\u([\da-f]{4})/ig, (m, s) => String.fromCharCode(parseInt(s, 16)));
        } catch (e) {
          console.log(e);
        }
        if (options && options.disableQuoting) {
          if (i.startsWith('"') && i.endsWith('"')) {
            i = `${i.substr(1, i.length - 2)}`;
          }
        } else if (i.includes(" ") && !i.startsWith('"')) {
          i = `"${i}"`;
        }
        return i;
      });
      fonts.sort((a, b) => {
        return a.replace(/^['"]+/, "").toLocaleLowerCase() < b.replace(/^['"]+/, "").toLocaleLowerCase() ? -1 : 1;
      });
      return fonts;
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HomeTab
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/homeView.ts
var import_obsidian11 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn2) {
  return function(event) {
    event.preventDefault();
    return fn2.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash4 = 5381;
  let i = str.length;
  while (i--)
    hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i);
  return hash4 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn2, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn2(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn2(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn2, params, intro) {
  let config = fn2(node, params);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config();
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block4, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block4(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance15, create_fragment15, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance15 ? instance15(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment15 ? create_fragment15($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/searchBar.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1v6c0q", ".home-tab-searchbar-container.svelte-1v6c0q.svelte-1v6c0q{display:flex;align-items:center;flex-direction:column}.home-tab-searchbar.svelte-1v6c0q.svelte-1v6c0q{display:flex;min-width:250px;max-width:700px;margin:0 auto;height:calc(var(--input-height)*1.25);background-color:var(--background-modifier-form-field);border:var(--input-border-width) solid var(--background-modifier-border);padding:var(--size-2-3);border-radius:var(--input-radius);outline:none}.home-tab-searchbar.svelte-1v6c0q input.svelte-1v6c0q{width:100%;height:100%;box-shadow:none;font-size:var(--font-ui-medium);background:none;border:none;padding-left:12px}.home-tab-searchbar.svelte-1v6c0q input.svelte-1v6c0q:hover{background:none;border:none}.home-tab-suggestion-file-tag.hide.svelte-1v6c0q.svelte-1v6c0q{display:none}");
}
function create_fragment(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let input;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "PNG";
      t1 = space();
      input = element("input");
      attr(div0, "class", "nav-file-tag home-tab-suggestion-file-tag hide svelte-1v6c0q");
      attr(input, "type", "search");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(input, "class", "svelte-1v6c0q");
      attr(div1, "class", "home-tab-searchbar svelte-1v6c0q");
      toggle_class(div1, "embedded", ctx[0]);
      set_style(div1, "width", ctx[0] || ctx[7] ? "90%" : "50%", false);
      attr(div2, "class", "home-tab-searchbar-container svelte-1v6c0q");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      ctx[9](div0);
      append(div1, t1);
      append(div1, input);
      ctx[10](input);
      ctx[11](div2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(div1, "embedded", ctx2[0]);
      }
      if (dirty & 1) {
        set_style(div1, "width", ctx2[0] || ctx2[7] ? "90%" : "50%", false);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      ctx[9](null);
      ctx[10](null);
      ctx[11](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $container;
  let $activeExtEl;
  let $searchBarEl;
  let { HomeTabSearchBar: HomeTabSearchBar2 } = $$props;
  let { embedded = false } = $$props;
  const searchBarEl = HomeTabSearchBar2.searchBarEl;
  component_subscribe($$self, searchBarEl, (value) => $$invalidate(3, $searchBarEl = value));
  const activeExtEl = HomeTabSearchBar2.activeExtEl;
  component_subscribe($$self, activeExtEl, (value) => $$invalidate(2, $activeExtEl = value));
  const container = HomeTabSearchBar2.suggestionContainerEl;
  component_subscribe($$self, container, (value) => $$invalidate(1, $container = value));
  const isPhone = import_obsidian.Platform.isPhone;
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $activeExtEl = $$value;
      activeExtEl.set($activeExtEl);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $searchBarEl = $$value;
      searchBarEl.set($searchBarEl);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $container = $$value;
      container.set($container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("HomeTabSearchBar" in $$props2)
      $$invalidate(8, HomeTabSearchBar2 = $$props2.HomeTabSearchBar);
    if ("embedded" in $$props2)
      $$invalidate(0, embedded = $$props2.embedded);
  };
  return [
    embedded,
    $container,
    $activeExtEl,
    $searchBarEl,
    searchBarEl,
    activeExtEl,
    container,
    isPhone,
    HomeTabSearchBar2,
    div0_binding,
    input_binding,
    div2_binding
  ];
}
var SearchBar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { HomeTabSearchBar: 8, embedded: 0 }, add_css);
  }
};
var searchBar_default = SearchBar;

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/store.ts
var pluginSettingsStore = writable();
var starredFiles = writable();
var recentFiles = writable([]);

// src/ui/homepage.svelte
var import_obsidian9 = require("obsidian");

// src/ui/starredFiles.svelte
var import_obsidian7 = require("obsidian");

// src/iconSelectionModal.ts
var import_obsidian5 = require("obsidian");

// src/suggester/suggester.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/easing/index.mjs
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function quintOut(t) {
  return --t * t * t * t * t + 1;
}

// node_modules/svelte/transition/index.mjs
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}

// src/ui/suggesterView.svelte
function add_css2(target) {
  append_styles(target, "svelte-mdftrq", ".scrollable.svelte-mdftrq{overflow-y:auto}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[13] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_style_value;
  let t;
  let div1_class_value;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block = ctx[1].additionalModalInfo && create_if_block_1(ctx);
  return {
    c() {
      var _a, _b, _c, _d;
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", div0_class_value = ((_a = ctx[1].suggestionClass) != null ? _a : "suggestion") + " " + ((_b = ctx[1].additionalClasses) != null ? _b : "") + " svelte-mdftrq");
      attr(div0, "style", div0_style_value = (_c = ctx[1].style) != null ? _c : "");
      toggle_class(div0, "scrollable", ctx[1].isScrollable);
      attr(div1, "class", div1_class_value = null_to_empty((_d = ctx[1].containerClass) != null ? _d : "suggestion-container") + " svelte-mdftrq");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      ctx[10](div0);
      append(div1, t);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "mousedown", mousedown_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a, _b, _c, _d;
      ctx = new_ctx;
      if (dirty & 31) {
        each_value = ctx[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 2 && div0_class_value !== (div0_class_value = ((_a = ctx[1].suggestionClass) != null ? _a : "suggestion") + " " + ((_b = ctx[1].additionalClasses) != null ? _b : "") + " svelte-mdftrq")) {
        attr(div0, "class", div0_class_value);
      }
      if (!current || dirty & 2 && div0_style_value !== (div0_style_value = (_c = ctx[1].style) != null ? _c : "")) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty & 2) {
        toggle_class(div0, "scrollable", ctx[1].isScrollable);
      }
      if (ctx[1].additionalModalInfo) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 2 && div1_class_value !== (div1_class_value = null_to_empty((_d = ctx[1].containerClass) != null ? _d : "suggestion-container") + " svelte-mdftrq")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, slide, { duration: 200, easing: quintOut }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, slide, { duration: 200, easing: quintOut }, false);
      div1_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      ctx[10](null);
      if (if_block)
        if_block.d();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1(ctx) {
  let html_tag;
  let raw_value = ctx[14].outerHTML + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 12 && raw_value !== (raw_value = ctx2[14].outerHTML + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2].generateDisplayElementContent(ctx[11]);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  function mousemove_handler() {
    return ctx[7](ctx[13]);
  }
  return {
    c() {
      var _a;
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", div_class_value = null_to_empty((_a = ctx[1].suggestionItemClass) != null ? _a : "suggestion-item mod-complex") + " svelte-mdftrq");
      toggle_class(div, "is-selected", ctx[4] === ctx[13]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "mousemove", mousemove_handler),
          listen(div, "click", ctx[8]),
          listen(div, "auxclick", ctx[9])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty & 12) {
        each_value_1 = ctx[2].generateDisplayElementContent(ctx[11]);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 2 && div_class_value !== (div_class_value = null_to_empty((_a = ctx[1].suggestionItemClass) != null ? _a : "suggestion-item mod-complex") + " svelte-mdftrq")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 18) {
        toggle_class(div, "is-selected", ctx[4] === ctx[13]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let raw_value = ctx[1].additionalModalInfo.outerHTML + "";
  return {
    c() {
      div = element("div");
      attr(div, "class", "suggester-additional-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && raw_value !== (raw_value = ctx2[1].additionalModalInfo.outerHTML + ""))
        div.innerHTML = raw_value;
      ;
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[3] && ctx[3].length > 0 && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[3] && ctx2[3].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
var mousedown_handler = (e) => e.preventDefault();
function instance2($$self, $$props, $$invalidate) {
  let $suggestionWrapper;
  let { suggester } = $$props;
  let { options } = $$props;
  let { textInputSuggester } = $$props;
  let suggestions;
  suggester.suggestionsStore.subscribe((value) => $$invalidate(3, suggestions = value));
  let selectedItemIndex;
  suggester.selectedItemIndexStore.subscribe((value) => $$invalidate(4, selectedItemIndex = value));
  const suggestionWrapper = suggester.suggestionsContainer;
  component_subscribe($$self, suggestionWrapper, (value) => $$invalidate(5, $suggestionWrapper = value));
  const mousemove_handler = (index) => suggester.setSelectedItemIndex(index);
  const click_handler = () => textInputSuggester.useSelectedItem(suggester.getSelectedItem());
  const auxclick_handler = (e) => {
    if (e.button === 1) {
      textInputSuggester.useSelectedItem(suggester.getSelectedItem(), true);
    }
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $suggestionWrapper = $$value;
      suggestionWrapper.set($suggestionWrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("suggester" in $$props2)
      $$invalidate(0, suggester = $$props2.suggester);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("textInputSuggester" in $$props2)
      $$invalidate(2, textInputSuggester = $$props2.textInputSuggester);
  };
  return [
    suggester,
    options,
    textInputSuggester,
    suggestions,
    selectedItemIndex,
    $suggestionWrapper,
    suggestionWrapper,
    mousemove_handler,
    click_handler,
    auxclick_handler,
    div0_binding
  ];
}
var SuggesterView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      suggester: 0,
      options: 1,
      textInputSuggester: 2
    }, add_css2);
  }
};
var suggesterView_default = SuggesterView;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance15 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance15.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance15.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance15.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance15.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance15 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance15.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance15
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance15.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance15;
    }
    instance15.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance15,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance15;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggester/suggester.ts
var Suggester = class {
  constructor(ISuggester, scope) {
    this.ISuggster = ISuggester;
    this.suggestionsStore = writable();
    this.selectedItemIndexStore = writable();
    this.suggestionsContainer = writable();
    this.selectedItemIndexStore.subscribe((value) => this.selectedItemIndex = value);
    this.suggestionsStore.subscribe((value) => this.suggestions = value);
    this.setSuggestions([]);
    this.setSelectedItemIndex(0);
    scope.register([], "ArrowUp", (e) => {
      e.preventDefault();
      this.setSelectedItemIndex(this.selectedItemIndex - 1);
      this.ISuggster.scrollSelectedItemIntoView();
    });
    scope.register([], "ArrowDown", (e) => {
      e.preventDefault();
      this.setSelectedItemIndex(this.selectedItemIndex + 1);
      this.ISuggster.scrollSelectedItemIntoView();
    });
    scope.register([], "Enter", (e) => {
      e.preventDefault();
      this.ISuggster.useSelectedItem(this.getSelectedItem());
    });
  }
  setSuggestions(suggestions) {
    this.selectedItemIndexStore.set(0);
    this.suggestionsStore.set(suggestions);
  }
  getSuggestions() {
    return this.suggestions;
  }
  getSelectedItem() {
    return this.suggestions[this.selectedItemIndex];
  }
  getSelectedItemIndex() {
    return this.selectedItemIndex;
  }
  getSuggestionByIndex(index) {
    return this.suggestions[index];
  }
  setSelectedItemIndex(newIndex) {
    if (newIndex >= this.suggestions.length) {
      this.selectedItemIndexStore.set(0);
    } else if (newIndex < 0) {
      this.selectedItemIndexStore.set(this.suggestions.length - 1);
    } else {
      this.selectedItemIndexStore.set(newIndex);
    }
  }
};
var TextInputSuggester = class {
  additionalCleaning() {
  }
  onOpen() {
  }
  onClose() {
  }
  constructor(app2, inputEl, suggestionParentContainer, viewOptions, searchDelay) {
    this.app = app2;
    this.inputEl = inputEl;
    this.scope = new import_obsidian2.Scope(this.app.scope);
    this.suggester = new Suggester(this, this.scope);
    this.inputEl.addEventListener("input", searchDelay ? (0, import_obsidian2.debounce)(() => this.onInput(), searchDelay, false) : this.onInput.bind(this));
    this.inputEl.addEventListener("focus", searchDelay ? (0, import_obsidian2.debounce)(() => this.onInput(), searchDelay, false) : this.onInput.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.scope.register([], "escape", this.close.bind(this));
    this.viewOptions = viewOptions != null ? viewOptions : {};
    this.suggestionParentContainer = suggestionParentContainer;
    this.closingAnimationRunning = false;
  }
  onInput() {
    const input = this.inputEl.value;
    const suggestions = this.getSuggestions(input);
    if (suggestions.length > 0) {
      this.suggester.setSuggestions(suggestions);
      this.open();
    } else if (suggestions.length === 0) {
      this.onNoSuggestion();
    }
  }
  onNoSuggestion() {
    this.close();
  }
  getContainerEl() {
    return this.suggestionParentContainer;
  }
  open() {
    if (this.closingAnimationRunning)
      this.abortClosingAnimation();
    if (this.suggesterView)
      return;
    this.suggestionContainer = this.getContainerEl();
    this.app.keymap.pushScope(this.scope);
    this.suggesterView = new suggesterView_default({
      target: this.suggestionContainer,
      props: {
        textInputSuggester: this,
        suggester: this.suggester,
        options: this.viewOptions
      },
      intro: true
    });
    this.onOpen();
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggester.setSuggestions([]);
    if (this.suggesterView) {
      this.closingAnimationRunning = true;
      this.closingAnimationTimeout = setTimeout(() => {
        var _a;
        (_a = this.suggesterView) == null ? void 0 : _a.$destroy();
        this.suggesterView = void 0;
        this.closingAnimationRunning = false;
      }, 200);
    }
    this.additionalCleaning();
    this.onClose();
  }
  abortClosingAnimation() {
    var _a;
    clearTimeout(this.closingAnimationTimeout);
    (_a = this.suggesterView) == null ? void 0 : _a.$destroy();
    this.suggesterView = void 0;
    this.closingAnimationRunning = false;
  }
  scrollSelectedItemIntoView() {
    var _a, _b;
    (_b = get_store_value(this.suggester.suggestionsContainer).getElementsByClassName((_a = this.viewOptions.suggestionItemClass) != null ? _a : "suggestion-item")[this.suggester.getSelectedItemIndex()]) == null ? void 0 : _b.scrollIntoView({ behavior: "auto", block: "nearest", inline: "nearest" });
  }
};
var PopoverTextInputSuggester = class extends TextInputSuggester {
  constructor(app2, inputEl, viewOptions) {
    super(app2, inputEl, app2.dom.appContainerEl, viewOptions);
  }
  getContainerEl() {
    if (document.contains(this.popperWrapper))
      return this.popperWrapper;
    this.popperWrapper = this.suggestionParentContainer.createDiv("popper-wrapper");
    this.popperWrapper.style.zIndex = "var(--layer-menu)";
    const isPhone = import_obsidian2.Platform.isPhone;
    const popperReference = isPhone ? document.body : this.inputEl;
    if (isPhone) {
      this.popperWrapper.style.width = "100%";
    }
    this.popperInstance = createPopper(popperReference, this.popperWrapper, {
      placement: "bottom-start",
      modifiers: [{
        name: "offset",
        options: {
          offset: [0, 5]
        }
      }]
    });
    return this.popperWrapper;
  }
  additionalCleaning() {
    if (this.popperInstance) {
      this.popperInstance.destroy();
    }
    if (document.body.contains(this.popperWrapper)) {
      this.popperWrapper.detach();
    }
  }
};

// node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end2 = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start2 === -1) {
      start2 = i;
    } else if (!match && start2 !== -1) {
      end2 = i - 1;
      if (end2 - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end2]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
    indices.push([start2, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end2 = len - remainder;
      while (i < end2) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto: auto2 = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/utils/getFilesUtils.ts
var import_obsidian3 = require("obsidian");

// src/utils/getFileTypeUtils.ts
var fileTypeLookupTable = {
  image: ["jpg", "jpeg", "png", "svg", "gif", "bmp"],
  video: ["mp4", "webm", "ogv", "mov", "mkv"],
  audio: ["mp3", "wav", "m4a", "ogg", "3gp", "flac"],
  markdown: ["md"],
  pdf: ["pdf"]
};
function getFileTypeFromExtension(extension) {
  for (const fileType of Object.keys(fileTypeLookupTable)) {
    if (fileTypeLookupTable[fileType].includes(extension)) {
      return fileType;
    }
  }
  return void 0;
}
function getExtensionFromFilename(filename) {
  const extension = filename.match(/\.([^.]+$)./g);
  if (extension) {
    return extension[0].substring(1);
  }
  return void 0;
}
function isValidExtension(extToCheck) {
  const extensions = [
    "jpg",
    "jpeg",
    "png",
    "svg",
    "gif",
    "bmp",
    "mp4",
    "webm",
    "ogv",
    "mov",
    "mkv",
    "mp3",
    "wav",
    "m4a",
    "ogg",
    "3gp",
    "flac",
    "md",
    "pdf"
  ];
  return extensions.includes(extToCheck);
}
function isValidFileType(typeToCheck) {
  const fileTypes = ["image", "video", "audio", "markdown", "pdf"];
  return fileTypes.includes(typeToCheck);
}

// src/utils/getFilesUtils.ts
function getImageFiles() {
  let fileList = [];
  app.vault.getFiles().forEach((file) => {
    if (getFileTypeFromExtension(file.extension) === "image") {
      fileList.push(file);
    }
  });
  return fileList;
}
function getFileAliases(file) {
  var _a, _b, _c;
  let aliases = [];
  const rawAliases = ((_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) ? (_c = (_b = app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter) == null ? void 0 : _c.aliases : void 0;
  if (rawAliases instanceof Array) {
    aliases.push(...rawAliases);
  } else if (typeof rawAliases === "string") {
    rawAliases.replace("[", "").replace("]", "").split(",").forEach((alias) => {
      if (alias.length > 0) {
        aliases.push(alias.trim());
      }
    });
  }
  return aliases;
}
function generateSearchFile(file) {
  return {
    name: file.name,
    basename: file.basename,
    path: file.path,
    aliases: getFileAliases(file),
    isCreated: true,
    file,
    fileType: getFileTypeFromExtension(file.extension),
    extension: file.extension
  };
}
function getUnresolvedLinkPath(cachedFilename, newFilePath) {
  const normalizedFilename = (0, import_obsidian3.getLinkpath)(cachedFilename);
  if (newFilePath && !normalizedFilename.includes("/")) {
    return (0, import_obsidian3.normalizePath)(`${this.app.fileManager.getNewFileParent("").path}/${normalizedFilename}`);
  }
  return (0, import_obsidian3.normalizePath)(normalizedFilename);
}
function getUnresolvedLinkBasename(cachedFilename) {
  const normalizedPath = (0, import_obsidian3.getLinkpath)(cachedFilename);
  if (normalizedPath.includes("/")) {
    const regexResult = normalizedPath.match(/.*\/(.*)/);
    return regexResult ? regexResult[1] : normalizedPath;
  }
  return normalizedPath;
}
function generateMarkdownUnresolvedFile(cachedFilename) {
  const filename = getExtensionFromFilename(cachedFilename) ? cachedFilename.replace(".md", "") : cachedFilename;
  return {
    name: `${getUnresolvedLinkBasename(filename)}.md`,
    basename: getUnresolvedLinkBasename(filename),
    path: getUnresolvedLinkPath(`${filename}.md`, true),
    isCreated: false,
    isUnresolved: true,
    fileType: "markdown",
    extension: "md"
  };
}
function getUnresolvedMarkdownFiles() {
  const fileList = [];
  const unresolvedLinkParents = app.metadataCache.unresolvedLinks;
  const unresolvedFilenames = [];
  Object.entries(unresolvedLinkParents).forEach((record) => {
    Object.keys(record[1]).forEach((filename) => {
      if (!getExtensionFromFilename(filename) && !unresolvedFilenames.includes(filename)) {
        unresolvedFilenames.push(filename);
      }
    });
  });
  unresolvedFilenames.forEach((filename) => fileList.push(generateMarkdownUnresolvedFile(filename)));
  return fileList;
}
function getSearchFiles(unresolvedLinks) {
  const files = app.vault.getFiles();
  const fileList = [];
  files.forEach((f) => {
    fileList.push(generateSearchFile(f));
  });
  if (unresolvedLinks) {
    fileList.push(...getUnresolvedMarkdownFiles());
  }
  return fileList;
}
function getParentFolderFromPath(filepath) {
  const regexResult = filepath.match(/.*\/([^\/]+)\//);
  return regexResult ? regexResult[1] : "/";
}

// src/suggester/fuzzySearch.ts
var DEFAULT_FUSE_OPTIONS = {
  includeScore: true,
  fieldNormWeight: 1.35,
  threshold: 0.2,
  distance: 125,
  useExtendedSearch: true
};
var fuzzySearch = class {
  constructor(searchArray, searchOptions = DEFAULT_FUSE_OPTIONS) {
    this.fuse = new Fuse(searchArray, searchOptions);
  }
  rawSearch(querry, limit) {
    return this.fuse.search(querry, limit ? { limit } : void 0);
  }
  filteredSearch(querry, scoreThreshold = 0.25, maxResults = 5) {
    return this.rawSearch(querry, maxResults).filter((item) => item.score ? item.score < scoreThreshold : true);
  }
  updateSearchArray(newSearchArray) {
    this.fuse.setCollection(newSearchArray);
  }
};
var ArrayFuzzySearch = class extends fuzzySearch {
  constructor(searchArray, searchOptions) {
    super(searchArray, searchOptions);
  }
};
var FileFuzzySearch = class extends fuzzySearch {
  constructor(fileList, searchOptions) {
    const searchArray = fileList;
    super(searchArray, searchOptions);
  }
  getBestMatch(searchResultElement, querry) {
    const searchFile = searchResultElement.item;
    if (!searchFile.aliases)
      return searchFile.basename;
    const searchArray = [];
    searchArray.push(searchFile.basename);
    searchFile.aliases.forEach((alias) => searchArray.push(alias));
    const fuzzySearch2 = new ArrayFuzzySearch(searchArray);
    const bestMatch = fuzzySearch2.rawSearch(querry, 1)[0];
    return bestMatch ? bestMatch.item : searchFile.basename;
  }
};
var ImageFileFuzzySearch = class extends fuzzySearch {
  constructor(imageList, searchOptions) {
    const searchArray = imageList != null ? imageList : getImageFiles();
    super(searchArray, searchOptions);
  }
};

// src/utils/lucideIcons.ts
var lucideIcons = [
  "accessibility",
  "activity",
  "air-vent",
  "airplay",
  "alarm-check",
  "alarm-clock-off",
  "alarm-clock",
  "alarm-minus",
  "alarm-plus",
  "album",
  "alert-circle",
  "alert-octagon",
  "alert-triangle",
  "align-center-horizontal",
  "align-center-vertical",
  "align-center",
  "align-end-horizontal",
  "align-end-vertical",
  "align-horizontal-distribute-center",
  "align-horizontal-distribute-end",
  "align-horizontal-distribute-start",
  "align-horizontal-justify-center",
  "align-horizontal-justify-end",
  "align-horizontal-justify-start",
  "align-horizontal-space-around",
  "align-horizontal-space-between",
  "align-justify",
  "align-left",
  "align-right",
  "align-start-horizontal",
  "align-start-vertical",
  "align-vertical-distribute-center",
  "align-vertical-distribute-end",
  "align-vertical-distribute-start",
  "align-vertical-justify-center",
  "align-vertical-justify-end",
  "align-vertical-justify-start",
  "align-vertical-space-around",
  "align-vertical-space-between",
  "anchor",
  "angry",
  "annoyed",
  "aperture",
  "apple",
  "archive-restore",
  "archive",
  "armchair",
  "arrow-big-down",
  "arrow-big-left",
  "arrow-big-right",
  "arrow-big-up",
  "arrow-down-circle",
  "arrow-down-left",
  "arrow-down-right",
  "arrow-down",
  "arrow-left-circle",
  "arrow-left-right",
  "arrow-left",
  "arrow-right-circle",
  "arrow-right",
  "arrow-up-circle",
  "arrow-up-down",
  "arrow-up-left",
  "arrow-up-right",
  "arrow-up",
  "asterisk",
  "at-sign",
  "award",
  "axe",
  "axis-3d",
  "baby",
  "backpack",
  "baggage-claim",
  "banana",
  "banknote",
  "bar-chart-2",
  "bar-chart-3",
  "bar-chart-4",
  "bar-chart-horizontal",
  "bar-chart",
  "baseline",
  "bath",
  "battery-charging",
  "battery-full",
  "battery-low",
  "battery-medium",
  "battery",
  "beaker",
  "bed-double",
  "bed-single",
  "bed",
  "beer",
  "bell-minus",
  "bell-off",
  "bell-plus",
  "bell-ring",
  "bell",
  "bike",
  "binary",
  "bitcoin",
  "bluetooth-connected",
  "bluetooth-off",
  "bluetooth-searching",
  "bluetooth",
  "bold",
  "bomb",
  "bone",
  "book-open-check",
  "book-open",
  "book",
  "bookmark-minus",
  "bookmark-plus",
  "bookmark",
  "bot",
  "box-select",
  "box",
  "boxes",
  "briefcase",
  "brush",
  "bug",
  "building-2",
  "building",
  "bus",
  "cake",
  "calculator",
  "calendar-check-2",
  "calendar-check",
  "calendar-clock",
  "calendar-days",
  "calendar-heart",
  "calendar-minus",
  "calendar-off",
  "calendar-plus",
  "calendar-range",
  "calendar-search",
  "calendar-x-2",
  "calendar-x",
  "calendar",
  "camera-off",
  "camera",
  "car",
  "carrot",
  "cast",
  "check-circle-2",
  "check-circle",
  "check-square",
  "check",
  "chef-hat",
  "cherry",
  "chevron-down",
  "chevron-first",
  "chevron-last",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-down-up",
  "chevrons-down",
  "chevrons-left-right",
  "chevrons-left",
  "chevrons-right-left",
  "chevrons-right",
  "chevrons-up-down",
  "chevrons-up",
  "chrome",
  "cigarette-off",
  "cigarette",
  "circle-dot",
  "circle-ellipsis",
  "circle-slashed",
  "circle",
  "citrus",
  "clapperboard",
  "clipboard-check",
  "clipboard-copy",
  "clipboard-edit",
  "clipboard-list",
  "clipboard-signature",
  "clipboard-type",
  "clipboard-x",
  "clipboard",
  "clock-1",
  "clock-10",
  "clock-11",
  "clock-12",
  "clock-2",
  "clock-3",
  "clock-4",
  "clock-5",
  "clock-6",
  "clock-7",
  "clock-8",
  "clock-9",
  "clock",
  "cloud-cog",
  "cloud-drizzle",
  "cloud-fog",
  "cloud-hail",
  "cloud-lightning",
  "cloud-moon-rain",
  "cloud-moon",
  "cloud-off",
  "cloud-rain-wind",
  "cloud-rain",
  "cloud-snow",
  "cloud-sun-rain",
  "cloud-sun",
  "cloud",
  "cloudy",
  "clover",
  "code-2",
  "code",
  "codepen",
  "codesandbox",
  "coffee",
  "cog",
  "coins",
  "columns",
  "command",
  "compass",
  "component",
  "concierge-bell",
  "contact",
  "contrast",
  "cookie",
  "copy",
  "copyleft",
  "copyright",
  "corner-down-left",
  "corner-down-right",
  "corner-left-down",
  "corner-left-up",
  "corner-right-down",
  "corner-right-up",
  "corner-up-left",
  "corner-up-right",
  "cpu",
  "credit-card",
  "croissant",
  "crop",
  "cross",
  "crosshair",
  "crown",
  "cup-soda",
  "curly-braces",
  "currency",
  "database",
  "delete",
  "diamond",
  "dice-1",
  "dice-2",
  "dice-3",
  "dice-4",
  "dice-5",
  "dice-6",
  "dices",
  "diff",
  "disc",
  "divide-circle",
  "divide-square",
  "divide",
  "dollar-sign",
  "download-cloud",
  "download",
  "dribbble",
  "droplet",
  "droplets",
  "drumstick",
  "edit-2",
  "edit-3",
  "edit",
  "egg-fried",
  "egg",
  "equal-not",
  "equal",
  "eraser",
  "euro",
  "expand",
  "external-link",
  "eye-off",
  "eye",
  "facebook",
  "factory",
  "fan",
  "fast-forward",
  "feather",
  "figma",
  "file-archive",
  "file-audio-2",
  "file-audio",
  "file-axis-3d",
  "file-badge-2",
  "file-badge",
  "file-bar-chart-2",
  "file-bar-chart",
  "file-box",
  "file-check-2",
  "file-check",
  "file-clock",
  "file-code",
  "file-cog-2",
  "file-cog",
  "file-diff",
  "file-digit",
  "file-down",
  "file-edit",
  "file-heart",
  "file-image",
  "file-input",
  "file-json-2",
  "file-json",
  "file-key-2",
  "file-key",
  "file-line-chart",
  "file-lock-2",
  "file-lock",
  "file-minus-2",
  "file-minus",
  "file-output",
  "file-pie-chart",
  "file-plus-2",
  "file-plus",
  "file-question",
  "file-scan",
  "file-search-2",
  "file-search",
  "file-signature",
  "file-spreadsheet",
  "file-symlink",
  "file-terminal",
  "file-text",
  "file-type-2",
  "file-type",
  "file-up",
  "file-video-2",
  "file-video",
  "file-volume-2",
  "file-volume",
  "file-warning",
  "file-x-2",
  "file-x",
  "file",
  "files",
  "film",
  "filter",
  "fingerprint",
  "flag-off",
  "flag-triangle-left",
  "flag-triangle-right",
  "flag",
  "flame",
  "flashlight-off",
  "flashlight",
  "flask-conical",
  "flask-round",
  "flip-horizontal-2",
  "flip-horizontal",
  "flip-vertical-2",
  "flip-vertical",
  "flower-2",
  "flower",
  "focus",
  "folder-archive",
  "folder-check",
  "folder-clock",
  "folder-closed",
  "folder-cog-2",
  "folder-cog",
  "folder-down",
  "folder-edit",
  "folder-heart",
  "folder-input",
  "folder-key",
  "folder-lock",
  "folder-minus",
  "folder-open",
  "folder-output",
  "folder-plus",
  "folder-search-2",
  "folder-search",
  "folder-symlink",
  "folder-tree",
  "folder-up",
  "folder-x",
  "folder",
  "folders",
  "form-input",
  "forward",
  "frame",
  "framer",
  "frown",
  "fuel",
  "function-square",
  "gamepad-2",
  "gamepad",
  "gauge",
  "gavel",
  "gem",
  "ghost",
  "gift",
  "git-branch-plus",
  "git-branch",
  "git-commit",
  "git-compare",
  "git-fork",
  "git-merge",
  "git-pull-request-closed",
  "git-pull-request-draft",
  "git-pull-request",
  "github",
  "gitlab",
  "glass-water",
  "glasses",
  "globe-2",
  "globe",
  "grab",
  "graduation-cap",
  "grape",
  "grid",
  "grip-horizontal",
  "grip-vertical",
  "hammer",
  "hand-metal",
  "hand",
  "hard-drive",
  "hard-hat",
  "hash",
  "haze",
  "headphones",
  "heart-crack",
  "heart-handshake",
  "heart-off",
  "heart-pulse",
  "heart",
  "help-circle",
  "hexagon",
  "highlighter",
  "history",
  "home",
  "hourglass",
  "ice-cream",
  "image-minus",
  "image-off",
  "image-plus",
  "image",
  "import",
  "inbox",
  "indent",
  "indian-rupee",
  "infinity",
  "info",
  "inspect",
  "instagram",
  "italic",
  "japanese-yen",
  "joystick",
  "key",
  "keyboard",
  "lamp-ceiling",
  "lamp-desk",
  "lamp-floor",
  "lamp-wall-down",
  "lamp-wall-up",
  "lamp",
  "landmark",
  "languages",
  "laptop-2",
  "laptop",
  "lasso-select",
  "lasso",
  "laugh",
  "layers",
  "layout-dashboard",
  "layout-grid",
  "layout-list",
  "layout-template",
  "layout",
  "leaf",
  "library",
  "life-buoy",
  "lightbulb-off",
  "lightbulb",
  "line-chart",
  "link-2-off",
  "link-2",
  "link",
  "linkedin",
  "list-checks",
  "list-end",
  "list-minus",
  "list-music",
  "list-ordered",
  "list-plus",
  "list-start",
  "list-video",
  "list-x",
  "list",
  "loader-2",
  "loader",
  "locate-fixed",
  "locate-off",
  "locate",
  "lock",
  "log-in",
  "log-out",
  "luggage",
  "magnet",
  "mail-check",
  "mail-minus",
  "mail-open",
  "mail-plus",
  "mail-question",
  "mail-search",
  "mail-warning",
  "mail-x",
  "mail",
  "mails",
  "map-pin-off",
  "map-pin",
  "map",
  "martini",
  "maximize-2",
  "maximize",
  "medal",
  "megaphone-off",
  "megaphone",
  "meh",
  "menu",
  "message-circle",
  "message-square",
  "mic-2",
  "mic-off",
  "mic",
  "microscope",
  "microwave",
  "milestone",
  "minimize-2",
  "minimize",
  "minus-circle",
  "minus-square",
  "minus",
  "monitor-off",
  "monitor-speaker",
  "monitor",
  "moon",
  "more-horizontal",
  "more-vertical",
  "mountain-snow",
  "mountain",
  "mouse-pointer-2",
  "mouse-pointer-click",
  "mouse-pointer",
  "mouse",
  "move-3d",
  "move-diagonal-2",
  "move-diagonal",
  "move-horizontal",
  "move-vertical",
  "move",
  "music-2",
  "music-3",
  "music-4",
  "music",
  "navigation-2-off",
  "navigation-2",
  "navigation-off",
  "navigation",
  "network",
  "newspaper",
  "octagon",
  "option",
  "outdent",
  "package-2",
  "package-check",
  "package-minus",
  "package-open",
  "package-plus",
  "package-search",
  "package-x",
  "package",
  "paint-bucket",
  "paintbrush-2",
  "paintbrush",
  "palette",
  "palmtree",
  "paperclip",
  "party-popper",
  "pause-circle",
  "pause-octagon",
  "pause",
  "pen-tool",
  "pencil",
  "percent",
  "person-standing",
  "phone-call",
  "phone-forwarded",
  "phone-incoming",
  "phone-missed",
  "phone-off",
  "phone-outgoing",
  "phone",
  "pie-chart",
  "piggy-bank",
  "pin-off",
  "pin",
  "pipette",
  "pizza",
  "plane",
  "play-circle",
  "play",
  "plug-2",
  "plug-zap",
  "plug",
  "plus-circle",
  "plus-square",
  "plus",
  "pocket",
  "podcast",
  "pointer",
  "pound-sterling",
  "power-off",
  "power",
  "printer",
  "puzzle",
  "qr-code",
  "quote",
  "radio-receiver",
  "radio",
  "rectangle-horizontal",
  "rectangle-vertical",
  "recycle",
  "redo-2",
  "redo",
  "refresh-ccw",
  "refresh-cw",
  "refrigerator",
  "regex",
  "repeat-1",
  "repeat",
  "reply-all",
  "reply",
  "rewind",
  "rocket",
  "rocking-chair",
  "rotate-3d",
  "rotate-ccw",
  "rotate-cw",
  "rss",
  "ruler",
  "russian-ruble",
  "sailboat",
  "save",
  "scale-3d",
  "scale",
  "scaling",
  "scan-face",
  "scan-line",
  "scan",
  "scissors",
  "screen-share-off",
  "screen-share",
  "scroll",
  "search",
  "send",
  "separator-horizontal",
  "separator-vertical",
  "server-cog",
  "server-crash",
  "server-off",
  "server",
  "settings-2",
  "settings",
  "share-2",
  "share",
  "sheet",
  "shield-alert",
  "shield-check",
  "shield-close",
  "shield-off",
  "shield",
  "shirt",
  "shopping-bag",
  "shopping-cart",
  "shovel",
  "shower-head",
  "shrink",
  "shrub",
  "shuffle",
  "sidebar-close",
  "sidebar-open",
  "sidebar",
  "sigma",
  "signal-high",
  "signal-low",
  "signal-medium",
  "signal-zero",
  "signal",
  "siren",
  "skip-back",
  "skip-forward",
  "skull",
  "slack",
  "slash",
  "slice",
  "sliders-horizontal",
  "sliders",
  "smartphone-charging",
  "smartphone",
  "smile-plus",
  "smile",
  "snowflake",
  "sofa",
  "sort-asc",
  "sort-desc",
  "speaker",
  "sprout",
  "square",
  "star-half",
  "star-off",
  "star",
  "stethoscope",
  "sticker",
  "sticky-note",
  "stop-circle",
  "stretch-horizontal",
  "stretch-vertical",
  "strikethrough",
  "subscript",
  "sun-dim",
  "sun-medium",
  "sun-moon",
  "sun-snow",
  "sun",
  "sunrise",
  "sunset",
  "superscript",
  "swiss-franc",
  "switch-camera",
  "sword",
  "swords",
  "syringe",
  "table-2",
  "table",
  "tablet",
  "tag",
  "tags",
  "target",
  "tent",
  "terminal-square",
  "terminal",
  "text-cursor-input",
  "text-cursor",
  "thermometer-snowflake",
  "thermometer-sun",
  "thermometer",
  "thumbs-down",
  "thumbs-up",
  "ticket",
  "timer-off",
  "timer-reset",
  "timer",
  "toggle-left",
  "toggle-right",
  "tornado",
  "toy-brick",
  "train",
  "trash-2",
  "trash",
  "tree-deciduous",
  "tree-pine",
  "trees",
  "trello",
  "trending-down",
  "trending-up",
  "triangle",
  "trophy",
  "truck",
  "tv-2",
  "tv",
  "twitch",
  "twitter",
  "type",
  "umbrella",
  "underline",
  "undo-2",
  "undo",
  "unlink-2",
  "unlink",
  "unlock",
  "upload-cloud",
  "upload",
  "usb",
  "user-check",
  "user-cog",
  "user-minus",
  "user-plus",
  "user-x",
  "user",
  "users",
  "utensils-crossed",
  "utensils",
  "venetian-mask",
  "verified",
  "vibrate-off",
  "vibrate",
  "video-off",
  "video",
  "view",
  "voicemail",
  "volume-1",
  "volume-2",
  "volume-x",
  "volume",
  "wallet",
  "wand-2",
  "wand",
  "watch",
  "waves",
  "webcam",
  "webhook",
  "wifi-off",
  "wifi",
  "wind",
  "wine",
  "wrap-text",
  "wrench",
  "x-circle",
  "x-octagon",
  "x-square",
  "x",
  "youtube",
  "zap-off",
  "zap",
  "zoom-in",
  "zoom-out"
];

// src/utils/htmlUtils.ts
var import_obsidian4 = require("obsidian");
function getLucideIcon(iconId, options) {
  var _a, _b, _c;
  if (!lucideIcons.includes(iconId))
    return null;
  const iconEl = (0, import_obsidian4.getIcon)(iconId);
  if (iconEl) {
    const size = (_a = options == null ? void 0 : options.size) != null ? _a : 24;
    iconEl.ariaLabel = (_b = options == null ? void 0 : options.ariaLabel) != null ? _b : "";
    if (size != 24 || (options == null ? void 0 : options.strokeWidth) != 2) {
      iconEl.hasClass("svg-icon") ? iconEl.removeClass("svg-icon") : null;
    }
    (options == null ? void 0 : options.class) ? iconEl.addClass(options.class) : null;
    iconEl.setAttribute("width", size.toString());
    iconEl.setAttribute("height", size.toString());
    iconEl.setAttribute("stroke-width", ((_c = options == null ? void 0 : options.strokeWidth) != null ? _c : 2).toString());
    return iconEl;
  }
  return null;
}
function addLucideIcon(parentElement, iconId, options) {
  const icon = getLucideIcon(iconId, options);
  if (icon)
    parentElement.appendChild(icon);
}
function generateHotkeySuggestion(hotkeySuggestions, containerClass) {
  const hotkeySuggestionElement = createDiv(containerClass);
  hotkeySuggestions.forEach((hotkeySuggestion) => {
    const suggestionElement = hotkeySuggestionElement.createDiv("prompt-instruction");
    suggestionElement.createEl("span", { text: hotkeySuggestion.hotkey }).addClass("prompt-instruction-command");
    suggestionElement.createEl("span", { text: hotkeySuggestion.action });
  });
  return hotkeySuggestionElement;
}

// src/suggester/iconSuggester.ts
var iconSuggester = class extends PopoverTextInputSuggester {
  constructor(app2, inputEl, viewOptions, displayIcon) {
    super(app2, inputEl, viewOptions);
    this.iconList = [...lucideIcons];
    this.fuzzySearch = new ArrayFuzzySearch(this.iconList);
    this.displayIcon = displayIcon;
  }
  getSuggestions(input) {
    return this.fuzzySearch.filteredSearch(input, 0.25, 15);
  }
  useSelectedItem(selectedItem) {
    this.inputEl.value = selectedItem.item;
    this.inputEl.trigger("input");
    this.close();
  }
  generateDisplayElementContent(suggestion) {
    const suggestionContentEl = createDiv("suggestion-content");
    const suggestionTitleEl = suggestionContentEl.createDiv("suggestion-title");
    suggestionTitleEl.appendText(suggestion.item);
    const suggestionAuxEl = createDiv("suggestion-aux");
    if (this.displayIcon) {
      const iconContainerEl = suggestionAuxEl.createSpan();
      iconContainerEl.addClass("suggestion-flair");
      addLucideIcon(iconContainerEl, suggestion.item, {
        size: 20
      });
    }
    return [suggestionContentEl, suggestionAuxEl];
  }
};

// src/iconSelectionModal.ts
var IconSelectionModal = class extends import_obsidian5.Modal {
  constructor(app2, defaultIcon, onSubmit) {
    super(app2);
    this.icon = defaultIcon;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Set a custom icon" });
    const iconSetting = new import_obsidian5.Setting(contentEl).setName("Choose an icon").setDesc("Accepts any lucide icon id.");
    let invalidInputIcon;
    iconSetting.addExtraButton((button) => {
      button.setIcon("alert-circle").setTooltip("The path/link/icon is not valid.");
      invalidInputIcon = button.extraSettingsEl;
      invalidInputIcon.toggleVisibility(false);
      invalidInputIcon.addClass("mod-warning");
    });
    iconSetting.addSearch((text2) => {
      var _a, _b;
      new iconSuggester(this.app, text2.inputEl, {
        isScrollable: true,
        style: `max-height: 200px`
      }, true);
      (_b = text2.setPlaceholder("Type to start search...").setValue((_a = this.icon) != null ? _a : "").onChange(async (value) => {
        if (lucideIcons.includes(value)) {
          this.icon = value;
          invalidInputIcon.toggleVisibility(false);
        } else {
          invalidInputIcon.toggleVisibility(true);
        }
      }).inputEl.parentElement) == null ? void 0 : _b.addClass("wide-input-container");
    });
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Close modal").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Set icon").setCta().onClick(() => {
      this.icon ? this.onSubmit(this.icon) : null;
      this.close();
    }));
  }
  onClose() {
    this.icon = void 0;
    let { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/lucide-svelte/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/esm/Icon.svelte
function create_fragment3(ctx) {
  var _a;
  let svg;
  let svg_class_value;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let svg_levels = [
    defaultAttributes_default,
    ctx[4],
    { width: ctx[2] },
    { height: ctx[2] },
    { stroke: ctx[1] },
    { "stroke-width": ctx[3] },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${ctx[0]} ${(_a = ctx[5].class) != null ? _a : ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & 16 && ctx2[4],
        (!current || dirty & 4) && { width: ctx2[2] },
        (!current || dirty & 4) && { height: ctx2[2] },
        (!current || dirty & 2) && { stroke: ctx2[1] },
        (!current || dirty & 8) && { "stroke-width": ctx2[3] },
        (!current || dirty & 33 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${ctx2[0]} ${(_a2 = ctx2[5].class) != null ? _a2 : ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svg);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [name, color, size, strokeWidth, $$restProps, $$props, $$scope, slots];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/esm/icons/file-audio.svelte
function create_default_slot(ctx) {
  let path0;
  let t0;
  let polyline;
  let t1;
  let path1;
  let t2;
  let path2;
  let t3;
  let path3;
  let t4;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path0 = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      path1 = svg_element("path");
      t2 = space();
      path2 = svg_element("path");
      t3 = space();
      path3 = svg_element("path");
      t4 = space();
      if (default_slot)
        default_slot.c();
      attr(path0, "d", "M17.5 22h.5c.5 0 1-.2 1.4-.6.4-.4.6-.9.6-1.4V7.5L14.5 2H6c-.5 0-1 .2-1.4.6C4.2 3 4 3.5 4 4v3");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(path1, "d", "M10 20v-1a2 2 0 1 1 4 0v1a2 2 0 1 1-4 0Z");
      attr(path2, "d", "M6 20v-1a2 2 0 1 0-4 0v1a2 2 0 1 0 4 0Z");
      attr(path3, "d", "M2 19v-3a6 6 0 0 1 12 0v3");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      insert(target, path1, anchor);
      insert(target, t2, anchor);
      insert(target, path2, anchor);
      insert(target, t3, anchor);
      insert(target, path3, anchor);
      insert(target, t4, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(path1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(path2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(path3);
      if (detaching)
        detach(t4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file-audio" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File_audio = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var file_audio_default = File_audio;

// node_modules/lucide-svelte/dist/esm/icons/file-image.svelte
function create_default_slot2(ctx) {
  let path0;
  let t0;
  let polyline;
  let t1;
  let circle;
  let t2;
  let path1;
  let t3;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path0 = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      circle = svg_element("circle");
      t2 = space();
      path1 = svg_element("path");
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(path0, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(circle, "cx", "10");
      attr(circle, "cy", "13");
      attr(circle, "r", "2");
      attr(path1, "d", "m20 17-1.09-1.09a2 2 0 0 0-2.82 0L10 22");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      insert(target, circle, anchor);
      insert(target, t2, anchor);
      insert(target, path1, anchor);
      insert(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(circle);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(path1);
      if (detaching)
        detach(t3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file-image" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File_image = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var file_image_default = File_image;

// node_modules/lucide-svelte/dist/esm/icons/file-pie-chart.svelte
function create_default_slot3(ctx) {
  let path0;
  let t0;
  let polyline;
  let t1;
  let path1;
  let t2;
  let path2;
  let t3;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path0 = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      path1 = svg_element("path");
      t2 = space();
      path2 = svg_element("path");
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(path0, "d", "M16 22h2a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v3");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(path1, "d", "M4.04 11.71a5.84 5.84 0 1 0 8.2 8.29");
      attr(path2, "d", "M13.83 16A5.83 5.83 0 0 0 8 10.17V16h5.83Z");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      insert(target, path1, anchor);
      insert(target, t2, anchor);
      insert(target, path2, anchor);
      insert(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(path1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(path2);
      if (detaching)
        detach(t3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file-pie-chart" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File_pie_chart = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var file_pie_chart_default = File_pie_chart;

// node_modules/lucide-svelte/dist/esm/icons/file-text.svelte
function create_default_slot4(ctx) {
  let path;
  let t0;
  let polyline;
  let t1;
  let line0;
  let t2;
  let line1;
  let t3;
  let line2;
  let t4;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      line0 = svg_element("line");
      t2 = space();
      line1 = svg_element("line");
      t3 = space();
      line2 = svg_element("line");
      t4 = space();
      if (default_slot)
        default_slot.c();
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(line0, "x1", "16");
      attr(line0, "y1", "13");
      attr(line0, "x2", "8");
      attr(line0, "y2", "13");
      attr(line1, "x1", "16");
      attr(line1, "y1", "17");
      attr(line1, "x2", "8");
      attr(line1, "y2", "17");
      attr(line2, "x1", "10");
      attr(line2, "y1", "9");
      attr(line2, "x2", "8");
      attr(line2, "y2", "9");
    },
    m(target, anchor) {
      insert(target, path, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      insert(target, line0, anchor);
      insert(target, t2, anchor);
      insert(target, line1, anchor);
      insert(target, t3, anchor);
      insert(target, line2, anchor);
      insert(target, t4, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(line0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(line1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(line2);
      if (detaching)
        detach(t4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file-text" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File_text = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var file_text_default = File_text;

// node_modules/lucide-svelte/dist/esm/icons/file-video.svelte
function create_default_slot5(ctx) {
  let path0;
  let t0;
  let polyline;
  let t1;
  let path1;
  let t2;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path0 = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      path1 = svg_element("path");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(path0, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(path1, "d", "m10 11 5 3-5 3v-6Z");
    },
    m(target, anchor) {
      insert(target, path0, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      insert(target, path1, anchor);
      insert(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(path1);
      if (detaching)
        detach(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file-video" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File_video = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var file_video_default = File_video;

// node_modules/lucide-svelte/dist/esm/icons/file.svelte
function create_default_slot6(ctx) {
  let path;
  let t0;
  let polyline;
  let t1;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      path = svg_element("path");
      t0 = space();
      polyline = svg_element("polyline");
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
    },
    m(target, anchor) {
      insert(target, path, anchor);
      insert(target, t0, anchor);
      insert(target, polyline, anchor);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(path);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(polyline);
      if (detaching)
        detach(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "file" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var File = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var file_default = File;

// node_modules/lucide-svelte/dist/esm/icons/more-horizontal.svelte
function create_default_slot7(ctx) {
  let circle0;
  let t0;
  let circle1;
  let t1;
  let circle2;
  let t2;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      circle0 = svg_element("circle");
      t0 = space();
      circle1 = svg_element("circle");
      t1 = space();
      circle2 = svg_element("circle");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(circle0, "cx", "12");
      attr(circle0, "cy", "12");
      attr(circle0, "r", "1");
      attr(circle1, "cx", "19");
      attr(circle1, "cy", "12");
      attr(circle1, "r", "1");
      attr(circle2, "cx", "5");
      attr(circle2, "cy", "12");
      attr(circle2, "r", "1");
    },
    m(target, anchor) {
      insert(target, circle0, anchor);
      insert(target, t0, anchor);
      insert(target, circle1, anchor);
      insert(target, t1, anchor);
      insert(target, circle2, anchor);
      insert(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(circle0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(circle1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(circle2);
      if (detaching)
        detach(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [{ name: "more-horizontal" }, ctx[0]];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & 1 ? get_spread_update(icon_spread_levels, [icon_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, slots, $$scope];
}
var More_horizontal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var more_horizontal_default = More_horizontal;

// src/ui/svelteComponents/fileDisplayItem.svelte
var import_obsidian6 = require("obsidian");
var import_console = require("console");
function add_css3(target) {
  append_styles(target, "svelte-nzt2l9", ".home-star-file-item.svelte-nzt2l9{margin:5px;padding:5px;border-radius:var(--radius-m);min-width:75px;max-width:125px;position:relative}.home-star-file-item.svelte-nzt2l9:hover{background-color:var(--background-modifier-hover)}.home-star-file-item.use-accent-color.svelte-nzt2l9:hover{color:white;background:var(--interactive-accent)}.home-tab-file-item-preview-icon.svelte-nzt2l9{display:flex;align-items:center;justify-content:center;padding:var(--size-2-3)}.home-tab-file-item-name.svelte-nzt2l9{text-align:center;font-size:var(--font-ui-small);display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-line-clamp:3;-webkit-box-orient:vertical}.home-tab-file-item-remove_btn.svelte-nzt2l9{opacity:0;position:absolute;top:4px;right:4px}.home-tab-file-item-remove_btn.svelte-nzt2l9:hover{opacity:1}");
}
function create_else_block(ctx) {
  let file_1;
  let current;
  file_1 = new file_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(file_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(file_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(file_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(file_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(file_1, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let filepiechart;
  let current;
  filepiechart = new file_pie_chart_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(filepiechart.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filepiechart, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(filepiechart.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepiechart.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filepiechart, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let fileaudio;
  let current;
  fileaudio = new file_audio_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(fileaudio.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileaudio, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(fileaudio.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileaudio.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileaudio, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let filevideo;
  let current;
  filevideo = new file_video_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(filevideo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filevideo, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(filevideo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filevideo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filevideo, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let fileimage;
  let current;
  fileimage = new file_image_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(fileimage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileimage, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(fileimage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileimage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileimage, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let filetext;
  let current;
  filetext = new file_text_default({ props: { strokeWidth: 1 } });
  return {
    c() {
      create_component(filetext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filetext, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(filetext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filetext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filetext, detaching);
    }
  };
}
function create_if_block2(ctx) {
  var _a;
  let svg;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)(ctx[3], 24)) == null ? void 0 : _a.innerHTML) + "";
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "1");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", svg_class_value = "lucide-icon lucide lucide-" + ctx[3] + " svelte-nzt2l9");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      svg.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 8 && raw_value !== (raw_value = ((_a2 = (0, import_obsidian6.getIcon)(ctx2[3], 24)) == null ? void 0 : _a2.innerHTML) + ""))
        svg.innerHTML = raw_value;
      ;
      if (dirty & 8 && svg_class_value !== (svg_class_value = "lucide-icon lucide lucide-" + ctx2[3] + " svelte-nzt2l9")) {
        attr(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_fragment11(ctx) {
  let div3;
  let div0;
  let morehorizontal;
  let t0;
  let div1;
  let current_block_type_index;
  let if_block;
  let t1;
  let div2;
  let current;
  let mounted;
  let dispose;
  morehorizontal = new more_horizontal_default({
    props: {
      strokeWidth: 1,
      width: 24,
      height: 24,
      class: "svg-icon lucide-x"
    }
  });
  const if_block_creators = [
    create_if_block2,
    create_if_block_12,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_if_block_5,
    create_else_block
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    if (ctx2[5] === "markdown")
      return 1;
    if (ctx2[5] === "image")
      return 2;
    if (ctx2[5] === "video")
      return 3;
    if (ctx2[5] === "audio")
      return 4;
    if (ctx2[5] === "pdf")
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(morehorizontal.$$.fragment);
      t0 = space();
      div1 = element("div");
      if_block.c();
      t1 = space();
      div2 = element("div");
      div2.textContent = `${ctx[4]}`;
      attr(div0, "class", "home-tab-file-item-remove_btn svelte-nzt2l9");
      attr(div0, "aria-label", "File options");
      attr(div1, "class", "home-tab-file-item-preview-icon svelte-nzt2l9");
      attr(div2, "class", "home-tab-file-item-name svelte-nzt2l9");
      attr(div3, "class", "home-star-file-item svelte-nzt2l9");
      toggle_class(div3, "use-accent-color", ctx[1].selectionHighlight === "accentColor");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(morehorizontal, div0, null);
      append(div3, t0);
      append(div3, div1);
      if_blocks[current_block_type_index].m(div1, null);
      append(div3, t1);
      append(div3, div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[9]),
          listen(div3, "mousedown", prevent_default(ctx[10]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      if (!current || dirty & 2) {
        toggle_class(div3, "use-accent-color", ctx2[1].selectionHighlight === "accentColor");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(morehorizontal.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(morehorizontal.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(morehorizontal);
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { app: app2 } = $$props;
  let { file } = $$props;
  let { pluginSettings } = $$props;
  let { contextualMenu } = $$props;
  let { customIcon = void 0 } = $$props;
  const filename = file.basename;
  const fileType = getFileTypeFromExtension(file.extension);
  const dispatch2 = createEventDispatcher();
  function handleFileOpening(file2, newTab) {
    const leaf = app2.workspace.getLeaf(newTab);
    leaf.openFile(file2);
  }
  function handleMouseClick(e, file2) {
    if (e.target.classList.contains("home-tab-file-item-remove_btn"))
      return;
    else if (e.button != 2) {
      handleFileOpening(file2, import_obsidian6.Keymap.isModEvent(e));
    }
  }
  const click_handler = (e) => {
    contextualMenu.showAtMouseEvent(e);
    dispatch2("itemMenu", { file });
  };
  const mousedown_handler2 = (e) => handleMouseClick(e, file);
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(8, app2 = $$props2.app);
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
    if ("pluginSettings" in $$props2)
      $$invalidate(1, pluginSettings = $$props2.pluginSettings);
    if ("contextualMenu" in $$props2)
      $$invalidate(2, contextualMenu = $$props2.contextualMenu);
    if ("customIcon" in $$props2)
      $$invalidate(3, customIcon = $$props2.customIcon);
  };
  return [
    file,
    pluginSettings,
    contextualMenu,
    customIcon,
    filename,
    fileType,
    dispatch2,
    handleMouseClick,
    app2,
    click_handler,
    mousedown_handler2
  ];
}
var FileDisplayItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      app: 8,
      file: 0,
      pluginSettings: 1,
      contextualMenu: 2,
      customIcon: 3
    }, add_css3);
  }
};
var fileDisplayItem_default = FileDisplayItem;

// src/ui/starredFiles.svelte
function add_css4(target) {
  append_styles(target, "svelte-1i3g8fa", ".home-tab-starred-files-container.svelte-1i3g8fa{display:flex;align-items:baseline;justify-content:center;flex-wrap:wrap;width:65%;max-width:900px;padding-top:30px;margin:auto}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let filedisplayitem;
  let current;
  filedisplayitem = new fileDisplayItem_default({
    props: {
      file: ctx[10].file,
      customIcon: ctx[10].iconId,
      app: ctx[3],
      pluginSettings: ctx[1],
      contextualMenu: ctx[4]
    }
  });
  filedisplayitem.$on("itemMenu", ctx[7]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(filedisplayitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(filedisplayitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const filedisplayitem_changes = {};
      if (dirty & 1)
        filedisplayitem_changes.file = ctx[10].file;
      if (dirty & 1)
        filedisplayitem_changes.customIcon = ctx[10].iconId;
      if (dirty & 2)
        filedisplayitem_changes.pluginSettings = ctx[1];
      filedisplayitem.$set(filedisplayitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filedisplayitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filedisplayitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(filedisplayitem, detaching);
    }
  };
}
function create_fragment12(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[10].file.path;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "home-tab-starred-files-container svelte-1i3g8fa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 31) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { starredFileList } = $$props;
  let { pluginSettings } = $$props;
  let { starredFileManager: starredFileManager2 } = $$props;
  const app2 = view.leaf.app;
  let selectedFile;
  const selectIconModal = new IconSelectionModal(app2, void 0, (icon) => starredFileManager2.updateStarredFileIcon(selectedFile, icon));
  const contextualMenu = new import_obsidian7.Menu().addItem((item) => item.setTitle("Unstar file").setIcon("star-off").onClick((e) => removeStar(selectedFile))).addSeparator().addItem((item) => item.setTitle("Set custom icon").setIcon("plus").onClick(() => selectIconModal.open())).setUseNativeMenu(app2.vault.config.nativeMenus);
  const removeStar = (file) => {
    if (app2.internalPlugins.getPluginById("starred")) {
      app2.internalPlugins.plugins.starred.instance.toggleFileStar(file);
    } else {
      new import_obsidian7.Notice("Starred plugin is not enabled");
    }
  };
  const itemMenu_handler = (e) => $$invalidate(2, selectedFile = e.detail.file);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(5, view = $$props2.view);
    if ("starredFileList" in $$props2)
      $$invalidate(0, starredFileList = $$props2.starredFileList);
    if ("pluginSettings" in $$props2)
      $$invalidate(1, pluginSettings = $$props2.pluginSettings);
    if ("starredFileManager" in $$props2)
      $$invalidate(6, starredFileManager2 = $$props2.starredFileManager);
  };
  return [
    starredFileList,
    pluginSettings,
    selectedFile,
    app2,
    contextualMenu,
    view,
    starredFileManager2,
    itemMenu_handler
  ];
}
var StarredFiles = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      view: 5,
      starredFileList: 0,
      pluginSettings: 1,
      starredFileManager: 6
    }, add_css4);
  }
};
var starredFiles_default = StarredFiles;

// src/ui/recentFiles.svelte
var import_obsidian8 = require("obsidian");
function add_css5(target) {
  append_styles(target, "svelte-1xy0abl", ".home-tab-recent-files-container.svelte-1xy0abl{width:65%;display:flex;flex-direction:column;padding-top:20px;margin:auto}.home-tab-recent-files-title.svelte-1xy0abl{text-align:center;font-weight:600;font-size:var(--font-ui-large);padding-bottom:5px}.home-tab-recent-files-wrapper.svelte-1xy0abl{display:flex;max-width:900px;align-items:center;justify-content:center;flex-wrap:wrap;margin:auto}@media(max-width: 600px){.home-tab-recent-files-container.svelte-1xy0abl{padding-bottom:75px}}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let first;
  let filedisplayitem;
  let current;
  filedisplayitem = new fileDisplayItem_default({
    props: {
      file: ctx[8].file,
      app: ctx[3],
      pluginSettings: ctx[1],
      contextualMenu: ctx[4]
    }
  });
  filedisplayitem.$on("itemMenu", ctx[7]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(filedisplayitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(filedisplayitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const filedisplayitem_changes = {};
      if (dirty & 1)
        filedisplayitem_changes.file = ctx[8].file;
      if (dirty & 2)
        filedisplayitem_changes.pluginSettings = ctx[1];
      filedisplayitem.$set(filedisplayitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filedisplayitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filedisplayitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(filedisplayitem, detaching);
    }
  };
}
function create_fragment13(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].file.path;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Recent files";
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "home-tab-recent-files-title svelte-1xy0abl");
      attr(div1, "class", "home-tab-recent-files-wrapper svelte-1xy0abl");
      attr(div2, "class", "home-tab-recent-files-container svelte-1xy0abl");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 31) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block3, null, get_each_context3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { recentFileList } = $$props;
  let { pluginSettings } = $$props;
  let { recentFileManager } = $$props;
  const app2 = view.leaf.app;
  let selectedFile;
  let contextualMenu = new import_obsidian8.Menu().addItem((item) => item.setTitle("Hide file").setIcon("eye-off").onClick(() => recentFileManager.removeRecentFile(selectedFile))).setUseNativeMenu(app2.vault.config.nativeMenus);
  const itemMenu_handler = (e) => $$invalidate(2, selectedFile = e.detail.file);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(5, view = $$props2.view);
    if ("recentFileList" in $$props2)
      $$invalidate(0, recentFileList = $$props2.recentFileList);
    if ("pluginSettings" in $$props2)
      $$invalidate(1, pluginSettings = $$props2.pluginSettings);
    if ("recentFileManager" in $$props2)
      $$invalidate(6, recentFileManager = $$props2.recentFileManager);
  };
  return [
    recentFileList,
    pluginSettings,
    selectedFile,
    app2,
    contextualMenu,
    view,
    recentFileManager,
    itemMenu_handler
  ];
}
var RecentFiles = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      view: 5,
      recentFileList: 0,
      pluginSettings: 1,
      recentFileManager: 6
    }, add_css5);
  }
};
var recentFiles_default = RecentFiles;

// src/ui/homepage.svelte
function add_css6(target) {
  append_styles(target, "svelte-1yjwmjb", ".home-tab-logo.svelte-1yjwmjb svg.svelte-1yjwmjb{height:unset;width:unset}.home-tab-wordmark-container.svelte-1yjwmjb.svelte-1yjwmjb{display:flex;align-items:center;justify-content:center;margin-bottom:50px}.home-tab.svelte-1yjwmjb:not(.embedded) .home-tab-wordmark-container.svelte-1yjwmjb{padding-top:100px}.home-tab-wordmark.svelte-1yjwmjb h1.svelte-1yjwmjb{margin:unset}@media(max-width: 600px){.home-tab-wordmark-container.svelte-1yjwmjb.svelte-1yjwmjb{display:flex;flex-direction:column;justify-content:center}.home-tab-wordmark.svelte-1yjwmjb.svelte-1yjwmjb{text-align:center}}@media(max-height: 1000px){.home-tab.svelte-1yjwmjb:not(.embedded) .home-tab-wordmark-container.svelte-1yjwmjb{padding-top:10px}}");
}
function create_if_block_22(ctx) {
  let div1;
  let t0;
  let div0;
  let h1;
  let t1_value = ctx[5].wordmark + "";
  let t1;
  let if_block = !(ctx[5].logoType === "none") && create_if_block_32(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      h1 = element("h1");
      t1 = text(t1_value);
      set_style(h1, "font-family", ctx[5].customFont === "interfaceFont" ? "var(--interface-font)" : ctx[5].customFont === "textFont" ? "var(--font-text)" : ctx[5].customFont === "monospaceFont" ? "var(--font-monospace)" : ctx[5].font);
      set_style(h1, "font-size", ctx[5].fontSize);
      set_style(h1, "font-weight", ctx[5].fontWeight.toString());
      set_style(h1, "color", ctx[5].fontColorType === "default" ? "" : ctx[5].fontColorType === "accentColor" ? "var(--interactive-accent)" : ctx[5].fontColor);
      attr(h1, "class", "svelte-1yjwmjb");
      attr(div0, "class", "home-tab-wordmark svelte-1yjwmjb");
      attr(div1, "class", "home-tab-wordmark-container svelte-1yjwmjb");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, h1);
      append(h1, t1);
    },
    p(ctx2, dirty) {
      if (!(ctx2[5].logoType === "none")) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_32(ctx2);
          if_block.c();
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32 && t1_value !== (t1_value = ctx2[5].wordmark + ""))
        set_data(t1, t1_value);
      if (dirty & 32) {
        set_style(h1, "font-family", ctx2[5].customFont === "interfaceFont" ? "var(--interface-font)" : ctx2[5].customFont === "textFont" ? "var(--font-text)" : ctx2[5].customFont === "monospaceFont" ? "var(--font-monospace)" : ctx2[5].font);
      }
      if (dirty & 32) {
        set_style(h1, "font-size", ctx2[5].fontSize);
      }
      if (dirty & 32) {
        set_style(h1, "font-weight", ctx2[5].fontWeight.toString());
      }
      if (dirty & 32) {
        set_style(h1, "color", ctx2[5].fontColorType === "default" ? "" : ctx2[5].fontColorType === "accentColor" ? "var(--interactive-accent)" : ctx2[5].fontColor);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].logoType === "default")
      return create_if_block_42;
    if (ctx2[5].logoType === "lucideIcon" && !!ctx2[5].logo.lucideIcon)
      return create_if_block_52;
    if (ctx2[5].logoType === "imagePath" && !!ctx2[5].logo.imagePath)
      return create_if_block_6;
    if (ctx2[5].logoType === "imageLink" && !!ctx2[5].logo.imageLink)
      return create_if_block_7;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "home-tab-logo svelte-1yjwmjb");
      set_style(div, "margin-right", "calc(" + ctx[5].fontSize + "/5)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty & 32) {
        set_style(div, "margin-right", "calc(" + ctx2[5].fontSize + "/5)");
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_7(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[5].logo.imageLink))
        attr(img, "src", img_src_value);
      attr(img, "alt", "home-tab-logo");
      set_style(img, "max-width", "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      set_style(img, "max-height", "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && !src_url_equal(img.src, img_src_value = ctx2[5].logo.imageLink)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 32) {
        set_style(img, "max-width", "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")");
      }
      if (dirty & 32) {
        set_style(img, "max-height", "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")");
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_6(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[7].getResourcePath(ctx[5].logo.imagePath)))
        attr(img, "src", img_src_value);
      attr(img, "alt", "home-tab-logo");
      set_style(img, "max-width", "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      set_style(img, "max-height", "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && !src_url_equal(img.src, img_src_value = ctx2[7].getResourcePath(ctx2[5].logo.imagePath))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 32) {
        set_style(img, "max-width", "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")");
      }
      if (dirty & 32) {
        set_style(img, "max-height", "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")");
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_52(ctx) {
  var _a;
  let svg;
  let raw_value = ((_a = (0, import_obsidian9.getIcon)(ctx[5].logo.lucideIcon)) == null ? void 0 : _a.innerHTML) + "";
  let svg_width_value;
  let svg_height_value;
  let svg_stroke_value;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", svg_width_value = "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      attr(svg, "height", svg_height_value = "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", svg_stroke_value = ctx[5].iconColorType === "default" ? "currentColor" : ctx[5].iconColorType === "accentColor" ? "var(--interactive-accent)" : ctx[5].iconColor);
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(svg, "class", svg_class_value = "svg-icon lucide-" + ctx[5].logo.lucideIcon + " svelte-1yjwmjb");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      svg.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 32 && raw_value !== (raw_value = ((_a2 = (0, import_obsidian9.getIcon)(ctx2[5].logo.lucideIcon)) == null ? void 0 : _a2.innerHTML) + ""))
        svg.innerHTML = raw_value;
      ;
      if (dirty & 32 && svg_width_value !== (svg_width_value = "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")")) {
        attr(svg, "width", svg_width_value);
      }
      if (dirty & 32 && svg_height_value !== (svg_height_value = "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")")) {
        attr(svg, "height", svg_height_value);
      }
      if (dirty & 32 && svg_stroke_value !== (svg_stroke_value = ctx2[5].iconColorType === "default" ? "currentColor" : ctx2[5].iconColorType === "accentColor" ? "var(--interactive-accent)" : ctx2[5].iconColor)) {
        attr(svg, "stroke", svg_stroke_value);
      }
      if (dirty & 32 && svg_class_value !== (svg_class_value = "svg-icon lucide-" + ctx2[5].logo.lucideIcon + " svelte-1yjwmjb")) {
        attr(svg, "class", svg_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_42(ctx) {
  let svg;
  let defs;
  let linearGradient;
  let stop0;
  let stop1;
  let linearGradient_id_value;
  let polygon0;
  let polygon1;
  let polygon1_fill_value;
  let polygon2;
  let polygon3;
  let polygon4;
  let svg_width_value;
  let svg_height_value;
  return {
    c() {
      svg = svg_element("svg");
      defs = svg_element("defs");
      linearGradient = svg_element("linearGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      polygon2 = svg_element("polygon");
      polygon3 = svg_element("polygon");
      polygon4 = svg_element("polygon");
      attr(stop0, "offset", "0");
      attr(stop0, "stop-color", "#6c56cc");
      attr(stop1, "offset", "1");
      attr(stop1, "stop-color", "#9785e5");
      attr(linearGradient, "id", linearGradient_id_value = ctx[8].toString());
      attr(linearGradient, "x1", "82.85");
      attr(linearGradient, "y1", "30.41");
      attr(linearGradient, "x2", "51.26");
      attr(linearGradient, "y2", "105.9");
      attr(linearGradient, "gradientTransform", "matrix(1, 0, 0, -1, -22.41, 110.97)");
      attr(linearGradient, "gradientUnits", "userSpaceOnUse");
      attr(polygon0, "points", "44.61 0 12.91 17.52 0 45.45 19.57 90.47 47.35 100 52.44 89.8 63 26.39 44.61 0");
      attr(polygon0, "fill", "#34208c");
      attr(polygon1, "points", "63 26.39 43.44 14.41 16.43 35.7 47.35 100 52.44 89.8 63 26.39");
      attr(polygon1, "fill", polygon1_fill_value = "url(#" + ctx[8] + ")");
      attr(polygon2, "points", "63 26.39 63 26.39 44.61 0 43.44 14.41 63 26.39");
      attr(polygon2, "fill", "#af9ff4");
      attr(polygon3, "points", "43.44 14.41 44.61 0 12.91 17.52 16.43 35.7 43.44 14.41");
      attr(polygon3, "fill", "#4a37a0");
      attr(polygon4, "points", "16.43 35.7 19.57 90.47 47.35 100 16.43 35.7");
      attr(polygon4, "fill", "#4a37a0");
      attr(svg, "viewBox", "0 0 65 100");
      attr(svg, "width", svg_width_value = "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      attr(svg, "height", svg_height_value = "calc(" + ctx[5].fontSize + "*" + ctx[5].logoScale + ")");
      attr(svg, "class", "svelte-1yjwmjb");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, defs);
      append(defs, linearGradient);
      append(linearGradient, stop0);
      append(linearGradient, stop1);
      append(svg, polygon0);
      append(svg, polygon1);
      append(svg, polygon2);
      append(svg, polygon3);
      append(svg, polygon4);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && svg_width_value !== (svg_width_value = "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")")) {
        attr(svg, "width", svg_width_value);
      }
      if (dirty & 32 && svg_height_value !== (svg_height_value = "calc(" + ctx2[5].fontSize + "*" + ctx2[5].logoScale + ")")) {
        attr(svg, "height", svg_height_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_13(ctx) {
  let starredfiles;
  let current;
  starredfiles = new starredFiles_default({
    props: {
      starredFileList: ctx[4],
      view: ctx[0],
      pluginSettings: ctx[5],
      starredFileManager: ctx[2].starredFileManager
    }
  });
  return {
    c() {
      create_component(starredfiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starredfiles, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starredfiles_changes = {};
      if (dirty & 16)
        starredfiles_changes.starredFileList = ctx2[4];
      if (dirty & 1)
        starredfiles_changes.view = ctx2[0];
      if (dirty & 32)
        starredfiles_changes.pluginSettings = ctx2[5];
      if (dirty & 4)
        starredfiles_changes.starredFileManager = ctx2[2].starredFileManager;
      starredfiles.$set(starredfiles_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starredfiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starredfiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starredfiles, detaching);
    }
  };
}
function create_if_block3(ctx) {
  let recentfiles;
  let current;
  recentfiles = new recentFiles_default({
    props: {
      recentFileList: ctx[6],
      view: ctx[0],
      pluginSettings: ctx[5],
      recentFileManager: ctx[2].recentFileManager
    }
  });
  return {
    c() {
      create_component(recentfiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recentfiles, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recentfiles_changes = {};
      if (dirty & 64)
        recentfiles_changes.recentFileList = ctx2[6];
      if (dirty & 1)
        recentfiles_changes.view = ctx2[0];
      if (dirty & 32)
        recentfiles_changes.pluginSettings = ctx2[5];
      if (dirty & 4)
        recentfiles_changes.recentFileManager = ctx2[2].recentFileManager;
      recentfiles.$set(recentfiles_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recentfiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recentfiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recentfiles, detaching);
    }
  };
}
function create_fragment14(ctx) {
  var _a;
  let main2;
  let t0;
  let searchbar;
  let t1;
  let t2;
  let current;
  let if_block0 = !((_a = ctx[3]) == null ? void 0 : _a.searchbarOnly) && create_if_block_22(ctx);
  searchbar = new searchBar_default({
    props: {
      HomeTabSearchBar: ctx[1],
      embedded: ctx[3] ? true : false
    }
  });
  let if_block1 = ctx[9] && ctx[4] && ctx[11] && create_if_block_13(ctx);
  let if_block2 = ctx[2].recentFileManager && ctx[6].length > 0 && ctx[10] && create_if_block3(ctx);
  return {
    c() {
      main2 = element("main");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(searchbar.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr(main2, "class", "home-tab svelte-1yjwmjb");
      toggle_class(main2, "embedded", ctx[3]);
    },
    m(target, anchor) {
      insert(target, main2, anchor);
      if (if_block0)
        if_block0.m(main2, null);
      append(main2, t0);
      mount_component(searchbar, main2, null);
      append(main2, t1);
      if (if_block1)
        if_block1.m(main2, null);
      append(main2, t2);
      if (if_block2)
        if_block2.m(main2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (!((_a2 = ctx2[3]) == null ? void 0 : _a2.searchbarOnly)) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          if_block0.m(main2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const searchbar_changes = {};
      if (dirty & 2)
        searchbar_changes.HomeTabSearchBar = ctx2[1];
      if (dirty & 8)
        searchbar_changes.embedded = ctx2[3] ? true : false;
      searchbar.$set(searchbar_changes);
      if (ctx2[9] && ctx2[4] && ctx2[11]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(main2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[2].recentFileManager && ctx2[6].length > 0 && ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 68) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(main2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 8) {
        toggle_class(main2, "embedded", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main2);
      if (if_block0)
        if_block0.d();
      destroy_component(searchbar);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { HomeTabSearchBar: HomeTabSearchBar2 } = $$props;
  let { plugin } = $$props;
  let { embeddedView = void 0 } = $$props;
  let starredFileList = [];
  let pluginSettings;
  let recentFileList = [];
  pluginSettingsStore.subscribe((settings) => {
    $$invalidate(5, pluginSettings = settings);
    if (pluginSettings.showStarredFiles) {
      starredFiles.subscribe((files) => $$invalidate(4, starredFileList = files));
    }
    if (pluginSettings.showRecentFiles) {
      recentFiles.subscribe((files) => $$invalidate(6, recentFileList = files));
    }
  });
  const vaultAdapter = app.vault.adapter;
  const gradientUniqueId = Math.random();
  const isStarredPluginEnabled = app.internalPlugins.getPluginById("starred") ? true : false;
  const renderRecentFiles = embeddedView ? embeddedView.recentFiles : pluginSettings.showRecentFiles;
  const renderStarredFiles = embeddedView ? embeddedView.starredFiles : pluginSettings.showStarredFiles;
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("HomeTabSearchBar" in $$props2)
      $$invalidate(1, HomeTabSearchBar2 = $$props2.HomeTabSearchBar);
    if ("plugin" in $$props2)
      $$invalidate(2, plugin = $$props2.plugin);
    if ("embeddedView" in $$props2)
      $$invalidate(3, embeddedView = $$props2.embeddedView);
  };
  return [
    view,
    HomeTabSearchBar2,
    plugin,
    embeddedView,
    starredFileList,
    pluginSettings,
    recentFileList,
    vaultAdapter,
    gradientUniqueId,
    isStarredPluginEnabled,
    renderRecentFiles,
    renderStarredFiles
  ];
}
var Homepage = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      view: 0,
      HomeTabSearchBar: 1,
      plugin: 2,
      embeddedView: 3
    }, add_css6);
  }
};
var homepage_default = Homepage;

// src/suggester/homeTabSuggester.ts
var import_obsidian10 = require("obsidian");
var HomeTabFileSuggester = class extends TextInputSuggester {
  constructor(app2, plugin, view, searchBar) {
    super(app2, get_store_value(searchBar.searchBarEl), get_store_value(searchBar.suggestionContainerEl), {
      containerClass: `home-tab-suggestion-container ${import_obsidian10.Platform.isPhone ? "is-phone" : ""}`,
      suggestionItemClass: "suggestion-item mod-complex",
      additionalClasses: `${plugin.settings.selectionHighlight === "accentColor" ? "use-accent-color" : ""}`,
      additionalModalInfo: plugin.settings.showShortcuts ? generateHotkeySuggestion([
        { hotkey: "\u2191\u2193", action: "to navigate" },
        { hotkey: "\u21B5", action: "to open" },
        { hotkey: "shift \u21B5", action: "to create" },
        { hotkey: "ctrl \u21B5", action: "to open in new tab" },
        { hotkey: "esc", action: "to dismiss" }
      ], "home-tab-hotkey-suggestions") : void 0
    }, plugin.settings.searchDelay);
    this.plugin = plugin;
    this.view = view;
    this.searchBar = searchBar;
    this.searchBar.activeExtEl.subscribe((element2) => this.activeExtEl = element2);
    this.app.metadataCache.onCleanCache(() => {
      this.plugin.settings.markdownOnly ? this.files = this.filterSearchFileArray("markdown", getSearchFiles(this.plugin.settings.unresolvedLinks)) : this.files = getSearchFiles(this.plugin.settings.unresolvedLinks);
      this.fuzzySearch = new FileFuzzySearch(this.files, { ...DEFAULT_FUSE_OPTIONS, ignoreLocation: true, fieldNormWeight: 1.65, keys: [{ name: "basename", weight: 1.5 }, { name: "aliases", weight: 0.1 }] });
    });
    this.scope.register(["Mod"], "Enter", (e) => {
      e.preventDefault();
      this.useSelectedItem(this.suggester.getSelectedItem(), true);
    });
    this.scope.register(["Shift"], "Enter", async (e) => {
      e.preventDefault();
      await this.handleFileCreation();
    });
    this.scope.register(["Shift", "Mod"], "Enter", async (e) => {
      e.preventDefault();
      await this.handleFileCreation(void 0, true);
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Backspace") {
        const inputValue = this.inputEl.value;
        if (inputValue != "")
          return;
        if (this.activeExt) {
          this.activeExt = null;
          this.fuzzySearch.updateSearchArray(this.files);
          this.activeExtEl.toggleClass("hide", true);
        }
      }
      if (e.key === "Tab") {
        e.preventDefault();
        const inputValue = this.inputEl.value;
        if (isValidExtension(inputValue) || isValidFileType(inputValue)) {
          this.activeExtEl.setText(inputValue);
          this.activeExtEl.toggleClass("hide", false);
          this.activeExt = inputValue;
          this.app.metadataCache.onCleanCache(() => {
            this.fuzzySearch.updateSearchArray(this.filterSearchFileArray(inputValue, this.plugin.settings.markdownOnly ? getSearchFiles(this.plugin.settings.unresolvedLinks) : this.files));
          });
          this.inputEl.value = "";
          this.suggester.setSuggestions([]);
          this.close();
        }
      }
    });
    this.view.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian10.TFile) {
        this.updateSearchfilesList(file);
      }
    }));
    this.view.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian10.TFile) {
        this.updateSearchfilesList(file);
      }
    }));
    this.view.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian10.TFile) {
        this.updateSearchfilesList(file, oldPath);
      }
    }));
    this.view.registerEvent(this.app.metadataCache.on("resolved", () => this.updateUnresolvedFiles()));
  }
  updateSearchBarContainerEl(isActive) {
    var _a;
    (_a = this.inputEl.parentElement) == null ? void 0 : _a.toggleClass("is-active", isActive);
  }
  onOpen() {
    this.updateSearchBarContainerEl(this.suggester.getSuggestions().length > 0 ? true : false);
  }
  onClose() {
    this.updateSearchBarContainerEl(false);
  }
  filterSearchFileArray(filterKey, fileArray) {
    const arrayToFilter = fileArray;
    return arrayToFilter.filter((file) => isValidExtension(filterKey) ? file.extension === filterKey : file.fileType === filterKey);
  }
  updateUnresolvedFiles() {
    const unresolvedFiles = getUnresolvedMarkdownFiles();
    let newFiles = false;
    unresolvedFiles.forEach((unresolvedFile) => {
      if (!this.files.includes(unresolvedFile)) {
        this.files.push(unresolvedFile);
        newFiles = true;
      }
    });
    if (newFiles)
      this.fuzzySearch.updateSearchArray(this.files);
  }
  updateSearchfilesList(file, oldPath) {
    this.app.metadataCache.onCleanCache(() => {
      if (oldPath) {
        this.files.splice(this.files.findIndex((f) => f.path === oldPath), 1);
        this.files.push(generateSearchFile(file));
      }
      if (file.deleted) {
        this.files.splice(this.files.findIndex((f) => f.path === file.path), 1);
      } else {
        const fileIndex = this.files.findIndex((f) => f.path === file.path);
        if (fileIndex === -1) {
          this.files.push(generateSearchFile(file));
        } else if (this.files[fileIndex].isUnresolved) {
          this.files[fileIndex] = generateSearchFile(file);
        }
      }
      this.fuzzySearch.updateSearchArray(this.files);
    });
  }
  onNoSuggestion() {
    if (!this.activeExt || this.activeExt === "markdown" || this.activeExt === "md") {
      const input = this.inputEl.value;
      if (!!input) {
        this.suggester.setSuggestions([{
          item: {
            name: `${input}.md`,
            path: `${input}.md`,
            basename: input,
            isCreated: false,
            fileType: "markdown",
            extension: "md"
          },
          refIndex: 0,
          score: 0
        }]);
        this.open();
      } else {
        this.close();
      }
    } else {
      this.close();
    }
  }
  getSuggestions(input) {
    return this.fuzzySearch.rawSearch(input, this.plugin.settings.maxResults);
  }
  useSelectedItem(selectedItem, newTab) {
    if (selectedItem.item.isCreated && selectedItem.item.file) {
      this.openFile(selectedItem.item.file, newTab);
    } else {
      this.handleFileCreation(selectedItem.item, newTab);
    }
  }
  generateDisplayElementContent(suggestion) {
    var _a;
    const contentEl = createDiv("suggestion-content");
    const suggestionTitleEl = contentEl.createDiv("suggestion-title home-tab-suggestion-title");
    const suggestionAuxEl = createDiv("suggestion-aux");
    const nameToDisplay = this.fuzzySearch.getBestMatch(suggestion, this.inputEl.value);
    const fileNameEl = suggestionTitleEl.createEl("span", { text: nameToDisplay });
    if (suggestion.item.fileType != "markdown") {
      suggestionTitleEl.createEl("div", { text: suggestion.item.extension, cls: "nav-file-tag home-tab-suggestion-file-tag" });
    }
    if (suggestion.item.isCreated) {
      if (suggestion.item.aliases && ((_a = suggestion.item.aliases) == null ? void 0 : _a.includes(nameToDisplay))) {
        const noteEl = contentEl.createDiv("home-tab-suggestion-description");
        addLucideIcon(noteEl, "forward", { size: 15, ariaLabel: "Alias of" });
        noteEl.createEl("span", { text: suggestion.item.basename });
      }
    } else {
      const iconContainerEl = suggestionAuxEl.createDiv("home-tab-suggestion-tip");
      if (suggestion.item.isUnresolved) {
        suggestionTitleEl.addClass("is-unresolved");
        addLucideIcon(iconContainerEl, "file-plus", { size: 15, ariaLabel: "Not created yet, select to create" });
      } else {
        suggestionAuxEl.createDiv("suggestion-hotkey").createEl("span", { text: "Enter to create" });
        addLucideIcon(iconContainerEl, "file-question", { size: 15, ariaLabel: "Not exists yet, select to create" });
      }
    }
    if (suggestion.item.isCreated || suggestion.item.isUnresolved) {
      if (this.plugin.settings.showPath) {
        const pathEl = suggestionAuxEl.createEl("div", { cls: "home-tab-suggestion-filepath", attr: { "aria-label": "File path" } });
        const pathText = suggestion.item.file ? suggestion.item.file.parent.name : getParentFolderFromPath(suggestion.item.path);
        const iconContainer = pathEl.createDiv("");
        addLucideIcon(iconContainer, "folder", { size: 15 });
        pathEl.createEl("span", { text: pathText, cls: "home-tab-file-path" });
      }
    }
    return [contentEl, suggestionAuxEl];
  }
  async handleFileCreation(selectedFile, newTab) {
    var _a;
    let newFile;
    if (selectedFile == null ? void 0 : selectedFile.isUnresolved) {
      const folderPath = selectedFile.path.replace(selectedFile.name, "");
      if (!await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      newFile = await this.app.vault.create(selectedFile.path, "");
    } else {
      const input = this.inputEl.value;
      const files = this.files.filter((file) => file.fileType === "markdown");
      if (files.map((file) => file.basename).includes(input)) {
        const fileToOpen = (_a = files.find((f) => f.basename === input)) == null ? void 0 : _a.file;
        if (fileToOpen) {
          return this.openFile(fileToOpen, newTab);
        }
      }
      newFile = await this.app.vault.create((0, import_obsidian10.normalizePath)(`${this.app.fileManager.getNewFileParent("").path}/${input}.md`), "");
    }
    this.openFile(newFile, newTab);
  }
  openFile(file, newTab) {
    if (newTab) {
      this.app.workspace.createLeafInTabGroup().openFile(file);
    } else {
      this.view.leaf.openFile(file);
    }
  }
};

// src/homeView.ts
var VIEW_TYPE = "home-tab-view";
var HomeTabSearchBar = class {
  constructor(plugin, view, onLoad) {
    this.view = view;
    this.plugin = plugin;
    this.searchBarEl = writable();
    this.activeExtEl = writable();
    this.suggestionContainerEl = writable();
    this.onLoad = onLoad;
  }
  focusSearchbar() {
    if (this.searchBarEl)
      get_store_value(this.searchBarEl).focus();
  }
  load() {
    this.fileSuggester = new HomeTabFileSuggester(this.plugin.app, this.plugin, this.view, this);
    this.onLoad ? this.onLoad() : null;
  }
};
var EmbeddedHomeTab = class extends import_obsidian11.MarkdownRenderChild {
  constructor(containerEl, view, plugin, codeBlockContent) {
    super(containerEl);
    this.view = view;
    this.plugin = plugin;
    this.parseCodeBlockContent(codeBlockContent);
    this.searchBar = new HomeTabSearchBar(plugin, view);
  }
  onload() {
    this.homepage = new homepage_default({
      target: this.containerEl,
      props: {
        plugin: this.plugin,
        view: this.view,
        HomeTabSearchBar: this.searchBar,
        embeddedView: this
      }
    });
    this.searchBar.load();
  }
  onunload() {
    this.plugin.activeEmbeddedHomeTabViews.splice(this.plugin.activeEmbeddedHomeTabViews.findIndex((item) => item.view == this.view), 1);
    this.searchBar.fileSuggester.close();
    this.homepage.$destroy();
  }
  parseCodeBlockContent(codeBlockContent) {
    codeBlockContent.split("\n").map((line) => line.trim()).forEach((line) => {
      switch (true) {
        case line === "":
          break;
        case line === "only search bar":
          this.searchbarOnly = true;
          break;
        case line === "show recent files":
          this.recentFiles = true;
          break;
        case line === "show starred files":
          this.starredFiles = true;
          break;
      }
    });
  }
};
var HomeTabView = class extends import_obsidian11.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.navigation = true;
    this.allowNoFile = true;
    this.icon = "search";
    this.searchBar = new HomeTabSearchBar(this.plugin, this);
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Home tab";
  }
  async onOpen() {
    this.homepage = new homepage_default({
      target: this.contentEl,
      props: {
        plugin: this.plugin,
        view: this,
        HomeTabSearchBar: this.searchBar
      }
    });
    this.searchBar.load();
    this.searchBar.focusSearchbar();
  }
  async onClose() {
    this.searchBar.fileSuggester.close();
    this.homepage.$destroy();
  }
};

// src/settings.ts
var import_obsidian12 = require("obsidian");

// src/suggester/imageSuggester.ts
var ImageFileSuggester = class extends PopoverTextInputSuggester {
  constructor(app2, inputEl, viewOptions) {
    super(app2, inputEl, viewOptions);
    this.fuzzySearch = new ImageFileFuzzySearch(void 0, { ...DEFAULT_FUSE_OPTIONS, ignoreLocation: true, keys: ["name"] });
  }
  getSuggestions(input) {
    return this.fuzzySearch.filteredSearch(input, 0.25, 15);
  }
  useSelectedItem(selectedItem) {
    this.inputEl.value = selectedItem.item.path;
    this.inputEl.trigger("input");
    this.close();
  }
  generateDisplayElementContent(suggestion) {
    return [createEl("span", { text: suggestion.item.name })];
  }
};

// src/utils/cssUnitValidator.ts
function cssUnitValidator(inputString) {
  const regex = /\d+(?:cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)(?!.)/g;
  if (regex.test(inputString)) {
    return true;
  }
  return false;
}

// src/utils/isLink.ts
function isLink(string) {
  const urlPattern = /(?:https?):\/\/(\w+:?\w*)?(\S+)(:\d+)?(\/|\/([\w#!:.?+=&%!\-\/]))?/;
  return !!urlPattern.test(string);
}

// src/suggester/fontSuggester.ts
var import_font_list = __toESM(require_font_list());
var fontSuggester = class extends PopoverTextInputSuggester {
  constructor(app2, inputEl, viewOptions, renderFont) {
    super(app2, inputEl, viewOptions);
    this.renderFont = renderFont;
    this.getInstalledFonts().then((fontList) => this.fuzzySearch = new ArrayFuzzySearch(fontList));
  }
  async getInstalledFonts() {
    if (!this.fontList) {
      this.fontList = await (0, import_font_list.getFonts)();
    }
    return this.fontList;
  }
  getSuggestions(input) {
    return this.fuzzySearch.filteredSearch(input, 0.25, 15);
  }
  useSelectedItem(selectedItem) {
    this.inputEl.value = selectedItem.item.replace(/"/g, ``);
    this.inputEl.trigger("input");
    this.close();
  }
  generateDisplayElementContent(suggestion) {
    const suggestionContentEl = createDiv("suggestion-content");
    const suggestionTitleEl = suggestionContentEl.createDiv("suggestion-title");
    suggestionTitleEl.appendText(suggestion.item.replace(/"/g, ``));
    if (this.renderFont) {
      suggestionTitleEl.style.fontFamily = suggestion.item;
    }
    const suggestionAuxEl = createDiv("suggestion-aux");
    return [suggestionContentEl, suggestionAuxEl];
  }
  onNoSuggestion() {
    const input = this.inputEl.value;
    if (!input) {
      const suggestions = [];
      this.fontList.forEach((font) => {
        suggestions.push({
          item: font,
          refIndex: 0,
          score: 0
        });
      });
      this.suggester.setSuggestions(suggestions);
      this.open();
    } else {
      this.close();
    }
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  logoType: "default",
  logo: {
    lucideIcon: "",
    imagePath: "",
    imageLink: ""
  },
  logoScale: 1.2,
  iconColorType: "default",
  wordmark: "Obsidian",
  customFont: "interfaceFont",
  fontSize: "4em",
  fontColorType: "default",
  fontWeight: 600,
  maxResults: 5,
  showStarredFiles: app.internalPlugins.getPluginById("starred") ? true : false,
  showRecentFiles: false,
  maxRecentFiles: 5,
  storeRecentFile: true,
  showPath: true,
  selectionHighlight: "default",
  showShortcuts: true,
  markdownOnly: false,
  unresolvedLinks: false,
  recentFilesStore: [],
  starredFileStore: [],
  searchDelay: 0,
  replaceNewTabs: true,
  newTabOnStart: false,
  closePreviousSessionTabs: false
};
var HomeTabSettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Home tab settings" });
    containerEl.createEl("h2", { text: "General settings" });
    new import_obsidian12.Setting(containerEl).setName("Replace new tabs with Home tab").addToggle((toggle) => toggle.setValue(this.plugin.settings.replaceNewTabs).onChange((value) => {
      this.plugin.settings.replaceNewTabs = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Open new Home tab on Obsidian start").setDesc("If a Home tab is already open it'll focus it instead of opening a new one.").addToggle((toggle) => toggle.setValue(this.plugin.settings.newTabOnStart).onChange((value) => {
      this.plugin.settings.newTabOnStart = value;
      this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.newTabOnStart) {
      new import_obsidian12.Setting(containerEl).setName("Close previous session tabs on start").setDesc("This will closes all the tabs and leave only one Home tab when opening Obsidian.").addToggle((toggle) => toggle.setValue(this.plugin.settings.closePreviousSessionTabs).onChange((value) => {
        this.plugin.settings.closePreviousSessionTabs = value;
        this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h2", { text: "Search settings" });
    new import_obsidian12.Setting(containerEl).setName("Search only markdown files").addToggle((toggle) => toggle.setValue(this.plugin.settings.markdownOnly).onChange((value) => {
      this.plugin.settings.markdownOnly = value;
      this.plugin.saveSettings();
      this.plugin.refreshOpenViews();
    }));
    new import_obsidian12.Setting(containerEl).setName("Show uncreated files").addToggle((toggle) => toggle.setValue(this.plugin.settings.unresolvedLinks).onChange((value) => {
      this.plugin.settings.unresolvedLinks = value;
      this.plugin.saveSettings();
      this.plugin.refreshOpenViews();
    }));
    new import_obsidian12.Setting(containerEl).setName("Show file path").setDesc("Display file path at the right of the filename.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPath).onChange((value) => {
      this.plugin.settings.showPath = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Show shorcuts").setDesc("Display shortcuts under the search results.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showShortcuts).onChange((value) => {
      this.plugin.settings.showShortcuts = value;
      this.plugin.refreshOpenViews();
      this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Search results").setDesc("Set how many results display.").addSlider((slider) => slider.setLimits(1, 25, 1).setValue(this.plugin.settings.maxResults).setDynamicTooltip().onChange((value) => {
      this.plugin.settings.maxResults = value;
      this.plugin.saveSettings();
    })).then((settingEl) => this.addResetButton(settingEl, "maxResults"));
    new import_obsidian12.Setting(containerEl).setName("Search delay").setDesc("The value is in milliseconds.").addSlider((slider) => slider.setLimits(0, 500, 10).setValue(this.plugin.settings.searchDelay).setDynamicTooltip().onChange((value) => {
      this.plugin.settings.searchDelay = value;
      this.plugin.saveSettings();
      this.plugin.refreshOpenViews();
    })).then((settingEl) => this.addResetButton(settingEl, "searchDelay"));
    containerEl.createEl("h2", { text: "Files display" });
    if (app.internalPlugins.getPluginById("starred")) {
      new import_obsidian12.Setting(containerEl).setName("Show starred files").setDesc("Show starred files under the search bar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStarredFiles).onChange((value) => {
        this.plugin.settings.showStarredFiles = value;
        this.plugin.saveSettings();
        this.plugin.refreshOpenViews();
      }));
    }
    new import_obsidian12.Setting(containerEl).setName("Show recent files").setDesc("Display recent files under the search bar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRecentFiles).onChange((value) => {
      this.plugin.settings.showRecentFiles = value;
      this.plugin.saveSettings();
      this.display();
      this.plugin.refreshOpenViews();
    }));
    if (this.plugin.settings.showRecentFiles) {
      new import_obsidian12.Setting(containerEl).setName("Store last recent files").setDesc("Remember the recent files of the previous session.").addToggle((toggle) => toggle.setValue(this.plugin.settings.storeRecentFile).onChange((value) => {
        this.plugin.settings.storeRecentFile = value;
        this.plugin.saveSettings();
      }));
      new import_obsidian12.Setting(containerEl).setName("Recent files").setDesc("Set how many recent files display.").addSlider((slider) => slider.setValue(this.plugin.settings.maxRecentFiles).setLimits(1, 25, 1).setDynamicTooltip().onChange((value) => {
        this.plugin.recentFileManager.onNewMaxListLenght(value);
        this.plugin.settings.maxRecentFiles = value;
        this.plugin.saveSettings();
      })).then((settingEl) => this.addResetButton(settingEl, "maxRecentFiles"));
    }
    containerEl.createEl("h2", { text: "Appearance" });
    const logoTypeSetting = new import_obsidian12.Setting(containerEl).setName("Logo").setDesc("Remove or set a custom logo. Accepts local files, links to images or lucide icon ids.");
    (_a = logoTypeSetting.descEl.parentElement) == null ? void 0 : _a.addClass("ultra-compressed");
    let invalidInputIcon;
    logoTypeSetting.addExtraButton((button) => {
      button.setIcon("alert-circle").setTooltip("The path/link/icon is not valid.");
      invalidInputIcon = button.extraSettingsEl;
      invalidInputIcon.toggleVisibility(false);
      invalidInputIcon.addClass("mod-warning");
    });
    if (this.plugin.settings.logoType === "imagePath" || this.plugin.settings.logoType === "imageLink" || this.plugin.settings.logoType === "lucideIcon") {
      logoTypeSetting.addSearch((text2) => {
        var _a2;
        if (this.plugin.settings.logoType === "imagePath") {
          new ImageFileSuggester(this.app, text2.inputEl, {
            isScrollable: true,
            style: `max-height: 200px`
          });
        } else if (this.plugin.settings.logoType === "lucideIcon") {
          new iconSuggester(this.app, text2.inputEl, {
            isScrollable: true,
            style: `max-height: 200px`
          }, true);
        }
        (_a2 = text2.setPlaceholder("Type anything ... ").setValue(this.plugin.settings.logo[this.plugin.settings.logoType] != "" ? this.plugin.settings.logo[this.plugin.settings.logoType] : "").onChange(async (value) => {
          if (value === "" || value == "/") {
            invalidInputIcon.toggleVisibility(false);
            return;
          }
          if (this.plugin.settings.logoType === "imagePath") {
            const normalizedPath = (0, import_obsidian12.normalizePath)(value);
            if (await app.vault.adapter.exists(normalizedPath)) {
              invalidInputIcon.toggleVisibility(false);
              this.plugin.settings.logo["imagePath"] = normalizedPath;
              this.plugin.saveSettings();
            } else {
              invalidInputIcon.toggleVisibility(true);
            }
          } else if (this.plugin.settings.logoType === "imageLink") {
            if (isLink(value)) {
              invalidInputIcon.toggleVisibility(false);
              this.plugin.settings.logo["imageLink"] = value;
              this.plugin.saveSettings();
            } else {
              invalidInputIcon.toggleVisibility(true);
            }
          } else if (this.plugin.settings.logoType === "lucideIcon") {
            if (lucideIcons.includes(value)) {
              this.plugin.settings.logo["lucideIcon"] = value;
              this.plugin.saveSettings();
              invalidInputIcon.toggleVisibility(false);
            } else {
              invalidInputIcon.toggleVisibility(true);
            }
          }
        }).inputEl.parentElement) == null ? void 0 : _a2.addClass("wide-input-container");
      });
    }
    logoTypeSetting.addDropdown((dropdown) => dropdown.addOption("default", "Obsidian logo").addOption("imagePath", "Local image").addOption("imageLink", "Link").addOption("lucideIcon", "Lucide icon").addOption("none", "Empty").setValue(this.plugin.settings.logoType).onChange((value) => {
      this.plugin.settings.logoType = value;
      this.plugin.saveSettings();
      this.display();
    })).then((settingEl) => this.addResetButton(settingEl, "logoType"));
    if (this.plugin.settings.logoType === "lucideIcon") {
      const iconColorSetting = new import_obsidian12.Setting(containerEl).setName("Logo icon color").setDesc("Set the icon color");
      if (this.plugin.settings.iconColorType === "custom") {
        iconColorSetting.addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.iconColor ? this.plugin.settings.iconColor : "#000000").onChange((value) => {
          this.plugin.settings.iconColor = value;
          this.plugin.saveSettings();
        }));
      }
      iconColorSetting.addDropdown((dropdown) => dropdown.addOption("default", "Theme default").addOption("accentColor", "Accent color").addOption("custom", "Custom").setValue(this.plugin.settings.iconColorType).onChange((value) => {
        this.plugin.settings.iconColorType = value;
        this.plugin.saveSettings();
        this.display();
      })).then((settingEl) => this.addResetButton(settingEl, "iconColorType"));
    }
    new import_obsidian12.Setting(containerEl).setName("Logo scale").setDesc("Set the logo dimensions relative to the title font size.").addSlider((slider) => slider.setDynamicTooltip().setLimits(0.3, 3, 0.1).setValue(this.plugin.settings.logoScale).onChange((value) => {
      this.plugin.settings.logoScale = value;
      this.plugin.saveSettings();
    })).then((settingEl) => this.addResetButton(settingEl, "logoScale"));
    new import_obsidian12.Setting(containerEl).setName("Title").addText((text2) => text2.setValue(this.plugin.settings.wordmark).onChange((value) => {
      this.plugin.settings.wordmark = value;
      this.plugin.saveSettings();
    })).then((settingEl) => this.addResetButton(settingEl, "wordmark"));
    const titleFontSettings = new import_obsidian12.Setting(containerEl).setName("Title font").setDesc("Interface font, text font, and monospace font options match the fonts set in the Appearance setting tab.");
    (_b = titleFontSettings.descEl.parentElement) == null ? void 0 : _b.addClass("compressed");
    if (this.plugin.settings.customFont === "custom") {
      titleFontSettings.addSearch((text2) => {
        var _a2;
        text2.setValue(this.plugin.settings.font ? this.plugin.settings.font.replace(/"/g, "") : "");
        text2.setPlaceholder("Type anything ... ");
        const isMobile = this.app.isMobile;
        const suggester = isMobile ? void 0 : new fontSuggester(this.app, text2.inputEl, {
          isScrollable: true,
          style: `max-height: 200px;
                    width: fit-content;
                    min-width: 200px;`
        }, true);
        (_a2 = text2.onChange(async (value) => {
          value = value.indexOf(" ") >= 0 ? `"${value}"` : value;
          if (isMobile || suggester && (await suggester.getInstalledFonts()).includes(value)) {
            this.plugin.settings.font = value;
            this.plugin.saveSettings();
          }
        }).inputEl.parentElement) == null ? void 0 : _a2.addClass("wide-input-container");
      });
    }
    titleFontSettings.addDropdown((dropdown) => dropdown.addOption("interfaceFont", "Interface font").addOption("textFont", "Text font").addOption("monospaceFont", "Monospace font").addOption("custom", "Custom font").setValue(this.plugin.settings.customFont).onChange((value) => {
      this.plugin.settings.customFont = value;
      this.plugin.saveSettings();
      this.display();
    }));
    this.addResetButton(titleFontSettings, "customFont");
    let invalidFontSizeIcon;
    new import_obsidian12.Setting(containerEl).setName("Title font size").setDesc("Accepts any CSS font-size value.").addExtraButton((button) => {
      button.setIcon("alert-circle").setTooltip("The CSS unit is not valid.");
      invalidFontSizeIcon = button.extraSettingsEl;
      invalidFontSizeIcon.addClass("mod-warning");
      invalidFontSizeIcon.toggleVisibility(false);
    }).addText((text2) => text2.setValue(this.plugin.settings.fontSize).onChange((value) => {
      if (cssUnitValidator(value)) {
        this.plugin.settings.fontSize = value;
        this.plugin.saveSettings();
        invalidFontSizeIcon.toggleVisibility(false);
      } else {
        invalidFontSizeIcon.toggleVisibility(true);
      }
    })).then((settingEl) => this.addResetButton(settingEl, "fontSize"));
    new import_obsidian12.Setting(containerEl).setName("Title font weight").addSlider((slider) => slider.setLimits(100, 900, 100).setDynamicTooltip().setValue(this.plugin.settings.fontWeight).onChange((value) => {
      this.plugin.settings.fontWeight = value;
      this.plugin.saveSettings();
    })).then((settingEl) => this.addResetButton(settingEl, "fontWeight"));
    const titleColorSetting = new import_obsidian12.Setting(containerEl).setName("Title color");
    if (this.plugin.settings.fontColorType === "custom") {
      titleColorSetting.addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.fontColor ? this.plugin.settings.fontColor : "#000000").onChange((value) => {
        this.plugin.settings.fontColor = value;
        this.plugin.saveSettings();
      }));
    }
    titleColorSetting.addDropdown((dropdown) => dropdown.addOption("default", "Theme default").addOption("accentColor", "Accent color").addOption("custom", "Custom").setValue(this.plugin.settings.fontColorType).onChange((value) => {
      this.plugin.settings.fontColorType = value;
      this.plugin.saveSettings();
      this.display();
    })).then((settingEl) => this.addResetButton(settingEl, "fontColorType"));
    new import_obsidian12.Setting(containerEl).setName("Selection highlight").setDesc("Set the color of the selected item.").addDropdown((dropdown) => dropdown.addOption("default", "Theme default").addOption("accentColor", "Accent color").setValue(this.plugin.settings.selectionHighlight).onChange((value) => {
      this.plugin.settings.selectionHighlight = value;
      this.plugin.saveSettings();
      this.plugin.refreshOpenViews();
    })).then((settingEl) => this.addResetButton(settingEl, "selectionHighlight"));
  }
  addResetButton(settingElement, settingKey, refreshView = true) {
    settingElement.addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(() => {
      this.plugin.settings[settingKey] = DEFAULT_SETTINGS[settingKey];
      this.plugin.saveSettings();
      if (refreshView) {
        this.display();
      }
    }));
  }
};

// src/recentFiles.ts
var import_obsidian13 = require("obsidian");
var RecentFileManager = class extends import_obsidian13.Component {
  constructor(app2, plugin) {
    super();
    this.app = app2;
    this.plugin = plugin;
    this.pluginSettings = plugin.settings;
  }
  onload() {
    this.registerEvent(this.app.workspace.on("file-open", async (file) => {
      this.updateRecentFiles(file);
      await this.storeRecentFiles();
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      file instanceof import_obsidian13.TFile ? this.removeRecentFile(file) : null;
      await this.storeRecentFiles();
    }));
    this.registerEvent(this.app.vault.on("rename", (file) => file instanceof import_obsidian13.TFile ? this.onFileRename() : null));
    this.loadStoredRecentFiles();
  }
  updateRecentFiles(openedFile) {
    if (openedFile) {
      recentFiles.update((filesArray) => {
        if (filesArray.some((item) => item.file === openedFile)) {
          const itemIndex = filesArray.findIndex((item) => item.file === openedFile);
          filesArray[itemIndex].timestamp = Date.now();
        } else if (filesArray.length >= this.pluginSettings.maxRecentFiles) {
          filesArray[filesArray.length - 1] = {
            file: openedFile,
            timestamp: Date.now()
          };
        } else {
          filesArray.push({
            file: openedFile,
            timestamp: Date.now()
          });
        }
        return filesArray.sort((a, b) => b.timestamp - a.timestamp);
      });
    }
  }
  removeRecentFile(file) {
    recentFiles.update((filesArray) => {
      filesArray.splice(filesArray.findIndex((recentFile) => recentFile.file == file), 1);
      return filesArray;
    });
    this.storeRecentFiles();
  }
  onNewMaxListLenght(newValue) {
    const currentLenght = get_store_value(recentFiles).length;
    if (newValue < currentLenght) {
      this.removeRecentFiles(currentLenght - newValue);
    }
  }
  removeRecentFiles(number) {
    recentFiles.update((filesArray) => {
      filesArray.splice(filesArray.length - number, number);
      return filesArray;
    });
    this.storeRecentFiles();
  }
  onFileRename() {
    recentFiles.update((filesArray) => filesArray);
  }
  async storeRecentFiles() {
    if (this.plugin.settings.storeRecentFile) {
      let storeObj = [];
      get_store_value(recentFiles).forEach((item) => storeObj.push({
        filepath: item.file.path,
        timestamp: item.timestamp
      }));
      this.plugin.settings.recentFilesStore = storeObj;
      await this.plugin.saveData(this.plugin.settings);
    }
  }
  loadStoredRecentFiles() {
    if (this.plugin.settings.storeRecentFile) {
      let filesToLoad = [];
      this.app.workspace.onLayoutReady(() => {
        this.plugin.settings.recentFilesStore.forEach((item) => {
          let file = this.app.vault.getAbstractFileByPath(item.filepath);
          if (file && file instanceof import_obsidian13.TFile) {
            filesToLoad.push({
              file,
              timestamp: item.timestamp
            });
          }
        });
        recentFiles.set(filesToLoad);
      });
    }
  }
};

// src/starredFiles.ts
var import_obsidian14 = require("obsidian");
var starredFileManager = class extends import_obsidian14.Component {
  constructor(app2, plugin, starredFileStore) {
    super();
    this.app = app2;
    this.plugin = plugin;
    this.starredFileStore = starredFileStore;
  }
  onload() {
    this.loadStoredStarredFiles();
    this.updateStarredFiles();
    this.registerEvent(this.app.internalPlugins.getPluginById("starred").instance.on("changed", () => this.updateStarredFiles()));
  }
  updateStarredFiles() {
    const starredFiles2 = this.getStarredFiles();
    this.starredFileStore.update((filesArray) => {
      const updatedArray = [];
      starredFiles2.forEach((starredFile) => {
        var _a, _b;
        updatedArray.push({
          file: starredFile,
          iconId: (_b = (_a = filesArray.find((item) => item.file === starredFile)) == null ? void 0 : _a.iconId) != null ? _b : void 0
        });
      });
      return updatedArray;
    });
    this.storeStarredFiles();
  }
  updateStarredFileIcon(file, iconId) {
    this.starredFileStore.update((filesArray) => {
      const itemIndex = filesArray.findIndex((item) => item.file === file);
      filesArray[itemIndex].iconId = iconId;
      return filesArray;
    });
    this.storeStarredFiles();
  }
  getStarredFiles() {
    if (this.app.internalPlugins.getPluginById("starred")) {
      const starredItems = app.internalPlugins.plugins.starred.instance.items;
      const starredFiles2 = [];
      starredItems.forEach((item) => {
        if (item.type === "file") {
          const file = app.vault.getAbstractFileByPath(item.path);
          if (file instanceof import_obsidian14.TFile) {
            starredFiles2.push(file);
          }
        }
      });
      return starredFiles2;
    }
    return [];
  }
  async storeStarredFiles() {
    if (this.app.internalPlugins.getPluginById("starred")) {
      let storeObj = [];
      get_store_value(this.starredFileStore).forEach((item) => storeObj.push({
        filepath: item.file.path,
        iconId: item.iconId
      }));
      this.plugin.settings.starredFileStore = storeObj;
      await this.plugin.saveData(this.plugin.settings);
    }
  }
  loadStoredStarredFiles() {
    if (this.app.internalPlugins.getPluginById("starred")) {
      let filesToLoad = [];
      this.app.workspace.onLayoutReady(() => {
        this.plugin.settings.starredFileStore.forEach((item) => {
          let file = this.app.vault.getAbstractFileByPath(item.filepath);
          if (file && file instanceof import_obsidian14.TFile) {
            filesToLoad.push({
              file,
              iconId: item.iconId
            });
          }
        });
        this.starredFileStore.set(filesToLoad);
      });
    }
  }
};

// src/main.ts
var HomeTab = class extends import_obsidian15.Plugin {
  async onload() {
    console.log("Loading home-tab plugin");
    await this.loadSettings();
    this.addSettingTab(new HomeTabSettingTab(this.app, this));
    this.registerView(VIEW_TYPE, (leaf) => new HomeTabView(leaf, this));
    this.registerEvent(this.app.workspace.on("layout-change", () => this.onLayoutChange()));
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf.view instanceof HomeTabView) {
        leaf.view.searchBar.focusSearchbar();
      }
    }));
    pluginSettingsStore.set(this.settings);
    this.activeEmbeddedHomeTabViews = [];
    this.recentFileManager = new RecentFileManager(app, this);
    this.recentFileManager.load();
    this.addCommand({
      id: "open-new-home-tab",
      name: "Open new Home tab",
      callback: () => this.activateView(false, true)
    });
    this.addCommand({
      id: "open-home-tab",
      name: "Replace current tab",
      callback: () => this.activateView(true)
    });
    this.app.workspace.onLayoutReady(() => {
      if (this.app.internalPlugins.getPluginById("starred")) {
        this.starredFileManager = new starredFileManager(app, this, starredFiles);
        this.starredFileManager.load();
      }
      this.registerMarkdownCodeBlockProcessor("search-bar", (source, el, ctx) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
        if (view) {
          let embeddedHomeTab = new EmbeddedHomeTab(el, view, this, source);
          this.activeEmbeddedHomeTabViews.push(embeddedHomeTab);
          ctx.addChild(embeddedHomeTab);
        }
      });
      if (this.settings.newTabOnStart) {
        const leaves = app.workspace.getLeavesOfType(VIEW_TYPE);
        if (leaves.length > 0) {
          app.workspace.revealLeaf(leaves[0]);
          leaves.forEach((leaf, index) => {
            if (index < 1)
              return;
            leaf.detach();
          });
        } else {
          this.activateView(false, true);
        }
        if (this.settings.closePreviousSessionTabs) {
          const leafTypes = [];
          app.workspace.iterateRootLeaves((leaf) => {
            const leafType = leaf.view.getViewType();
            if (leafTypes.indexOf(leafType) === -1 && leafType != VIEW_TYPE) {
              leafTypes.push(leafType);
            }
          });
          leafTypes.forEach((type) => app.workspace.detachLeavesOfType(type));
        }
      }
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
    this.activeEmbeddedHomeTabViews.forEach((view) => view.unload());
    this.recentFileManager.unload();
    this.starredFileManager.unload();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    pluginSettingsStore.update(() => this.settings);
  }
  onLayoutChange() {
    if (this.settings.replaceNewTabs) {
      this.activateView();
    }
  }
  activateView(overrideView, openNewTab) {
    const leaf = openNewTab ? app.workspace.getLeaf("tab") : app.workspace.getMostRecentLeaf();
    if (leaf && (overrideView || leaf.getViewState().type === "empty")) {
      leaf.setViewState({
        type: VIEW_TYPE
      });
      if (openNewTab) {
        app.workspace.revealLeaf(leaf);
      }
    }
  }
  refreshOpenViews() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE).forEach((leaf) => leaf.rebuildView());
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
